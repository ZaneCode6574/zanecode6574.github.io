<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第六章：手势检测]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%89%8B%E5%8A%BF%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[简介移动应用中一个必不可少的环节就是与用户的交互，在Android中提供了手势检测，并为手势检测提供了相应的监听。Flutter中提供的手势检测为GestureDetector。 Flutter中的手势系统分为两层，第一层是触摸原事件（指针），有相应的四种事件类型： PointerDownEvent：用户与屏幕接触产生了联系。 PointerMoveEvent：手指已从屏幕上的一个位置移动到另一个位置。 PointerUpEvent：用户已停止接触屏幕。 PointerCancelEvent：此指针的输入不再指向此应用程序。 第二层就是我们可以检测到的手势，主要分为三大类，包括轻击、拖动和缩放。 本章通过介绍手势的处理方法，来展示Flutter手势的基本用法。内容如下： 用GestureDetector进行手势检测 用Dismissible实现滑动删除 使用GestureDetector进行手势检测GestureDetector可以进行手势检测，比如点击一次、双击、长按、垂直拖动及水平拖动等。 制作一个自定义按钮，点击时显示“你已按下” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyButton extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; //一定要把被触摸的组件放在GestureDetector里面 return GestureDetector( onTap: ()&#123; //底部消息提示 final snackBar=new SnackBar(content: new Text("你已按下"),); Scaffold.of(context).showSnackBar(snackBar); &#125;, //添加容器接收触摸动作 child: Container( padding: new EdgeInsets.all(12.0), decoration: BoxDecoration( color: Theme.of(context).buttonColor, borderRadius: BorderRadius.circular(10.0) ), child: Text('测试按钮'), ), ); &#125;&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: '测试手势', home: Scaffold( appBar: AppBar( title: Text('测试手势'), ), body: Center( child: new MyButton(), ), ), ); &#125;&#125; Dismissible实现滑动删除滑动删除模式在很多移动应用中很常见。例如，我们在整理手机通讯录时，希望能快速删除一些联系人，一般用手指轻轻一滑即可以实现删除功能。Flutter通过提供Dismissible组件使这项任务变得简单。 删除列表中某一项数据 123456789101112131415161718192021222324252627282930313233343536373839import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; //构建30条列表数据 List&lt;String&gt; items=new List&lt;String&gt;.generate(30, (i)=&gt;"列表项$&#123;i+1&#125;"); @override Widget build(BuildContext context) &#123; return MaterialApp( title: '滑动删除', home: Scaffold( appBar: AppBar( title: Text('手势检测'), ), body: new ListView.builder( itemCount: items.length, itemBuilder: (context,index)&#123; //提出被删除的项 final item=items[index]; //返回一个可以被删除的列表项 return new Dismissible(key: Key(item), onDismissed: (direction)&#123; items.removeAt(index); //弹出消息提示被删除了 Scaffold.of(context).showSnackBar(SnackBar(content: Text('$item 被删除了！'))); &#125;, child: ListTile(title: Text("$item"),), ); &#125;, ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章：页面布局]]></title>
    <url>%2F2019%2F03%2F01%2F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[简介 基础布局处理 宽高尺寸处理 列表及表格布局 其他布局处理 布局综合示例 基础布局基础布局组件包括容器布局，各种缩放、排列方式的组件 Container（容器布局）Container（容器布局）在Flutter里大量使用，它是一个组合Widget，内部有绘制Widget、定位Widget和尺寸Widget。Container组件的常见属性请参考“容器组件”的介绍。 准备几张图片，在项目下新建一个images文件夹，放入图片，配置pubspec.yaml文件，添加图片路径 1234assets:- images/xxx.jpg- images/xxx.jpg- images/xxx.jpg 编写代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; Widget container=new Container( decoration: new BoxDecoration( color: Colors.grey, ), child: new Column( children: &lt;Widget&gt;[ new Row( children: &lt;Widget&gt;[ //使用Expanded防止内容溢出 new Expanded(child: new Container( width: 150, height: 150, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.blueGrey), borderRadius: const BorderRadius.all(const Radius.circular(8.0)) ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/1.png'), ),), new Expanded(child: new Container( width: 150, height: 150, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.blueGrey), borderRadius: const BorderRadius.all(const Radius.circular(8.0)) ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/1.png'), ),), ], ), new Row( children: &lt;Widget&gt;[ //使用Expanded防止内容溢出 new Expanded(child: new Container( width: 150, height: 150, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.blueGrey), borderRadius: const BorderRadius.all(const Radius.circular(8.0)) ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/1.png'), ),), new Expanded(child: new Container( width: 150, height: 150, decoration: new BoxDecoration( border: new Border.all(width: 10.0,color: Colors.blueGrey), borderRadius: const BorderRadius.all(const Radius.circular(8.0)) ), margin: const EdgeInsets.all(4.0), child: new Image.asset('images/1.png'), ),), ], ), ], ), ); return MaterialApp( title: 'Container布局测试', home: Scaffold( appBar: AppBar( title: Text('Container布局'), ), body: container, ), ); &#125;&#125; Center（居中布局）子元素处于水平垂直居中 123456789101112131415161718192021222324import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Center布局测试', home: Scaffold( appBar: AppBar( title: Text('Center测试'), ), body: Center( child: new Text('测试测试',style: TextStyle(fontSize: 36.0),), ), ), ); &#125;&#125; Padding（填充布局）Padding即为填充组件，用于处理容器与其子元素之间的间距，与padding属性对应的是margin属性，margin处理容器与其他组件之间的间距。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Padding测试', home: Scaffold( appBar: AppBar( title: Text('Padding测试'), ), body: Center( child: new Container( width: 300.0, height: 300.0, padding: EdgeInsets.all(30.0), decoration: new BoxDecoration( color: Colors.white, border: new Border.all( color: Colors.green, width: 8.0 ) ), child: new Container( width: 200.0, height: 200.0, decoration: new BoxDecoration( color: Colors.white, border: new Border.all( color: Colors.blue, width: 8.0 ) ), child: new FlutterLogo(), ), ), ), ), ); &#125;&#125; Align（对齐布局）Align组件即对齐组件，能将子组件按指定方式对齐，并根据子组件的大小调整自己的大小。 这里放入几张图片 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Stack( children: &lt;Widget&gt;[ //左上角 new Align( alignment: new FractionalOffset(0.0, 0.0), child: new Image.asset('images/1.png',width: 128.0,height: 128.0,), ), //右上角 new Align( alignment: new FractionalOffset(1.0, 0.0), child: new Image.asset('images/1.png',width: 128.0,height: 128.0,), ), //水平垂直居中 new Align( alignment: FractionalOffset.center, child: new Image.asset('images/1.png',width: 128.0,height: 128.0,), ), //底部居左 new Align( alignment: FractionalOffset.bottomLeft, child: new Image.asset('images/1.png',width: 128.0,height: 128.0,), ), //底部居左 new Align( alignment: FractionalOffset.bottomRight, child: new Image.asset('images/1.png',width: 128.0,height: 128.0,), ), ], ), ), ); &#125;&#125; Row（水平布局）水平布局是一种常用的布局方式，我们主要使用Row组件来完成子组件在水平方向的排列。对Row来说，水平方向是主轴，垂直方向次轴，可以完全参照Web中的Flex布局（虽然我不知道这是啥） 12345678910111213141516171819202122232425262728import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: new Row( children: &lt;Widget&gt;[ new Expanded(child: new Text('左侧文本',textAlign: TextAlign.center,)), new Expanded(child: new Text('中间文本',textAlign: TextAlign.center,)), new Expanded(child: new FittedBox(fit: BoxFit.contain,child: const FlutterLogo(),)) ], ), ), ); &#125;&#125; Column（垂直布局）垂直布局是一种常用的布局方式，我们主要使用Column组件来完成对子组件纵向的排列。 12345678910111213141516171819202122232425262728293031import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: new Column( children: &lt;Widget&gt;[ new Text('垂直布局'), new Text('Flutter'), new Expanded(child: new FittedBox( fit: BoxFit.contain, child: const FlutterLogo(), )) ], ), ), ); &#125;&#125; 增加水平方向靠左对齐，主轴方向最小化处理，其中最后一行文字字号专门放大 123456789101112131415161718192021222324252627282930313233import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: new Column( crossAxisAlignment: CrossAxisAlignment.start, //水平方向靠左对齐 mainAxisSize: MainAxisSize.min, //主轴方向最小化处理 children: &lt;Widget&gt;[ new Text('垂直布局'), new Text('Flutter'), new Expanded(child: new FittedBox( fit: BoxFit.contain, child: const FlutterLogo(), )) ], ), ), ); &#125;&#125; FittedBox（缩放布局）FittedBox组件主要做两件事情，缩放（Scale）和位置调整（Position）。 FittedBox会在自己的尺寸范围内缩放并调整child位置，使child适合其尺寸。类似ImageView组件，它是将图片在其范围内按照规则进行缩放位置调整。FittedBox跟ImageView有些类似，可以猜出，它肯定有一个类似于ScaleType的属性。 布局行为分两种情况 如果外部有约束的话，按照外部约束调整自身尺寸，然后缩放调整child，按照指定的条件进行布局。 如果没有外部约束条件，则跟child尺寸一致，指定的缩放以及位置属性将不起作用。 fit和alignment两个重要属性fitfit：缩放的方式，默认的属性是BoxFit.contain，child在FittedBox范围内，尽可能大，但是不超出其尺寸。这里需要注意一点，contain是在保持着child宽高比的大前提下，尽可能填满。一般情况下，宽度或者高度达到最大值时，就会停止缩放。 BoxFit.none没有任何填充模式 BoxFit.fill不按宽高比填充模式，内容不会超过容器范围 BoxFit.contain按宽高比等比填充模式，内容不会超过容器范围 BoxFit.cover按原始尺寸填充整个容器模式，内容有可能会超过容器范围 BoxFit.width及BoxFit.height分别是按宽/高填充整个容器的模式，内容不会超过容器范围 BoxFit.scaleDown会根据情况缩小范围，有时和BoxFit.contain一样，有时和BoxFit.none一样，内容不会超过容器范围 alignmentalignment：设置对齐方式，默认的属性是Alignment.center，居中显示child Stack/AlignmentStack组件的每一个子组件要么定位，要么不定位，定位的子组件是用Positioned组件包裹的。Stack组件本身包含所有不定位的子组件，子组件根据alignment属性定位（默认为左上角）。然后根据定位的子组件的top、right、bottom和left属性将它们放置在Stack组件上。 12345678910111213141516171819202122232425262728293031323334353637383940414243import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; var stack=new Stack( alignment: Alignment.topLeft, children: &lt;Widget&gt;[ //添加一个圆形头像 new CircleAvatar( backgroundImage: new AssetImage('images/1.png'), radius: 100.0, ), //上面加一个容器，容器里放文本 new Container( decoration: new BoxDecoration( color: Colors.black38 ), child: new Text("测试一下文字",style: new TextStyle(fontSize: 22.0,fontWeight: FontWeight.bold,color: Colors.white),), ), ], ); @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Center( child: stack, ), ), ); &#125;&#125; Stack/PositionedPisitioned组件是用来定位的，Stack使用Positioned布局主要是因为在Stack组件里面需要包裹一个定位组件 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Center( child: Stack( children: &lt;Widget&gt;[ //添加图片 new Image(image: NetworkImage("https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1541655494719&amp;di=6b49d24b5172a34828b9d6506e4bf100&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn11%2F266%2Fw640h426%2F20180813%2Fce56-hhqtawx8254771.jpg")), new Positioned( bottom: 0.0, right: 0.0, child: Text('Hello',style: new TextStyle(fontSize: 36.0,fontWeight: FontWeight.bold,fontFamily: 'serif',color: Colors.white),), ), ], ), ), ), ); &#125;&#125; IndexedStackIndexedStack继承自Stack，它的作用是显示第index个child，其他child都是不可见的，所以IndexedStack的尺寸永远是和最大的子节点尺寸一致。由于IndexedStack是继承自Stack的，所以它只比Stack多了一个index属性，即对应child的索引。 这里我们改造Stack布局示例，把Stack组件替换为IndexedStack组件，同时添加index属性值，当index设置为1时，运行结果只显示“我是超级飞侠”几个字及它的容器。因为CircleAvatar组件索引为0，所以不显示。 1234567891011121314151617181920212223242526272829303132333435import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Center( child: IndexedStack( index: 0, children: &lt;Widget&gt;[ //添加图片 new Image(image: NetworkImage("https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1541655494719&amp;di=6b49d24b5172a34828b9d6506e4bf100&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn11%2F266%2Fw640h426%2F20180813%2Fce56-hhqtawx8254771.jpg")), new Positioned( bottom: 0.0, right: 0.0, child: Text('Hello',style: new TextStyle(fontSize: 36.0,fontWeight: FontWeight.bold,fontFamily: 'serif',color: Colors.white),), ), ], ), ), ), ); &#125;&#125; OverflowBox溢出父容器显示OverflowBox组件允许子元素child超出父容器的范围显示。当OverflowBox的最大尺寸大于child的时候，child可以完整显示，当其小于child的时候，则以最大尺寸为基准，当然这个尺寸是可以突破父节点的。最后加上对齐方式，完成布局。有时候需要某个元素超出整个模块，这时可以使用OverflowBox组件。 例子：添加两个容器，上层的容器会溢出下层的容器一定范围 12345678910111213141516171819202122232425262728293031323334353637import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Container( color: Colors.green, width: 200.0, height: 200.0, padding: const EdgeInsets.all(5.0), child: OverflowBox( alignment: Alignment.topLeft, maxWidth: 300.0, maxHeight: 500.0, child: Container( color: Colors.blueGrey, width: 400.0, height: 400.0, ), ), ), ), ); &#125;&#125; 宽高尺寸处理SizedBox（设置具体尺寸）SizedBox组件是一个特定大小的盒子，这个组件强制它的child有特定的宽度和高度。如果宽度或高度为null，则此组件将调整自身大小以匹配该维度中child的大小。 12345678910111213141516171819202122232425262728import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: SizedBox( width: 200.0, height: 200.0, child: const Card( child: Text('SizedBox',style: TextStyle(fontSize: 28.0),), ), ), ), ); &#125;&#125; ConstrainedBox（限定最大最小宽高布局）ConstrainedBox的作用是限定子元素child的最大宽度、最大高度、最小宽度和最小高度。 示例：一个宽高为300.0的Container上添加一个约束最大最小宽高的ConstrainedBox，实际显示中，则是一个宽高为220.0的区域 123456789101112131415161718192021222324252627282930313233import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: ConstrainedBox(constraints: const BoxConstraints( minWidth: 150.0, minHeight: 150.0, maxHeight: 250.0, maxWidth: 250.0 ), child: Container( width: 300.0, height: 300.0, color: Colors.green, ), ), ), ); &#125;&#125; 如果child不为null，则将限制条件加在child上，如果为null，则会尽可能地缩小尺寸 LimitedBox（限定最大宽高布局）LimitedBox组件是限制类型的组件，可对最大宽高进行限制。和ConstrainedBox类似，只不过LimitedBox组件没有最小宽高限制。 从布局的角度讲，LimitedBox是将child限制在其设定的最大宽高中的，但这个限定是有条件的。当LimitedBox最大宽度不受限制时，child的宽度就会受到这个最大宽度的限制，高度同理。 （明明ConstrainedBox不设置最小值就可以跟这个一样为什么要单独出一个LimitedBox？我暂时没理解到这其中的不同） 12345678910111213141516171819202122232425262728293031323334353637import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Column( children: &lt;Widget&gt;[ Container( color: Colors.grey, height: 100.0, ), LimitedBox( maxHeight: 150.0, child: Container( color: Colors.lightGreen, height: 250.0, ), ), ], ), ), ); &#125;&#125; （原书中用的Row，我就想试试Column） AspectRatio（调整宽高比）AspectRatio的作用是根据设置调整子元素child的宽高比，Flutter提供此组件，就免去了自定义所带来的麻烦。AspectRatio适用于需要固定宽高比的情景。 AspectRatio的布局行为分为两种情况 AspectRatio首先会在布局限制条件允许的范围内尽可能地扩展，Widget的高度是由宽度和比率决定的，类似于BoxFit中的contain，按照固定比率去尽量占满区域。 如果在满足所有限制条件后无法找到可行的尺寸，AspectRatio最终将会优先适应布局限制条件，而忽略所设置的比率。 示例：定义了一个高度为200的区域，内部AspectRatio比率设置为1.5，最终AspectRatio是宽300高200的一个区域 12345678910111213141516171819202122232425262728import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: new Container( height: 200.0, child: new AspectRatio(aspectRatio: 1.5, child: new Container( color: Colors.grey, ),), ), ), ); &#125;&#125; FractionallySizedBox（百分比布局）FractionallySizedBox组件会根据现有空间来调整child的尺寸，所以就算为child设置了具体的尺寸数值，也不起作用。当需要在一个区域里面取百分比尺寸时，可以使用这个组件，比如需要一个高度30%宽度60%的区域。 FractionallySizedBox的布局主要跟它的宽高因子（两个参数）有关，当参数为null或者有具体数值的时候，布局表现不一样。当然，还有一个辅助参数alignment，作为对齐方式进行布局。 具体有以下两种情况 设置了具体的宽高因子，具体的宽高则根据现有空间宽高×因子，当宽高因子大于1的时候，有可能会超出父组件的范围。 没有设置宽高因子，则填满可用区域。 如果宽高因子不为null，那么实际的最大宽高度则为child的宽高乘以这个因子；如果因子为null，那么child的宽高则会尽量充满整个区域 示例：两个容器，底部的容器宽高各为200。如果上面的容器宽度因子为0.5，则它的实际宽度为100；如果高度因子为1.5，则它的实际高度为300。对齐方式为左上角对齐。所以上层的元素横向在容器内部，纵向已经超出容器了。 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Container( color: Colors.blueGrey, height: 200.0, width: 200.0, child: FractionallySizedBox( alignment: Alignment.topLeft, widthFactor: 0.5, heightFactor: 2.0, child: Container( color: Colors.green, ), ), ), ), ); &#125;&#125; 列表及表格布局ListViewListView布局是一种常用的布局方式，ListView结合ListTitle可以布局出一些复杂的列表界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; List&lt;Widget&gt; list=&lt;Widget&gt;[ new ListTile( title: Text('第一个ListTitle',style: TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: Text('第一个subtitle'), leading: new Icon(Icons.fastfood,color: Colors.orange,), ), new ListTile( title: Text('第二个ListTitle',style: TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: Text('第二个subtitle'), leading: new Icon(Icons.home,color: Colors.orange,), ), new ListTile( title: Text('第三个ListTitle',style: TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: Text('第三个subtitle'), leading: new Icon(Icons.person,color: Colors.orange,), ), new ListTile( title: Text('第四个ListTitle',style: TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: Text('第四个subtitle'), leading: new Icon(Icons.print,color: Colors.orange,), ), new ListTile( title: Text('第四个ListTitle',style: TextStyle(fontWeight: FontWeight.w400,fontSize: 18.0),), subtitle: Text('第四个subtitle'), leading: new Icon(Icons.keyboard,color: Colors.orange,), ), ]; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Center( child: ListView( children: list, ), ), ), ); &#125;&#125; 实现长文本滚动效果 12345678910111213141516171819202122232425262728293031323334353637import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: ListView( children: &lt;Widget&gt;[ new Center( child: Text('第一个文字',style: TextStyle(fontSize: 30.0),), ), new Center( child: Text('第二个文字',style: TextStyle(fontSize: 16.0),), ), new Center(child: Text('''天河公园，是区属综合性公园，位于广州天河区员村，西靠天府路，南连黄埔大道，北接中山大道，来往交通十分便利。公园总面积为70.7公顷，水体面积占10公顷。天河公园以自然生态景观为主要特色，公园规划为五个功能区：百花园景区、文体娱乐区、老人活动区、森林休憩区、后勤管理区。''' ,style: TextStyle(fontSize: 14.0),), ) ], ), ), ); &#125;&#125; （长文本滚动的效果我没体会到，因为用双引号还是一样的效果，书上说长文本要用&#39;&#39;&#39;XXXX&#39;&#39;&#39;） GridViewGridView布局即为网格布局，通常用来布局多行多列的情况。 123456789101112131415161718192021222324252627282930313233343536373839404142import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; //使用generate构造图片列表 List&lt;Container&gt; _buildGridTitleList(int count)&#123; return new List&lt;Container&gt;.generate(count, (int index)=&gt;new Container( child: new Image(image: AssetImage('images/1.png')), )); &#125; //渲染GridView Widget buildGrid()&#123; return new GridView.extent(maxCrossAxisExtent: 150, //次轴的宽度 padding: const EdgeInsets.all(4.0), //上下左右内边距 mainAxisSpacing: 4.0, //主轴间隙 crossAxisSpacing: 4.0, //次轴间隙 children: _buildGridTitleList(9), ); &#125; return MaterialApp( title: 'Align测试', home: Scaffold( appBar: AppBar( title: Text('Align测试'), ), body: Center( child: buildGrid(), ), ), ); &#125;&#125; Table几乎每一个前端技术的布局中都会有一种table布局，这种组件太常见了，以至于其表现形式，完全可以借鉴其他前端技术。表格布局中，每一行的高度由其内容决定，每一列的宽度由columnWidths属性单独控制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: "Table测试", home: new Scaffold( appBar: AppBar( title: Text("Table测试"), ), body: new Center( //设置表格列，并指定宽 child: Table( columnWidths: const &lt;int,TableColumnWidth&gt;&#123; 0:FixedColumnWidth(100.0), 1:FixedColumnWidth(40.0), 2:FixedColumnWidth(80.0), 3:FixedColumnWidth(80.0), &#125;, //设置表格边框样式 border: TableBorder.all( color: Colors.black38, width: 2.0, style: BorderStyle.solid ), children: const &lt;TableRow&gt;[ //添加第一行数据 TableRow( children: &lt;Widget&gt;[ Text("姓名"), Text("性别"), Text("年龄"), Text("身高"), ] ), TableRow( children: &lt;Widget&gt;[ Text("姓名"), Text("性别"), Text("年龄"), Text("身高"), ] ), TableRow( children: &lt;Widget&gt;[ Text("姓名"), Text("性别"), Text("年龄"), Text("身高"), ] ) ] ), ), ), ); &#125;&#125; 其他布局处理Transform（矩阵转换）Transform的主要作用就是做矩阵变换。Container中矩阵变换就使用了Transform。Transform可以对child做平移、旋转及缩放等操作。 1234567891011121314151617181920212223242526272829303132333435import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: "测试Demo", home: new Scaffold( appBar: AppBar( title: Text("测试"), ), body: new Center( child: Container( color: Colors.grey, child: Transform( alignment: Alignment.topRight, transform: Matrix4.rotationZ(0.3), child: Container( padding: const EdgeInsets.all(8.0), color: const Color(0xFFE8581C), child: const Text("矩阵转换"), ), ), ), ), ), ); &#125;&#125; BaseLine（基准线布局）Baseline基准线是指将所有元素底部放在同一条水平线上。做过移动端开发的读者大都了解过，一般文字排版的时候可能会用到它。它的作用很简单，根据child的baseline来调整child的位置。例如两个字号不一样的文字，希望底部在一条水平线上，就可以使用这个组件，是一个非常基础的组件。 12345678910111213141516171819202122232425262728293031323334353637import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: "测试Demo", home: new Scaffold( appBar: AppBar( title: Text("测试"), ), body: new Row( //水平等间距排列 mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ //设置基准线 new Baseline(baseline: 80.0, baselineType: TextBaseline.alphabetic, child:new Text("AAcc",style: new TextStyle(fontSize: 18.0,textBaseline: TextBaseline.alphabetic),) ,), new Baseline(baseline: 80.0, baselineType: TextBaseline.alphabetic, child:new Text("AAcc",style: new TextStyle(fontSize: 23.0,textBaseline: TextBaseline.alphabetic),) ,), new Baseline(baseline: 80.0, baselineType: TextBaseline.alphabetic, child:new Text("AAcc",style: new TextStyle(fontSize: 34.0,textBaseline: TextBaseline.alphabetic),) ,) ], ), ), ); &#125;&#125; Offstage（控制是否显示组件）Offstage主要有一个属性就是offstage，值为true或者false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; final appTitle="Offstage示例"; return new MaterialApp( title: appTitle, home: new MyHomePage(title:appTitle), ); &#125;&#125;class MyHomePage extends StatefulWidget&#123; final String title; MyHomePage(&#123;Key key,this.title&#125;):super(key:key); @override _MyHomePageState createState()=&gt;new _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt;&#123; bool offstage=true; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: AppBar( title: Text("测试显示和隐藏"), ), body: Center( child: new Offstage( offstage: offstage, child: Text("显示出",style: new TextStyle(fontSize: 20.0),), ), ), floatingActionButton: new FloatingActionButton( onPressed: ()&#123; setState(() &#123; offstage=!offstage; &#125;); &#125;, tooltip: "显示隐藏", child: new Icon(Icons.flip), ), ); &#125;&#125; Wrap（按宽高自动换行布局）Wrap使用了Flex中的一些概念，某种意义上说跟Row、Column更加相似。单行的Wrap跟Row表现几乎一致，单列的Wrap则跟Column表现几乎一致。但Row与Column都是单行单列的，Wrap却突破了这个限制，主轴上空间不足时，则向次轴上去扩展显示。对于一些需要按宽度或高度让child自动换行布局的场景，可以使用Wrap。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; final appTitle="Offstage示例"; return new MaterialApp( title: appTitle, home: Scaffold( appBar: AppBar( title: Text("Wrap"), ), body: Wrap( spacing: 8.0,//chip之间的间隙 runSpacing: 4.0,//行之间的间隙 children: &lt;Widget&gt;[ Chip( avatar: CircleAvatar( backgroundColor: Colors.lightGreen.shade800,child: new Text("西门",style: TextStyle(fontSize: 10.0),), ), label: Text("西门吹雪"), ), Chip( avatar: CircleAvatar( backgroundColor: Colors.lightBlue.shade700, child: new Text('司空', style: TextStyle(fontSize: 10.0),)), label: Text('司空摘星'), ), Chip( avatar: CircleAvatar( backgroundColor: Colors.orange.shade800, child: new Text('婉清', style: TextStyle(fontSize: 10.0),)), label: Text('木婉清'), ), Chip( avatar: CircleAvatar( backgroundColor: Colors.blue.shade900, child: new Text('一郎', style: TextStyle(fontSize: 10.0),)), label: Text('萧十一郎'),) ], ), ), ); &#125;&#125; 布局综合示例跟随书上的代码，做一个风景区介绍的布局 布局分析整体布局使用一个垂直布局组件ListView进行滚动布局。一共有四大块；武当山图片、风景区地址、按钮组和景区介绍文本块。整体布局使用一个垂直布局组件ListView进行滚动布局。一共有四大块；武当山图片、风景区地址、按钮组和景区介绍文本块。 垂直方向使用ListView而不使用Column的原因是，风景区介绍文本可能会很长，甚至超出屏幕，如果使用Column组件，则有部分文本可能会看不到。使用ListView组件，用户可以滚动到下面查看文本。 风景区地址从横向上看需要使用一个水平排列的组件Row，水平方向总共有三个Child，分别为左侧文本区域、右侧图标及数字区域。其中左侧文本区域要继续细拆，需要用一个垂直布局的组件Column，上下各放一个文本组件即可。右侧图标及数字是两个组件，所以横向上来看总共是三个组件。 接下来分析按钮组的布局，在横向上用Row组件排列三个按钮。在纵向上用Column做三个相同的按钮，上面为按钮图标，下面为按钮文本。这样布局拆分的好处是，最大化地复用组件 编写 准备一张风景图，这里我使用上面那张网络图 1https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1541655494719&amp;di=6b49d24b5172a34828b9d6506e4bf100&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn11%2F266%2Fw640h426%2F20180813%2Fce56-hhqtawx8254771.jpg 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; //风景区地址部分 Widget addressContainer=Container( padding: const EdgeInsets.all(32.0), //四周间隔一定的距离 child: Row( children: &lt;Widget&gt;[ Expanded( child: Column( crossAxisAlignment: CrossAxisAlignment.start, //顶部对齐 children: &lt;Widget&gt;[ Container(padding: const EdgeInsets.only(bottom: 8.0), //与下面的文本间隔一定距离 child: Text("风景区地址",style: TextStyle(fontWeight: FontWeight.bold),), ), Text("湖北省十堰市丹江口市",style: TextStyle(color: Colors.grey[500]),), ], ), ), Icon(Icons.star,color: Colors.red[500],), Text('66'), ], ), ); //构建按钮组中单个按钮，参数为图标及文本 Column buildButtonColumn(IconData icon,String label)&#123; return Column( mainAxisSize: MainAxisSize.min,//垂直方向大小最小化 mainAxisAlignment: MainAxisAlignment.center, //垂直方向居中对齐 children: &lt;Widget&gt;[ Icon(icon,color: Colors.lightGreen[600],), Container( margin: const EdgeInsets.only(top: 8.0), child: Text( label,style: TextStyle( fontSize: 12.0, fontWeight: FontWeight.w400, color: Colors.lightGreen[600], ), ), ), ], ); &#125; //按钮组部分 Widget buttonsContainer=Container( //容器横向布局 child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, //水平方向均匀排列每个元素 children: &lt;Widget&gt;[ buildButtonColumn(Icons.call, "电话"), buildButtonColumn(Icons.near_me, "导航"), buildButtonColumn(Icons.mobile_screen_share, "分享"), ], ), ); //风景区介绍文本部分 Widget textContainer=Container( padding: const EdgeInsets.all(32.0), child: Text( ''' 武当山，中国道教圣地，又名太和山、谢罗山、参上山、仙室山，古有“太岳”“玄岳”“大岳”之称。位于湖北西北部十堰市丹江口市境内。东接闻名古城襄阳市，西靠车城十堰市 ，南望原始森林神农架，北临高峡平湖 丹江口水库。 明代，武当山被皇帝封为“大岳”、“治世玄岳”，被尊为“皇室家庙”。武当山以“四大名山皆拱揖，五方仙岳共朝宗”的“五岳之冠”地位闻名于世。 1994年12月，武当山古建筑群入选《世界遗产名录》，2006年被整体列为“全国重点文物保护单位”。2007年，武当山和长城、丽江、周庄等景区一起入选“欧洲人最喜爱的中国十大景区”。2010至2013年，武当山分别被评为国家5A级旅游区、国家森林公园、中国十大避暑名山、海峡两岸交流基地，入选最美“国家地质公园”。 截至2013年，武当山有古建筑53处，建筑面积2.7万平方米，建筑遗址9处，占地面积20多万平方米，全山保存各类文物5035件。 武当山是道教名山和武当武术的发源地，被称为“亘古无双胜境，天下第一仙山”。武当武术，是中华武术的重要流派。元末明初，道士张三丰集其大成，开创武当派。 ''',softWrap: true,), ); //构建界面组装 return MaterialApp( title: '布局综合示例', theme: new ThemeData( brightness: Brightness.light,//整体主题亮度 primaryColor: Colors.lightGreen,//App主要部分的背景色 accentColor: Colors.orange[600],//前景色 ), home: Scaffold( appBar: AppBar( title: Text('综合布局',style: TextStyle(color: Colors.white),), ), body: ListView( children: &lt;Widget&gt;[ Image.network("https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1541655494719&amp;di=6b49d24b5172a34828b9d6506e4bf100&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn11%2F266%2Fw640h426%2F20180813%2Fce56-hhqtawx8254771.jpg",width: 600,height: 240,fit: BoxFit.cover,), addressContainer, buttonsContainer, textContainer ], ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章：Cupertino风格组件]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9ACupertino%E9%A3%8E%E6%A0%BC%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[简介Cupertino风格组件即iOS风格组件，主要有CupertinoTabBar、CupertinoPageScaffold、CupertinoTabScaffold、CupertinoTabView等。目前组件库还没有Material Design风格组件丰富。但作为一种补充，可以根据实际场景选择使用即可。 本章所涉及的组件及内容有： CupertinoActivityIndicator组件 CupertinoAlertDialog对话框组件 CupertinoButton按钮组件 Cupertino导航组件集（CupertinoTabBar、CupertinoPageScaffold、CupertinoTabScaffold、CupertinoTabView等） CupertinoActivityIndicator组件CupertinoActivityIndicator是一个IOS风格的loading指示器，通常用在加载等待的效果展示 导入Cupertino组件库 1import 'package:flutter/cupertino.dart'; 代码 1234567891011121314151617181920212223242526import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'CupertinoActivityIndicator示例', home: Scaffold( appBar: AppBar( title: Text('CupertinoActivityIndicator示例'), ), body: Center( child: CupertinoActivityIndicator( radius: 60.0, //值越大加载的图形越大 ), ), ), ); &#125;&#125; CupertinoAlertDialog对话框组件CupertinoAlertDialog和Material Design风格里的AlertDialog对话框相似，只是样式不同。共同点是不仅仅有提示内容，还有一些操作按钮，如确定和取消等。内容部分可以用SingleChildScrollView进行包裹。操作按钮建议用CupertinoDialogAction组件，这样显示更协调一些。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'CupertinoAlertDialog示例', home: Scaffold( appBar: AppBar( title: Text('CupertinoAlertDialog示例'), ), body: Center( child: CupertinoAlertDialog( title: Text('提示'), content: SingleChildScrollView( child: ListBody( children: &lt;Widget&gt;[ Text('是否要删除'), Text('一旦删除不可恢复'), ], ), ), actions: &lt;Widget&gt;[ CupertinoDialogAction( child: Text('确定'), onPressed: ()&#123;&#125;, ), CupertinoDialogAction( child: Text('取消'), onPressed: ()&#123;&#125;, ), ], ), ), ), ); &#125;&#125; CupertinoButton按钮组件IOS风格按钮 123456789101112131415161718192021222324import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'CupertinoButton示例', home: Scaffold( appBar: AppBar( title: Text('CupertinoButton示例'), ), body: Center( child: CupertinoButton(child: Text('按钮'), color: Colors.blue,onPressed: ()&#123;&#125;), ), ), ); &#125;&#125; 这里我发现，onPressed后面如果是null，按钮就会默认不可点击变成灰色，颜色代码也将失效 Cupertino导航组件集Cupertino导航相关的组件也非常丰富。由于它们之间有关联关系，所以本节把导航相关的组件放在一起说明。下面分别说明这些组件的属性及描述。 CupertinoTabScaffold选项卡组件 CupertinoTabBar选项卡按钮 选项卡按钮，通常由BottomNavigationBarItem组成包含图标加文本 CupertinoTabView 选项卡视图 CupertinoPageScaffold 页面的基本布局结构，包含内容和导航栏 CupertinoNavigationBar 导航栏结构组件 导航栏综合示例 添加最外层导航选项卡，使用CupertinoTabScaffold组件，它有两个属性tabBar和tabBuilder，分别用来绑定底部选项卡及所对应的视图 添加底部选项卡按钮，使用CupertinoTabBar组件，需要制定选项卡项，每个项包含一个图标及一个文本 123456789tabBar: CupertinoTabBar( items:[ BottomNavigationBarItem( //指定图标 //指定文本 ), //根据需要添加更多按钮 ],), 每个选项卡需要绑定一个视图，使用CupertinoTabView组件 1234567891011121314151617tabBuilder:(context,index)&#123; //选项卡绑定的视图 return CupertinoTabView( builder:(context)&#123; switch(index)&#123; case 0: return HomePage(); break; case 1: return ChatPage(); break; default: return Container(); &#125; &#125;, );&#125; 编写一个选项卡页面即主页，命名为HomePage,页面需要一个CupertinoPageScaffold来包裹，指定页面顶部导航内容及内容区域 1234567891011121314class HomePage extends StatelessWidget&#123; @override Widget build()&#123; return CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( //只加标题 ), child:Center( //内容区域 ), ) &#125;&#125; 编写第二个选项卡页面即聊天页面，将其命名为ChatPage。页面需要一个CupertinoPageScaffold组件来包裹，指定页面顶部导航内容（包含左中右三块），及内容区域。 12345678910111213class ChatPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( //导航栏 包含左中右三部分 ), child: Center( //内容区域 ), ); &#125;&#125; 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import 'package:flutter/material.dart';import 'package:flutter/cupertino.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Capertino导航栏组件集', theme: ThemeData.light(), home: MyPage(), ); &#125;&#125;class MyPage extends StatefulWidget&#123; _MyPageState createState=&gt;_MyPageState();&#125;class _MyPageState extends State&lt;MyPage&gt;&#123; @override Widget build(BuildContext context) &#123; //最外层导航栏选项卡 return CupertinoTabScaffold( //底部选项卡 tabBar: CupertinoTabBar(backgroundColor: CupertinoColors.lightBackgroundGray,items: [ //选项卡项，包含图标及文字 BottomNavigationBarItem( icon: Icon(CupertinoIcons.home), title: Text('主页') ), BottomNavigationBarItem( icon: Icon(CupertinoIcons.conversation_bubble), title: Text('聊天') ), ]), tabBuilder: (context,index)&#123; //选项卡绑定的视图 return CupertinoTabView( builder: (context)&#123; switch(index)&#123; case 0: return HomePage(); break; case 1: return ChatPage(); break; default: return Container(); &#125; &#125;, ); &#125;, ); &#125;&#125;class HomePage extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( middle: Text('主页'), ), child: Center( child: Text('主页',style: Theme.of(context).textTheme.button,), ), ); &#125;&#125;class ChatPage extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( //导航栏，包含左中右三部分 middle: Text('聊天界面'), trailing: Icon(CupertinoIcons.add), //右侧 leading: Icon(CupertinoIcons.back), //左侧 ), child: Center( child: Text('聊天面板',style: Theme.of(context).textTheme.button,), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Cupertino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：Material Design风格组件]]></title>
    <url>%2F2019%2F02%2F24%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AMaterial-Design%E9%A3%8E%E6%A0%BC%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[介绍Material Design是由Google推出的全新设计语言，这种设计语言旨在为手机、平板电脑、台式机和其他平台提供更一致、更广泛的外观和感觉。在本书里我们有时把Material Design也称为纸墨设计，Material Design风格是一种非常有质感的设计风格，并会提供一些默认的交互动画。 App结构和导航组件MaterialApp(应用组件)MaterialApp代表使用纸墨设计风格的应用，里面包含了其所需要的基本控件。一个完整的Flutter项目就是从MaterialApp这个主组件开始的。 设置主页使用home属性设置应用的主页，即整个应用的主组件 1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';void main()&#123; runApp(new MyApp());&#125;class MyApp extends StatelessWidget&#123; //整个应用的主组件 @override Widget build(BuildContext context) &#123; return new MaterialApp( home: new MyHomePage(), title: 'MaterialApp示例', ); &#125;&#125;//这是一个可改变的Widgetclass MyHomePage extends StatefulWidget&#123; _MyHomePageState createState()=&gt;new _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt;&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: Text("MaterialApp示例"), ), body: Center( child: Text('主页'), ), ); &#125;&#125; 路由处理routes对象是一个Map&lt;String，WidgetBuilder&gt;。当使用Navigator.pushNamed来路由的时候，会在routes查找路由名字，然后使用对应的WidgetBuilder来构造一个带有页面切换动画的MaterialPageRoute。如果应用只有一个界面，则不用设置这个属性，使用home设置这个界面即可。 通过routes可以给MaterialApp组件初始化一个路由列表，跳转到指定页面 1Navigator.pushNamed(context,'/somePage'); 在MaterialApp组件使用initialRoute属性可以给应用添加一个初始化路由器 12345routes:&#123;'/first':(BuildContext context)=&gt;FirstPage(),'/second':(BuildContext context)=&gt;SecondPage(),&#125;,initialRoute:'/first',//初始路由页面为first页面 这里我们添加两个页面，在第一个页面里添加一个Button，当点击Button时路由到第二个页面 1Navigator.pushNamed(context,'/second'); 在第二个页面也添加一个Button，点击以后跳转到第一个页面 1Navigator.pushNamed(context,'/first'); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import 'package:flutter/material.dart';void main()&#123; runApp(new MyApp());&#125;class MyApp extends StatelessWidget&#123; //整个应用的主组件 @override Widget build(BuildContext context) &#123; return new MaterialApp( home: new MyHomePage(), title: 'MaterialApp示例', routes: &#123; '/first':(BuildContext context)=&gt;FirstPage(), '/second':(BuildContext context)=&gt;SecondPage(), &#125;, initialRoute: '/first', ); &#125;&#125;//这是一个可改变的Widgetclass MyHomePage extends StatefulWidget&#123; _MyHomePageState createState()=&gt;new _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt;&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: Text("MaterialApp示例"), ), body: Center( child: Text('主页'), ), ); &#125;&#125;//第一个路由页面class FirstPage extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: Text('这是第一页'), ), body: Center( child: RaisedButton( onPressed: ()&#123; Navigator.pushNamed(context, '/second'); &#125;, child: Text('这是第一页',style: TextStyle(fontSize: 28.0),), ), ), ); &#125;&#125;//第二个路由页面//第一个路由页面class SecondPage extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: Text('这是第二页'), ), body: Center( child: RaisedButton( onPressed: ()&#123; Navigator.pushNamed(context, '/first'); &#125;, child: Text('这是第二页',style: TextStyle(fontSize: 28.0),), ), ), ); &#125;&#125; 这里感觉像安卓中的启动另外一个活动，而且上面的代码是不管之前有没有这个活动都会启动一个新的，而不是返回。 自定义主题应用程序的主题，各种定制的颜色都可以设置，用于程序主题切换。 123456new MaterialApp( theme: new ThemeData( //主题色 primarySwatch: Colors.blue, )) Scaffold(脚手架组件)Scaffold实现了基本的Material Design布局。只要是在Material Design中定义过的单个界面显示的布局组件元素，都可以使用Scaffold来绘制。 1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';void main()&#123; runApp(new MaterialApp( title: 'Scaffold脚手架组件示例', home: new LayoutDemo(), ));&#125;class LayoutDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( //头部元素，比如左侧返回按钮，中间标题，右侧菜单 appBar: AppBar( title: Text('Scaffold脚手架组件示例'), ), //视图内容部分 body: Center( child: Text('Scaffold'), ), //底部导航栏 bottomNavigationBar: BottomAppBar( child: Container(height: 50.0,), ), //添加fab按钮 floatingActionButton: new FloatingActionButton( onPressed: ()&#123;&#125;, tooltip: '增加', child: Icon(Icons.add), ), //fab居中展示 floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); &#125;&#125; 感觉这个比《第一行代码Android》里面的MaterialDesign好用，很简洁就加上了 AppBar（应用按钮组件）应用按钮组件有AppBar和SliverAppBar。它们是纸墨设计中的AppBar，也就是Android中的Toolbar。AppBar和SliverAppBar都是继承自StatefulWidget类，都代表Toolbar，两者的区别在于AppBar位置是固定在应用最上面的；而SliverAppBar是可以跟随内容滚动的。 AppBar可以显示顶部leading、title和actions等内容。底部通常为选项卡TabBar。flexibleSpace显示在AppBar的下方，高度和AppBar高度一样，可以实现一些特殊的效果，不过该属性通常在SliverAppBar中使用。 示例：在上端左侧显示标题，右侧添加两个按钮 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';void main()&#123; runApp(new MaterialApp( title: 'AppBar应用按钮示例', home: new LayoutDemo(), ));&#125;class LayoutDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: AppBar( title: Text('AppBar应用示例'), actions: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.search), tooltip: '搜索', onPressed: ()&#123;&#125;, ), IconButton( icon: Icon(Icons.add), tooltip: '添加', onPressed: ()&#123;&#125;, ), ], ), ); &#125;&#125; ButtomNavigationBar（底部导航条组件）BottomNavigationBar是底部导航条，可以很容易地在tap之间切换和浏览顶级视图。 BottomNavigationBar通常显示在应用页面底部。由按钮加文字组成，这个可以根据实际应用场景任意组合。按下按钮切换不同的页面。所以它需要一个当前索引来控制当前具体切换的页面。 接下来是一个示例代码，仿一个聊天软件，底部显示“信息”、“通讯录”及“发现”按钮。这个界面有点像微信的排列方式。按钮是由图标加文本方式，切换不同的按钮，中间显示切换的内容。示例中用到了状态控制，用来控制当前切换按钮的索引值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( body: MyHomePage(), ), ); &#125;&#125;class MyHomePage extends StatefulWidget&#123; MyHomePage(&#123;Key key&#125;):super(key:key); _MyHomePageState createState()=&gt;_MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt;&#123; int _selectiedIndex=1;//当前选中项的索引 final _widgetOptions=[ Text('Index 0:信息'), Text('Index 1:通讯录'), Text('Index 2:发现'), ]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ButtomNavigationBar示例'), ), body: Center( child: _widgetOptions.elementAt(_selectiedIndex), //居中显示某一个文本 ), //底部导航栏按钮，包含图标及文本 bottomNavigationBar: BottomNavigationBar( items: &lt;BottomNavigationBarItem&gt;[ BottomNavigationBarItem(icon: Icon(Icons.chat),title: Text('信息')), BottomNavigationBarItem(icon: Icon(Icons.contacts),title: Text('通讯录')), BottomNavigationBarItem(icon: Icon(Icons.account_circle),title: Text('发现')), ], currentIndex: _selectiedIndex, fixedColor: Colors.deepPurple, onTap: _onItemTapped, ), ); &#125; void _onItemTapped(int index)&#123; setState(() &#123; _selectiedIndex=index; &#125;); &#125;&#125; 感觉用这个用起来太方便了 TabBar（水平选项卡及视图组件）TabBar是一个显示水平选项卡的Material Design组件，通常需要配套Tab选项组件及TabBarView页面视图组件一起使用。 TabBar组件常见属性： Tab组件常见属性: TabBar的选项卡按钮通常显示在应用页面上部 实现一个TabBar,实现这个示例需要以下几个组件 DefaultTabController TabBar Tab TabBarView 在编写示例之前，我们先了解一下DefaultTabController这个组件，它是TabBar和TabBarView的控制器，是关联这两组件的桥梁。 DefaultTabController的示例代码如下 123456789101112131415161718192021222324252627282930313233343536373839import 'package:flutter/material.dart';void main() &#123; runApp(new DefaultTabControllerSample());&#125;class DefaultTabControllerSample extends StatelessWidget &#123; //选项卡数据 final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ Tab(text: '选项卡一'), Tab(text: '选项卡二'), ]; @override Widget build(BuildContext context) &#123; return new MaterialApp( //用来组装TabBar及TabBarView home: DefaultTabController( length: myTabs.length, child: Scaffold( appBar: AppBar( //添加导航栏 bottom: TabBar( tabs: myTabs, ), ), //添加导航视图 body: TabBarView( children: myTabs.map((Tab tab) &#123; return Center(child: Text(tab.text)); &#125;).toList(), ), ), ), ); &#125;&#125; 编写TabBar水平选项卡 添加视图数据ItemView，增加title及icon两个数据项 1234class ItemView&#123; title; icon;&#125; 组装数据，添加所有选项类目。 1ItemView(title:'自驾',icon:Icons.directions_car); 用List组装起来 1const List&lt;ItemView&gt; items=const&lt;ItemView&gt;[]; 添加被选中的视图命名为SelectedView，此组件需要传入视图项数据，包含图标及标题，然后通过Column组件居中显示在界面里。 1234567891011class SelectedView extends StatelessWidget &#123; //TODO构造方法 //视图数据 final ItemView item; @override Widget build(BuildContext context) &#123; //渲染页面 添加图标和文本 &#125;&#125; 接着添加示例的主体命名为TabBarSample。主要用DefaultTabController来包裹并指定选项卡的数量。接着在AppBar里添加TabBar组件。注意这里的bottom不要理解为底部，应理解为AppBar的按钮部分。TabBar需要设置为可滚动的，因为选项卡子项较多，界面需要滑动才可以显示全。TabBar的子项tabs需要使用迭代器来展示Tab内容。添加好TabBar后再添加视图TabBarView，这里同样也需要使用迭代器来展示选项卡视图。 123456tabs: items.map((ItemView item) &#123; return new Tab( text: item.title, icon: new Icon(item.icon), );&#125;).toList(), 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import 'package:flutter/material.dart';void main()&#123; runApp(new TabBarDemo());&#125;//选项卡的类目const List&lt;ItemView&gt; items=const &lt;ItemView&gt;[ const ItemView(title: '自驾',icon: Icons.directions_car), const ItemView(title: '自行车',icon: Icons.directions_bike), const ItemView(title: '轮船',icon: Icons.directions_boat), const ItemView(title: '公交车',icon: Icons.directions_bus), const ItemView(title: '火车',icon: Icons.directions_railway), const ItemView(title: '步行',icon: Icons.directions_walk), const ItemView(title: '步行',icon: Icons.directions_walk), const ItemView(title: '步行',icon: Icons.directions_walk), const ItemView(title: '步行',icon: Icons.directions_walk), const ItemView(title: '步行',icon: Icons.directions_walk),];class ItemView&#123; final String title; final IconData icon; const ItemView(&#123;this.title,this.icon&#125;);&#125;//被选中的视图class SelectedView extends StatelessWidget&#123; const SelectedView(&#123;Key key,this.item&#125;):super(key:key); final ItemView item; @override Widget build(BuildContext context) &#123; final TextStyle textStyle=Theme.of(context).textTheme.display1; return new Card( color: Colors.white, child: new Center( child: new Column( mainAxisSize: MainAxisSize.min,//垂直方向最小化处理 crossAxisAlignment: CrossAxisAlignment.center,//水平方向居中对齐 children: &lt;Widget&gt;[ new Icon(item.icon,size: 128.0,color: textStyle.color), new Text(item.title,style: textStyle), ], ), ), ); &#125;&#125;class TabBarDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( //添加DefaultTabController关联TabBar及TabBarView home: new DefaultTabController( length: items.length, child: new Scaffold( appBar: new AppBar( title: const Text('TabBar选项卡示例'), bottom: new TabBar( isScrollable: true, tabs: items.map((ItemView item)&#123; return new Tab( text:item.title, icon:new Icon(item.icon), ); &#125;).toList(), ), ), //添加选项卡视图 body: new TabBarView( children:items.map((ItemView item)&#123; //迭代器显示选项卡视图 return new Padding( padding: const EdgeInsets.all(16.0), child: new SelectedView( item:item ), ); &#125;).toList(), ), ), ), ); &#125;&#125; Drawer（抽屉组件）Drawer可以实现类似抽屉拉出推入的效果。可以从侧边栏拉出导航面板。这样做的好处是，可以把一些功能菜单折叠起来。通常Drawer是和ListView组件组合使用的。 Drawer组件可以添加头部效果，用以下两个组件可以实现： DrawerHeader：展示基本信息。 UserAccountsDrawerHeader：展示用户头像、用户名、Email等信息。 DrawerHeader通常用于抽屉中在顶部展示一些基本信息 UserAccountsDrawerHeader可以设置用户头像、用户名和Email等信息，显示一个符合Material Design规范的drawer header 从UserAccountsDrawerHeader的属性及描述来看，我们可以写一个示例来模仿QQ侧边导航栏的效果 （他这里直接用到了文件中的图片，这里随便搞一张就行了,但是他没有讲如何添加资源图片） 在项目根目录创建一个images文件夹，编辑pubspec.yaml文件，添加图片资源 12assets: - images/1.png 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import 'package:flutter/material.dart';void main()&#123; runApp(new MaterialApp( title: 'Drawer抽屉组件示例', home: new LayoutDemo(), ));&#125;class LayoutDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: AppBar( title: Text('Drawer抽屉组件示例'), ), drawer: Drawer( child: ListView( children: &lt;Widget&gt;[ //设置头像、用户名、Email等 UserAccountsDrawerHeader( accountName: Text('ZaneCode6574'), accountEmail: Text('zanecode6574@qq.com'), currentAccountPicture: new CircleAvatar( backgroundImage: new AssetImage("images/1.png"), ), onDetailsPressed: ()&#123;&#125;, otherAccountsPictures: &lt;Widget&gt;[ new Container( child: Image.asset("images/1.png"), ), ], ), ListTile( leading: new CircleAvatar( child: Icon(Icons.color_lens), ), title: Text('个性装扮'), ), ListTile( leading: new CircleAvatar( child: Icon(Icons.color_lens), ), title: Text('个性'), ), ListTile( leading: new CircleAvatar( child: Icon(Icons.color_lens), ), title: Text('装扮'), ), ], ), ), ); &#125;&#125; 按钮和提示组件FloatingActionButton（悬停按钮组件）FloatingActionButton对应一个圆形图标按钮，悬停在内容之上，以展示应用程序中的主要动作，所以非常醒目，类似于iOS系统里的小白点按钮。Floating-Action-Button通常用于Scaffold.floatingActionButton字段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'FloatingActionButton示例', home: Scaffold( appBar: AppBar( title: Text('FloatingActionButton示例'), ), body: Center( child: Text('FloatingActionButton示例',style: TextStyle(fontSize: 28.0),), ), floatingActionButton: new Builder( builder: (BuildContext context)&#123; return new FloatingActionButton( child: const Icon(Icons.add), tooltip: "请点击", foregroundColor: Colors.white, backgroundColor: Colors.blue, elevation: 7.0, highlightElevation: 14.0, onPressed: ()&#123; Scaffold.of(context).showSnackBar(new SnackBar( content: new Text("你点击了FloatingActionButton"), )); &#125;, mini: false, shape: new CircleBorder(), isExtended: false, ); &#125;, ), floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat, ), ); &#125;&#125; 这里实现这个好容易…比起之前的 FlatButton（扁平按钮组件）FlatButton组件是一个扁平的Material Design风格按钮，点击时会有一个阴影效果 123456789101112131415161718192021222324252627import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: '扁平按钮组件Demo', home: Scaffold( appBar: AppBar( title: Text('扁平按钮组件示例'), ), body: Center( child: FlatButton( onPressed: ()&#123;&#125;, child: Text('扁平化按钮',style: TextStyle(fontSize: 24.0),), ), ), ), ); &#125;&#125; PopupMenuButton（弹出菜单组件）PopupMenuButton为弹出菜单按钮，一般放在应用页面的右上角，表示有更多的操作。菜单项使用PopupMenuItem组件。 12345678910111213141516171819202122232425262728293031323334353637383940import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;//菜单项enum ConferenceItem&#123; AddMemeber,LockConference,ModifyLayout,TurnoffAll&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'PopupMenuButton示例', home: Scaffold( appBar: AppBar( title: Text('PopupMenuButton示例'), ), body: Center( child: FlatButton( onPressed: ()&#123;&#125;, child: PopupMenuButton&lt;ConferenceItem&gt;( onSelected: (ConferenceItem result)&#123;&#125;, itemBuilder: (BuildContext context)=&gt;&lt;PopupMenuEntry&lt;ConferenceItem&gt;&gt;[ const PopupMenuItem&lt;ConferenceItem&gt;(value: ConferenceItem.AddMemeber,child: Text('添加成员'),), const PopupMenuItem&lt;ConferenceItem&gt;(value: ConferenceItem.LockConference,child: Text('锁定会议'),), const PopupMenuItem&lt;ConferenceItem&gt;(value: ConferenceItem.ModifyLayout,child: Text('修改布局'),), const PopupMenuItem&lt;ConferenceItem&gt;(value: ConferenceItem.TurnoffAll,child: Text('挂断所有'),), ], ), ), ), ), ); &#125;&#125; SimpleDialogSimpleDialog组件用于设计简单对话框，可以显示附加的提示或操作。简单对话框通常需要配合SimpleDialogOption组件一起使用 123456789101112131415161718192021222324252627282930313233343536import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'SimpleDialog组件示例', home: Scaffold( appBar: AppBar( title: Text('SimpleDialog示例'), ), body: Center( child: SimpleDialog( title: const Text('对话框标题'), children: &lt;Widget&gt;[ SimpleDialogOption( onPressed: ()&#123;&#125;, child: const Text('第一行信息'), ), SimpleDialogOption( onPressed: ()&#123;&#125;, child: const Text('第二行信息'), ), ], ), ), ), ); &#125;&#125; 通常对话框都是某个动作来触发渲染的。比如点击按钮，点击菜单等。所以对话框一般要封装在一个方法里实现。另外这个过程是异步的需要加入async/await处理。 AlertDialog（提示对话框组件）AlertDialog组件比SimpleDialog对话框又复杂一些。不仅仅有提示内容，还有一些操作按钮，如确定和取消等，内容部分可以用SingleChildScrollView进行包裹。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'AlertDialog示例', home: Scaffold( appBar: AppBar( title: Text('AlertDialog示例'), ), body: Center( child: AlertDialog( title: Text('提示'), content: SingleChildScrollView( child: ListBody( children: &lt;Widget&gt;[ Text('是否要删除？'), Text('一旦删除不可恢复!'), ], ), ), actions: &lt;Widget&gt;[ FlatButton( child: Text('确定'), onPressed: ()&#123;&#125;, ), FlatButton( child: Text('是的'), onPressed: ()&#123;&#125;, ), ], ), ), ), ); &#125;&#125; SnackBar（轻量提示组件）SnackBar是一个轻量级消息提示组件，在屏幕的底部显示(这个控件在前面都出现过了) 123456789101112131415161718192021222324252627282930313233343536373839import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Snack测试', home: Scaffold( appBar: AppBar( title: Text('Snack测试'), ), body: Center( child: Text('Snack示例',style: TextStyle(fontSize: 28.0),), ), floatingActionButton: new Builder( builder: (BuildContext context)&#123; return new FloatingActionButton( child: const Icon(Icons.add), onPressed: ()&#123; Scaffold.of(context).showSnackBar(new SnackBar( content: Text('显示SnackBar'), )); &#125;, shape: new CircleBorder(), ); &#125;, ), floatingActionButtonLocation: FloatingActionButtonLocation.endFloat, //居中放置，位置可以是左中右 ), ); &#125;&#125; 其他组件（文本框、卡片等）TextField（文本框组件）只要是应用程序就少不了交互，文本输入是最常见的一种交互方式。TextField组件就是用来做文本输入的组件。注意这个要和Text组件区分开来，Text组件主要用于显示文本，并不接受输入文本。 假设想获取文本内容，仅有输入框还不行，还需要传递controller给TextField。用来监听文本内容的变化，这是一种绑定的机制。 初如化监听器代码如下所示： 1234final TextEditingController controller = TextEditingController();controller.addListener(() &#123; //TODO&#125;); 绑定监听器代码如下所示： 123child: TextField( controller: controller,), 当你在文本框里输入“hello world”，你会发现在控制台里文字是一个一个打印出来的。原因是监听器只要发现文本内容有发生变化，就会触发回调函数输出内容。输出结果如下： 123456789101112flutter: 你输入的内容为:flutter: 你输入的内容为: hflutter: 你输入的内容为: heflutter: 你输入的内容为: helflutter: 你输入的内容为: hellflutter: 你输入的内容为: helloflutter: 你输入的内容为: helloflutter: 你输入的内容为: hello wflutter: 你输入的内容为: hello woflutter: 你输入的内容为: hello worflutter: 你输入的内容为: hello worlflutter: 你输入的内容为: hello world 接下来可以再给TextField添加一些属性用来做更多的控制，比如最大长度，最大行数，是否自动对焦，内容提交回调等等。最后再给文本框加一些装饰效果，比如填充色，图标等内容。组件的装饰和生活中的装修一样任由个人发挥，这里建议简单大方即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; //添加文本编辑控制器，监听文本输入变化 final TextEditingController controller=new TextEditingController(); controller.addListener(()&#123; print('你输入的内容为：$&#123;controller.text&#125;'); &#125;); return MaterialApp( title: 'TextField组件示例', home: Scaffold( appBar: AppBar( title: Text('TextField组件示例'), ), body: Center( child: Padding( padding: const EdgeInsets.all(20.0), child: TextField( //绑定 controller: controller, maxLength: 30, maxLines: 1, autocorrect: true, autofocus: true, obscureText: false, textAlign: TextAlign.left, style: TextStyle(fontSize: 28.0,color: Colors.blue), //文本内容改变时回调 onChanged: (text)&#123; print('文本内容改变时回调:$&#123;text&#125;'); &#125;, //内容提交时回调 onSubmitted: (text)&#123; print('内容提交时回调:$text'); &#125;, enabled: true, decoration: InputDecoration( fillColor: Colors.grey.shade200, filled: true, helperText: '用户名', //左侧图标 prefixIcon: Icon(Icons.person), //右侧文本提示 suffixText: '用户名', ), ), ), ), ), ); &#125;&#125; 卡片组件Card即卡片组件块，内容可以由大多数类型的Widget构成，但通常与ListTile一起使用。Card有一个child，但它可以是支持多个child的列、行、列表、网格或其他小部件。默认情况下，Card将其大小缩小为0像素。你可以使用SizedBox来限制Card的大小。在Flutter中，Card具有圆角和阴影，这让它看起来有立体感。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import 'package:flutter/material.dart';void main()&#123; runApp(MyApp());&#125;class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; var card=new SizedBox( height: 250, child: new Card( child: new Column( children: &lt;Widget&gt;[ new ListTile( title: Text('地址1',style: new TextStyle(fontWeight: FontWeight.w300),), subtitle: Text('文字2'), leading: new Icon( Icons.home, color: Colors.lightBlue, ), ), new Divider(), new ListTile( title: Text('地址二',style: new TextStyle( fontWeight: FontWeight.w300 ),), subtitle: Text('文字二'), leading: new Icon(Icons.home,color: Colors.lightBlue,), ), new Divider(), ], ), ), ); return MaterialApp( title: 'Card布局示例', home: Scaffold( appBar: AppBar( title: Text('Card布局示例'), ), body: new Center( child: card, ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>Material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章：Flutter常用组件]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AFlutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[（这前面的章节安排有些问题，比如Scaffold组件就没讲，而是在后面才出现的，这里先用，后面再看就明白了） Flutter里有一个非常重要的核心理念：一切皆为组件，Flutter所有的元素皆由组件组成。比如：一个布局元素、一个动画、一个装饰效果等。 容器组件容器组件（Container）包含一个子Widget，自身具备如alignment、padding等基础属性，方便布局过程中摆放child padding与margin的不同之处在于，padding是包含在Content内，而margin则是外部边界。设置点击事件的话，padding区域会响应，而margin区域不会响应。 编写一个带有装饰效果的Container容器 1234567891011121314151617181920212223242526272829303132333435363738394041import 'package:flutter/material.dart';void main()=&gt;runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: '容器组件示例', home: Scaffold( appBar: AppBar( title: Text('容器组件示例'), ), body: Center( //添加容器 child: Container( width: 200.0, height: 200.0, //添加边框装饰效果 decoration: BoxDecoration( color: Colors.white, //设置上下左右四个边框样式 border: new Border.all( color: Colors.grey, width: 8.0, ), borderRadius: const BorderRadius.all(const Radius.circular(8.0)),//边框弧度 ), child: Text( 'Flutter', textAlign: TextAlign.center, style: TextStyle(fontSize: 28.0), ), ), ), ), ); &#125;&#125; 文本组件文本组件（text）负责显示文本和定义显示样式 接下来我们通过创建多个文本组件来展示不同的文本样式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import 'package:flutter/material.dart';class ContainerDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('文本组件'), ), body: new Column( children: &lt;Widget&gt;[ new Text('红色+黑色删除线+25号',style: new TextStyle( color: const Color(0xffff0000), decoration: TextDecoration.lineThrough, decorationColor: const Color(0xff000000), fontSize: 25.0, )), new Text('橙色+下划线+24号', style:new TextStyle( color: const Color(0xffff9900), decoration: TextDecoration.underline, fontSize: 24.0, )), new Text('虚线上划线+23号+倾斜', style: new TextStyle( decoration: TextDecoration.overline, decorationStyle: TextDecorationStyle.dashed, fontSize: 23.0, fontStyle: FontStyle.italic, ), ), new Text('24号+加粗', style: new TextStyle( fontSize: 24.0, fontWeight: FontWeight.bold, ), ) ], ), ); &#125;&#125;void main()&#123; runApp( new MaterialApp( title: '字体测试', home: new ContainerDemo(), ) );&#125; 图标及按钮控件图标组件（Icon）为展示图标的组件，该组件不可交互，要实现可交互的图标，可以考虑使用IconButton组件。图标组件相关的组件有以下几个 IconButton：可交互的Icon。 Icons：框架自带Icon集合。 IconTheme：Icon主题。 ImageIcon：通过AssetImages或者其他图片显示Icon。 图标组件123456789101112131415161718192021import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '图标组件示例', home: new LayoutDemo(), ));class LayoutDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('图标组件示例'), ), body: new Icon(Icons.phone,color: Colors.green[500],size: 80.0,), ); &#125;&#125; 图标按钮组件图标按钮组件（IconButton）是基于Material Design风格的组件，它可以响应按下事件，并且按下时会带一个水波纹的效果。如果它的onPressed回调函数为null，那么这个按钮处于禁用状态，并且不可以按下。 1234567891011121314151617181920212223242526272829import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '图标按钮组件示例', home: new IconButtonDemo(), ));class IconButtonDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text('图标按钮组件示例'), ), body: new Center( child: new IconButton( icon: Icon(Icons.volume_up,size: 48.0,), tooltip: '按下操作', onPressed: ()&#123; print('按下操作'); &#125;, ), ), ); &#125;&#125; 凸起按钮组件凸起按钮组件（RaisedButton）是Material Design中的button，一个凸起的材质矩形按钮，它可以响应按下事件，并且按下时会带一个触摸的效果。 1234567891011121314151617181920212223242526272829303132import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '图标按钮组件示例', home: new RaisedButtonDemo(), ));class RaisedButtonDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'RaisedButton示例', home: new Scaffold( appBar: new AppBar( title: new Text('RaisedButton组件示例'), ), body: new Center( child: new RaisedButton(onPressed: ()&#123; &#125;,child: new Text('RaisedButton组件', style: new TextStyle( color: Colors.green, ),),), ), ), ); &#125;&#125; 列表组件列表是前端是最常见的需求。在Flutter中，用ListView来显示列表项，支持垂直和水平方向展示，通过一个属性我们就可以控制其方向，列表有以下分类 水平的列表 垂直的列表 数据量非常大的列表 矩阵式的列表 基础列表组件基础列表组件为ListView组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '图标按钮组件示例', home: new ListViewDemo(), ));class ListViewDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; final title='基础列表示例'; return MaterialApp( title: title, home: Scaffold( appBar: AppBar( title: Text(title), ), body: new ListView( children: &lt;Widget&gt;[ ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ListTile( leading: Icon(Icons.alarm), title: Text('Alarm'), ), ], ), ), ); &#125;&#125; 水平列表组件水平列表组件即为水平方向排列的组件，列表内部元素以水平方向排。把ListView组件的scroll-Direction属性设置为Axis.horizontal即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import 'package:flutter/material.dart';void main() =&gt; runApp( new MaterialApp( title: '图标按钮组件示例', home: new ListViewHorizontalDemo(), ));class ListViewHorizontalDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; final title='水平列表'; return MaterialApp( title: title, home: Scaffold( appBar: new AppBar( title: Text(title), ), body: Container( margin: EdgeInsets.symmetric( vertical: 20.0 ), height: 200.0, child: ListView( scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ Container( width: 160.0, color: Colors.lightBlue, ), Container( width: 160.0, color: Colors.amber, ), Container( width: 160.0, color: Colors.green, child: Column( children: &lt;Widget&gt;[ Text( '水平', style: TextStyle( fontWeight: FontWeight.bold, fontSize: 36.0, ), ), Text('列表', style: TextStyle( fontWeight: FontWeight.bold, fontSize: 36.0, ), ), Icon(Icons.list), ], ), ), Container( width: 160.0, color: Colors.deepPurpleAccent, ), Container( width: 160.0, color: Colors.black, ), ], ), ), ), ); &#125;&#125; 长列表组件长列表用于显示很多项数据，这里需要一个itemBuilder，类似《第一行代码Android》中讲的列表的适配器Adapter 123456789101112131415161718192021222324252627282930313233343536373839404142import 'package:flutter/material.dart';void main() =&gt; runApp( new LongListViewDemo( //使用generate产生500条数据 items: new List&lt;String&gt;.generate(500, (i)=&gt;"Item $i"), ));class LongListViewDemo extends StatelessWidget&#123; //列表数据集 final List&lt;String&gt; items; LongListViewDemo(&#123;Key key,@required this.items&#125;):super(key:key); @override Widget build(BuildContext context) &#123; final title='长列表示例'; return MaterialApp( title: title, home: new Scaffold( appBar: new AppBar( title: new Text(title), ), //使用ListView.builder来构造列表项 body: new ListView.builder( itemCount: items.length, //列表项构造器 itemBuilder: (context,index)&#123; return new ListTile( leading: new Icon(Icons.phone), title: new Text('$&#123;items[index]&#125;'), ); &#125;, ), ), ); &#125;&#125; 网格列表组件数据量很大时用矩阵方式排列比较清晰，此时用网格列表组件，即为GridView组件，可以实现多行多列的应用场景。使用GridView创建网格列表有多种方式 GridView.count通过单行展示个数创建GridView。 GridView.extent通过最大宽度创建GridView。 1234567891011121314151617181920212223242526272829303132333435363738import 'package:flutter/material.dart';void main() =&gt; runApp(new GridViewDemo());class GridViewDemo extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; final title='网格列表示例'; return new MaterialApp( title: title, home: new Scaffold( appBar: new AppBar( title: new Text(title), ), //使用GridView.count构建网络 body: new GridView.count( primary: false, padding: const EdgeInsets.all(20.0), crossAxisSpacing: 30.0, crossAxisCount: 3, children: &lt;Widget&gt;[ const Text('第一行第一列'), const Text('第一行第二列'), const Text('第一行第三列'), const Text('第二行第一列'), const Text('第二行第二列'), const Text('第二行第三列'), const Text('第三行第一列'), const Text('第三行第二列'), const Text('第三行第三列'), ], ), ), ); &#125;&#125; 表单组件表单是一个包含表单元素的区域。表单元素允许用户输入内容，比如：文本域、下拉列表、单选框、复选框等。常见的应用场景有：登录、注册、输入信息等。表单里有两个重要的组件，一个是Form组件用来做整个表单提交使用的，另一个是TextFormField组件用来做用户输入的。 （感觉表单这个有点像Web开发里面的玩意儿，这个跟使用Java开发安卓中的EditText不太一样） 对于输入框我们最关心的是输入内容是否合法，比如邮箱地址是否正确，电话号码是否是数字，等等。等用户输入完成后，需要知道输入框输入的内容。 为了获取表单的实例，我们需要设置一个全局类型的key，通过这个key的属性，来获取表单对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import 'package:flutter/material.dart';void main() =&gt; runApp(new LoginPage());class LoginPage extends StatefulWidget&#123; @override _LoginPageState createState() =&gt;new _LoginPageState();&#125;class _LoginPageState extends State&lt;LoginPage&gt;&#123; //全局Key来获取Form表单组件 GlobalKey&lt;FormState&gt; loginKey=new GlobalKey&lt;FormState&gt;(); String userName,password; void login()&#123; var loginForm=loginKey.currentState; if(loginForm.validate())&#123; loginForm.save(); print('UserName:'+userName+" Password:"+password); &#125; &#125; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Form表单示例', home: new Scaffold( appBar: new AppBar( title: new Text('Form表单示例'), ), body: new Column( children: &lt;Widget&gt;[ new Container( padding: const EdgeInsets.all(16.0), child: new Form( key: loginKey, child: new Column( children: &lt;Widget&gt;[ new TextFormField( decoration: new InputDecoration( labelText: '请输入用户名', ), onSaved: (value)&#123; userName=value; &#125;, onFieldSubmitted: (value)&#123;&#125;, ), new TextFormField( decoration: new InputDecoration( labelText: '请输入密码', ), obscureText: true, validator: (value)&#123; return value.length&lt;6 ? "密码长度不够6位" : null; &#125;, onSaved: (value)&#123; password=value; &#125;, ) ], ), ), ), new SizedBox( width: 340.0, height: 42.0, child: new RaisedButton( onPressed: login, child: new Text( '登陆', style: TextStyle( fontSize: 18.0, ), ), ), ), ], ), ), ); &#125;&#125; 到了这里都还是很懵逼的，代码结构不是很习惯看起来有点费力]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>常用组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章：Flutter基础知识]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AFlutter%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[简介Flutter特点 跨平台：现在Flutter至少可以跨5种平台，甚至支持嵌入式开发。我们常用的有MacOS、Windows、Linux、Android、iOS，甚至可以在谷歌最新的操作系统Fuchsia上运行。到目前为止，Flutter算是支持平台最多的框架了，良好的跨平台性，直接带来的好处就是减少开发成本。 丝滑般的体验：使用Flutter内置高大上的Material Design和Cupertino风格组件、丰富的motion API、平滑而自然的滑动效果和平台感知，为用户带来全新体验。 响应式框架：使用Flutter的、响应式框架和一系列基础组件，可以轻松构建用户界面。使用功能强大且灵活的API（针对2D、动画、手势、效果等）能解决艰难的UI挑战。 支持插件：通过Flutter的插件可以访问平台本地API，如相机、蓝牙、WiFi等。借助现有的Java、Swift、Objective C、C++代码实现对原生系统的调用。 60fps超高性能：Flutter采用GPU渲染技术，所以性能极高。Flutter编写的应用是可以达到60fps（每秒传输帧数），这也就是说，它完全可以胜任游戏的制作。官方宣称用Flutter开发的应用甚至会超过原生应用的性能。 一切皆为组件组件（Widget）是Flutter应用程序用户界面的基本构建块。不仅按钮、输入框、卡片、列表这些内容可作为Widget，甚至将布局方式、动画处理都视为Widget。所以Flutter具有一致的统一对象模型：Widget。 Widget可以定义为： 一个界面组件（如按钮或输入框）。 一个文本样式（如字体或颜色）。 一种布局（如填充或滚动）。 一种动画处理（如缓动）。 一种手势处理（GestureDetector）。 Widget具有丰富的属性及方法，属性通常用来改变组件的状态（颜色、大小等）及回调方法的处理（单击事件回调、手势事件回调等）。方法主要是提供一些组件的功能扩展。比如：TextBox是一个矩形的文本组件，其属性及方法如下： bottom：底部间距属性。 direction：文本排列方向属性。 left：左侧间距属性。 right：右侧间距属性。 top：上部间距属性。 toRect：导出矩形方法。 toString：转换成字符串方法。 组件嵌套复杂的功能界面通常都是由一个一个简单功能的组件组装完成的。有的组件负责布局，有的负责定位，有的负责调整大小，有的负责渐变处理，等等。这种嵌套组合的方式带来的最大好处就是解耦。 例如，界面中添加了一个居中组件Center，居中组件里嵌套了一个容器组件Container，容器组件里嵌套了一个文本组件Text和一个装饰器BoxDecoration。代码如下 1234567891011return new Center( //添加容器 child: new Container( //添加装饰器 decoration: new BoxDecoration( ), child: new Text( //添加文本组件 ), ),), 最基础的组件类是Widget，其他所有的组件都是继承Widget的，如图1-1所示。紧接着下面有两大类组件：有状态组件及无状态组件。有状态组件是界面会发生变化的组件，如Scrollable、Animatable等，无状态的组件即界面不发生变化的组件，如Text、AssetImage等。 构建Widget可以重写Widget的build方法来构建一个组件，如下代码￼12@protected Widget build(BuildContext context);￼ build即为创建一个Widget的意思，返回值也是一个Widget对象，不管返回的是单个组件还是返回通过嵌套的方式组合的组件，都是Widget的实例。 处理用户交互如果Widget需要根据用户交互或其他因素进行更改，则该Widget是有状态的。例如，如果一个Widget的计数器在用户点击一个按钮时递增，那么该计数器的值就是该Widget的状态。当该值发生变化时，需要重新构建Widget以更新UI。 这些Widget将继承StatefulWidget（而不是State）并将它们的可变状态存储在State的子类中 每当你改变一个State对象时（例如增加计数器），必须调用setState（）来通知框架，框架会再次调用State的构建方法来更新用户界面。 有了独立的状态和Widget对象，其他Widget可以以同样的方式处理无状态和有状态的Widget，而不必担心丢失状态。父Widget可以自由地创造子Widget的新实例且不会失去子Widget的状态，而不是通过持有子Widget来维持其状态。框架在适当的时候完成查找和重用现有状态对象的所有工作。 什么是状态Flutter中的状态和React中的状态概念一致。React的核心思想是组件化的思想，应用由组件搭建而成，而组件中最重要的概念是State（状态），State是一个组件的UI数据模型，是组件渲染时的数据依据。Flutter程序的运行可以认为是一个巨大的状态机，用户的操作、请求API和系统事件的触发都是推动状态机运行的触发点，触发点通过调用setState方法推动状态机进行响应。状态的生命周期如图 分层的框架Flutter框架是一个分层的结构，每一层都建立在前一层之上。图1-4显示了Flutter框架，上层比下层的使用频率更高。 有关构成Flutter分层框架的完整库，请参阅官方的API文档 分层设计的目标是帮助开发者用更少的代码做更多的事情。例如，Material层通常组合来自Widget层的基本Widget，而Widget层通过较低级对象渲染层来构建。 分层结构为构建应用程序提供了许多选项。选择一种自定义的方法来释放框架的全部表现力，或者使用构件层中的构建块，或混合搭配。可以使用Flutter提供的所有现成的Widget，也可以使用Flutter团队用于构建框架的相同工具和技术创建定制的Widget。也就是说，你可以从高层次、统一的Widget概念中获得开发效率优势，也可以深入到下层施展才能。 开发环境搭建可以参考这里的教程codelabs.flutter-io.cn Dart语言Flutter使用的是Dart语言来开发的，关于Dart语言的学习可以自己搜索。 入口程序每一个Flutter项目的/lib目录下都有一个main.dart文件，打开该文件，里面应该有一个main（）函数。Flutter使用Dart语言开发，而在Dart语言中，main（）函数是Dart程序的入口，也就是说，Flutter程序在运行的时候，第一个执行的函数就是main（）函数。 1void main() =&gt; runApp(Wiget app); main（）函数中只调用runApp函数，使用runApp函数可以将给定的根组件填满整个屏幕。如果不调用runApp函数，项目也可以正常执行，但是屏幕上什么都不会显示。Flutter是Dart语言的移动应用框架，runApp函数就是Flutter框架的入口，如果不调用runApp函数，那你执行的就是一个Dart控制台应用。 Material Design风格每一个.dart文件的第一行几乎都会导入flutter/material.dart包，这个包是Flutter实现Material Design设计风格的基础包，里面有文本输入框（Text）、图标（Icon）、图片（Image）、行排列布局（Row）、列排列布局（Column）、Decoration（装饰器）、动画等组件，大家可以将它们理解为网页中的按钮、标题、选项框等组件库。 第一行代码如下所示：￼12import 'package:flutter/material.dart'; ￼ 那么Material Design是谷歌推出的一套视觉设计语言。比如有的App可以换皮肤，而每一套皮肤就是一种设计语言，有古典风、炫酷风、极简风，等等，而Material Design就是谷歌风。Flutter采用的就是Material Design风格。 Flutter主题为了在整个应用中使用同一套颜色和字体样式，可以使用“主题”这种方式。定义主题有两种方式：全局主题，或使用Theme来定义应用程序局部的颜色和字体样式。事实上，全局主题只是由应用程序根MaterialApp创建的主题（Theme）。 定义一个主题后，就可以在我们自己的Widget中使用它，Flutter提供的Material Widgets将使用主题为AppBars、Buttons、Checkboxes等设置背景颜色和字体样式。 创建应用主题创建主题的方法是将ThemeData提供给MaterialApp构造函数，这样就可以在整个应用程序中共享包含颜色和字体样式的主题。 如果没有提供主题，Flutter会创建一个默认主题 12345678new MaterialApp( title: title, theme: new ThemeData( brightness: Brightness.dark, primaryColor: Colors.lightBlue[800], accentColor: Colors.cyan[600], ),); 局部主题如果我们想在应用程序的某一部分使用特殊的颜色，那么就需要覆盖全局的主题。 创建特有的主题数据 实例化一个ThemeData并将其传递给Theme对象 12345678910new Theme( //创建一个特有的主题数据 data: new ThemeData( accentColor: Colors.yellow, ), child: new FloatingActionButton( onPressed: () &#123;&#125;, child: new Icon(Icons.add), ),); 扩展父主题扩展父主题时无须覆盖所有的主题属性，我们可以通过使用copyWith方法来实现，代码如下： 12345678new Theme( //覆盖accentColor为Colors.yellow data: Theme.of(context).copyWith(accentColor: Colors.yellow), child: new FloatingActionButton( onPressed: null, child: new Icon(Icons.add), ),); 使用主题首先，函数Theme.of（context）可以通过上下文来获取主题，方法是查找最近的主题，如果找不到就会找整个应用的主题。 下面来看一个简单的示例，应用的主题颜色定义为绿色，界面中间再加一个带有背景色的文本。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';void main() &#123; runApp(new MyApp());&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final appName = '自定义主题'; return new MaterialApp( title: appName, theme: new ThemeData( brightness: Brightness.light,//应用程序整体主题的亮度 primaryColor: Colors.lightGreen[600],//App主要部分的背景色 accentColor: Colors.orange[600],//前景色（文本、按钮等） ), home: new MyHomePage( title: appName, ), ); &#125;&#125;class MyHomePage extends StatelessWidget &#123; final String title; MyHomePage(&#123;Key key, @required this.title&#125;) : super(key: key); @overrideWidget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(title), ), body: new Center( child: new Container( //获取主题的accentColor color: Theme.of(context).accentColor, child: new Text( '带有背景颜色的文本组件', style: Theme.of(context).textTheme.title, ), ), ), floatingActionButton: new Theme( //使用copyWith的方式获取accentColor data: Theme.of(context).copyWith(accentColor: Colors.grey), child: new FloatingActionButton( onPressed: null, child: new Icon(Icons.computer), ), ), ); &#125;&#125; 无状态组件和有状态组件无状态组件（StatelessWidget）是不可变的，这意味着它们的属性不能改变，所有的值都是最终的。 有状态组件（StatefulWidget）持有的状态可能在Widget生命周期中发生变化。实现一个StatefulWidget至少需要两个类 一个StatefulWidget类。 一个State类。StatefulWidget类本身是不变的，但是State类在Widget生命周期中始终存在。 示例代码中MyHomePage必须继承自StatefulWidget类 1class MyHomePage extends StatefulWidget 重写createState方法 12@overrideMyHomePageState createState() =&gt; new _MyHomePageState(); 状态类必须继承自State类 1class _MyHomePageState extends State&lt;MyHomePage&gt; 定义一个普通变量_counter作为计数器变量，调用setState方法来控制这个变量的值的变化，如下所示： 12345678int _counter = 0;void _incrementCounter() &#123; setState(() &#123; //计数器变量 _counter++; &#125;);&#125; 完整的示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());//MyApp不需要做状态处理，所以此组件继承StatelessWidget即可class MyApp extends StatelessWidget &#123; // 这个组件是整个应用的主组件 @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( //自定义主题 primarySwatch: Colors.blue, ), home: new MyHomePage(title: 'Flutter Demo Home Page'), ); &#125;&#125;//主页需要继承自StatefulWidgetclass MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); //标题 final String title; //必须重写createState方法 @override _MyHomePageState createState() =&gt; new _MyHomePageState();&#125;//状态类必须继承State类,注意后面需要指定为&lt;MyHomePage&gt;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0;//计数器 void _incrementCounter() &#123; //调用State类里的setState方法来更改状态值，使得计数器加1 setState(() &#123; //计数器变量，每次点击让其加1 _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), //居中布局 body: new Center( //垂直布局 child: new Column( //主轴居中对齐 mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter',//绑定计数器的值 style: Theme.of(context).textTheme.display1, ), ], ),... 使用包资源包仓库所有包（package）都会发布到Dart的包仓库 包的使用 打开pubspec.yaml文件，在dependencies下添加包的名称及版本 点击Packages get 打开main.dart文件，导入包 1import 'package:url_launcher/url_launcher.dart'; Http请求HTTP协议通常用于做前后端的数据交互。Flutter请求网络有两种方法，一种是用Http请求，另一种是用HttpClient请求。 Http请求方式 在使用Http方式请求网络时，需要导入http包 1import 'package:http/http.dart' as http; 请看下面的完整示例代码，示例中发起了一个http的get请求，并将返回的结果信息打印到控制台里： 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';import 'package:http/http.dart' as http;void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'http请求示例', home: new Scaffold( appBar: new AppBar( title: new Text('http请求示例'), ), body: new Center( child: new RaisedButton( onPressed: () &#123; var url = 'http://httpbin.org/'; //向http://httpbin.org/发送get请求 http.get(url).then((response) &#123; print("状态： $&#123;response.statusCode&#125;"); print("正文： $&#123;response.body&#125;"); &#125;); &#125;, child: new Text('发起http请求'), ), ), ), ); &#125;&#125; ￼ 点击“发起http请求”按钮，程序开始请求指定的url，如果服务器正常返回数据，则状态码为200。控制台输出内容如下： 1234567891011121314151617181920212223242526272829303132Performing hot reload...Syncing files to device iPhone X...Reloaded 1 of 509 libraries in 452ms.flutter: 状态： 200flutter: 正文： &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;httpbin.org&lt;/title&gt; &lt;link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro:300,600|Titillium+Web:400,600,700" rel="stylesheet"&gt; &lt;link rel="stylesheet" type="text/css" href="/flasgger_static/swagger-ui.css"&gt; &lt;link rel="icon" type="image/png" href="/static/favicon.ico" sizes="64x64 32x32 16x16" /&gt; &lt;style&gt; html &#123; box-sizing: border-box; overflow: -moz-scrollbars-vertical; overflow-y: scroll; &#125; *, *:before, *:after &#123; box-sizing: inherit; &#125; body &#123; margin: 0; background: #fafafa; &#125;...]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三章：进阶技巧]]></title>
    <url>%2F2019%2F02%2F21%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[全局获取Context很多地方都需要用到Context，弹出Toast的时候需要，启动活动的时候需要，发送广播的时候需要，操作数据库的时候需要，使用通知的时候需要，等等等等。 目前很多操作都是在活动中进行的，因此很少遇到获取Context的困难，因为活动本身就是一个Context，但是应用框架逐渐复杂起来的时候，很多逻辑代码都会脱离Activity类。 第九章的HttpUtil类12345678910111213141516171819202122232425262728293031323334353637package com.zanecode6574.networktest;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpUtil &#123; public static String sendHttpRequest(String address) &#123; HttpURLConnection connection = null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; return response.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125;&#125; 这里如果想对sendHttpRequest方法进行优化，在检测到网络不存在的时候给用户一个Toast提示，但是这里是没有Context的 方法一：在sendHttpRequest方法中添加一个Context参数 方法二：Android提供了一个Application类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的Application类，以便于管理程序内一些全局的状态信息，比如说全局Context。 创建一个MyApplication类继承自Application 12345678910public class MyApplication extends Application &#123; private static Context context; @Override public void onCreate() &#123; context = getApplicationContext(); &#125; public static Context getContext() &#123; return context; &#125;&#125; 重写父类的onCreate()方法，并通过调用getApplicationContext()方法得到了一个应用程序级别的Context，然后又提供了一个静态的getContext()方法，在这里将刚才获取到的Context进行返回。 设置程序启动的时候初始化MyApplication类而不是默认的Application类 修改AndroidManifest.xml文件，在application标签下指定 1234567891011&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.networktest" android:versionCode="1" android:versionName="1.0" &gt; ... &lt;application android:name="com.example.networktest.MyApplication" ...&gt; ... &lt;/application&gt;&lt;/manifest&gt; 这里一定要加上完整的包名，否则找不到 现在修改sendHttpRequest方法直接就可以 1Toast.makeText(MyApplication.getContext(), "network is unavailable",Toast.LENGTH_SHORT).show(); 第六章使用LitePal操作数据库当时为了让LitePal正常工作，我们在application标签中配置了android:name=&quot;org.litepal.LitePalApplication&quot; 原理是一样的，这样LitePal就能在内部获取到Context 如果我们这个时候配置了自己的Application就会和LitePalApplication冲突，任何项目都只能配置一个Application，对于这种情况LitePal提供了解决方法，就是在我们的Application中调用LitePal的初始化方法 1234567891011public class MyApplication extends Application &#123; private static Context context; @Override public void onCreate() &#123; context = getApplicationContext(); LitePal.initialize(context); &#125; public static Context getContext() &#123; return context; &#125;&#125; 使用Intent传递对象Serializable方式Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方法也很简单，只需要让一个类去implements Serializable这个接口就可以直接用Intent传递了 发送对象的直接用Intent的putExtra方法，但是接收的时候要使用(类)getIntent().getSerializableExtra()方法，比如我传递的是Person类的person对象，接收的时候就是Person person=(Person)getIntent().getSerializableExtra(&quot;xxx&quot;) Parcelable方式不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。 Person类 123456789101112131415161718192021222324252627public class Person implements Parcelable &#123; private String name; private int age; ... @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(name); // 写出name dest.writeInt(age); // 写出age &#125; public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel source) &#123; Person person = new Person(); person.name = source.readString(); // 读取name person.age = source.readInt(); // 读取age return person; &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;;&#125; Parcelable的实现方式要稍微复杂一些。首先我们让Person类去实现了Parcelable接口，这样就必须重写describeContents()和writeToParcel()这两个方法。其中describeContents()方法直接返回0就可以了，而writeToParcel()方法中我们需要调用Parcel的writeXxx()方法，将Person类中的字段一一写出。注意，字符串型数据就调用writeString()方法，整型数据就调用writeInt()方法，以此类推。 除此之外，我们还必须在Person类中提供一个名为CREATOR的常量，这里创建了Parcelable.Creator接口的一个实现，并将泛型指定为Person。接着需要重写createFromParcel()和newArray()这两个方法，在createFromParcel()方法中我们要去读取刚才写出的name和age字段，并创建一个Person对象进行返回，其中name和age都是调用Parcel的readXxx()方法读取到的，注意这里读取的顺序一定要和刚才写出的顺序完全相同。而newArray()方法中的实现就简单多了，只需要new出一个Person数组，并使用方法中传入的size作为数组大小就可以了。 在接收的时候Person person = (Person) getIntent().getParcelableExtra(&quot;xxx&quot;); 总结Serializable的方式较为简单，但由于会把整个对象进行序列化，因此效率会比Parcelable方式低一些，所以在通常情况下还是更加推荐使用Parcelable的方式来实现Intent传递对象的功能。 我个人还没有感觉到差距，偏向用简单的。 定制自己的日志工具打个比方，你正在编写一个比较庞大的项目，期间为了方便调试，在代码的很多地方都打印了大量的日志。最近项目已经基本完成了，但是却有一个非常让人头疼的问题，之前用于调试的那些日志，在项目正式上线之后仍然会照常打印，这样不仅会降低程序的运行效率，还有可能将一些机密性的数据泄露出去。 因此，最理想的情况是能够自由地控制日志的打印，当程序处于开发阶段时就让日志打印出来，当程序上线了之后就把日志屏蔽掉。 新建一个LogUtil类 12345678910111213141516171819202122232425262728293031323334public class LogUtil &#123; public static final int VERBOSE = 1; public static final int DEBUG = 2; public static final int INFO = 3; public static final int WARN = 4; public static final int ERROR = 5; public static final int NOTHING = 6; public static int level = VERBOSE; public static void v(String tag, String msg) &#123; if (level &lt;= VERBOSE) &#123; Log.v(tag, msg); &#125; &#125; public static void d(String tag, String msg) &#123; if (level &lt;= DEBUG) &#123; Log.d(tag, msg); &#125; &#125; public static void i(String tag, String msg) &#123; if (level &lt;= INFO) &#123; Log.i(tag, msg); &#125; &#125; public static void w(String tag, String msg) &#123; if (level &lt;= WARN) &#123; Log.w(tag, msg); &#125; &#125; public static void e(String tag, String msg) &#123; if (level &lt;= ERROR) &#123; Log.e(tag, msg); &#125; &#125;&#125; 在LogUtil中先是定义了VERBOSE、DEBUG、INFO、WARN、ERROR、NOTHING这6个整型常量，并且它们对应的值都是递增的。然后又定义了一个静态变量level，可以将它的值指定为上面6个常量中的任意一个。 接下来我们提供了v()、d()、i()、w()、e()这5个自定义的日志方法，在其内部分别调用了Log.v()、Log.d()、Log.i()、Log.w()、Log.e()这5个方法来打印日志，只不过在这些自定义的方法中我们都加入了一个if判断，只有当level的值小于或等于对应日志级别值的时候，才会将日志打印出来。 这样就把一个自定义的日志工具创建好了，之后在项目里我们可以像使用普通的日志工具一样使用LogUtil，比如打印一行DEBUG级别的日志就可以这样写：LogUtil.d(&quot;TAG&quot;, &quot;debug log&quot;);，打印一行WARN级别的日志就可以这样写：LogUtil.w(&quot;TAG&quot;, &quot;warn log&quot;);，然后我们只需要修改level变量的值，就可以自由地控制日志的打印行为了。比如让level等于VERBOSE就可以把所有的日志都打印出来，让level等于WARN就可以只打印警告以上级别的日志，让level等于NOTHING就可以把所有日志都屏蔽掉。 使用了这种方法之后，刚才所说的那个问题就不复存在了，你只需要在开发阶段将level指定成VERBOSE，当项目正式上线的时候将level指定成NOTHING就可以了。 调试Android程序 第一种：直接使用断点，用debug模式启动，这个调试没什么好说的，打过代码都知道 第二种：动态调试，正常方式启动程序，然后点击Attach debugger to Android process按钮，选中需要调试的进程就可以进入调试模式了 创建定时任务Android中的定时任务一般有两种实现方式，一种是使用Java API里提供的Timer类，一种是使用Android的Alarm机制。这两种方式在多数情况下都能实现类似的效果，但Timer有一个明显的短板，它并不太适用于那些需要长期在后台运行的定时任务。我们都知道，为了能让电池更加耐用，每种手机都会有自己的休眠策略，Android手机就会在长时间不操作的情况下自动让CPU进入到睡眠状态，这就有可能导致Timer中的定时任务无法正常运行。而Alarm则具有唤醒CPU的功能，它可以保证在大多数情况下需要执行定时任务的时候CPU都能正常工作。需要注意，这里唤醒CPU和唤醒屏幕完全不是一个概念，千万不要产生混淆。 Alarm机制借助AlarmManager类来实现，这个类和NotificationManager有点类似，都是通过调用Context的getSystemService()方法来获取实例的，只是这里需要传入的参数是Context.ALARM_SERVICE。 获取一个AlarmManager的实例 1AlarmManager manager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); 调用AlarmManager的set()方法设置定时任务 123//设定一个任务在十秒钟后执行long triggerAtTime = SystemClock.elapsedRealtime() + 10 * 1000;manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pendingIntent); set()方法中需要传入的3个参数稍微有点复杂 第一个参数是一个整型参数，用于指定AlarmManager的工作类型，有4种值可选，分别是ELAPSED_REALTIME、ELAPSED_REALTIME_WAKEUP、RTC和RTC_WAKEUP。其中ELAPSED_REALTIME表示让定时任务的触发时间从系统开机开始算起，但不会唤醒CPU。ELAPSED_REALTIME_WAKEUP同样表示让定时任务的触发时间从系统开机开始算起，但会唤醒CPU。RTC表示让定时任务的触发时间从1970年1月1日0点开始算起，但不会唤醒CPU。RTC_WAKEUP同样表示让定时任务的触发时间从1970年1月1日0点开始算起，但会唤醒CPU。使用SystemClock.elapsedRealtime()方法可以获取到系统开机至今所经历时间的毫秒数，使用System.currentTimeMillis()方法可以获取到1970年1月1日0点至今所经历时间的毫秒数。 第二个参数就是定时任务触发的时间，以毫秒为单位。如果第一个参数使用的是ELAPSED_REALTIME或ELAPSED_REALTIME_WAKEUP，则这里传入开机至今的时间再加上延迟执行的时间。如果第一个参数使用的是RTC或RTC_WAKEUP，则这里传入1970年1月1日0点至今的时间再加上延迟执行的时间。 第三个参数是一个PendingIntent，对于它你应该已经不会陌生了吧。这里我们一般会调用getService()方法或者getBroadcast()方法来获取一个能够执行服务或广播的PendingIntent。这样当定时任务被触发的时候，服务的onStartCommand()方法或广播接收器的onReceive()方法就可以得到执行。 另外一种写法 12long triggerAtTime = System.currentTimeMillis() + 10 * 1000;manager.set(AlarmManager.RTC_WAKEUP, triggerAtTime, pendingIntent); 设定一个长时间在后台定试运行的服务 新建一个普通的服务，将触发定时任务的代码写到onStartCommand()方法中 12345678910111213141516171819202122public class LongRunningService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 在这里执行具体的逻辑操作 &#125; &#125;).start(); AlarmManager manager = (AlarmManager) getSystemService(ALARM_SERVICE); int anHour = 60 * 60 * 1000; // 这是一小时的毫秒数 long triggerAtTime = SystemClock.elapsedRealtime() + anHour; Intent i = new Intent(this, LongRunningService.class); PendingIntent pi = PendingIntent.getService(this, 0, i, 0); manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); return super.onStartCommand(intent, flags, startId); &#125;&#125; 先是在onStartCommand()方法中开启了一个子线程，这样就可以在这里执行具体的逻辑操作了。之所以要在子线程里执行逻辑操作，是因为逻辑操作也是需要耗时的，如果放在主线程里执行可能会对定时任务的准确性造成轻微的影响。 创建线程之后的代码就是我们刚刚讲解的Alarm机制的用法了，先是获取到了AlarmManager的实例，然后定义任务的触发时间为一小时后，再使用PendingIntent指定处理定时任务的服务为LongRunningService，最后调用set()方法完成设定。这样我们就将一个长时间在后台定时运行的服务成功实现了。因为一旦启动了LongRunningService，就会在onStartCommand()方法里设定一个定时任务，这样一小时后将会再次启动LongRunningService，从而也就形成了一个永久的循环，保证LongRunningService的onStartCommand()方法可以每隔一小时就执行一次。 启动定时任务 12Intent intent = new Intent(context, LongRunningService.class);context.startService(intent); 从Android 4.4系统开始，Alarm任务的触发时间将会变得不准确，有可能会延迟一段时间后任务才能得到执行。这并不是个bug，而是系统在耗电性方面进行的优化。系统会自动检测目前有多少Alarm任务存在，然后将触发时间相近的几个任务放在一起执行，这就可以大幅度地减少CPU被唤醒的次数，从而有效延长电池的使用时间。当然，如果你要求Alarm任务的执行时间必须准确无误，Android仍然提供了解决方案。使用AlarmManager的setExact()方法来替代set()方法，就基本上可以保证任务能够准时执行了。 如果想准确无误的启动就可以使用setExact()方法，基本能够保证任务准确执行 Doze模式在Android 6.0系统中，谷歌加入了一个全新的Doze模式，从而可以极大幅度地延长电池的使用寿命。 简介当用户的设备是Android 6.0或以上系统时，如果该设备未插接电源，处于静止状态（Android 7.0中删除了这一条件），且屏幕关闭了一段时间之后，就会进入到Doze模式。在Doze模式下，系统会对CPU、网络、Alarm等活动进行限制，从而延长了电池的使用寿命。 当然，系统并不会一直处于Doze模式，而是会间歇性地退出Doze模式一小段时间，在这段时间中，应用就可以去完成它们的同步操作、Alarm任务，等等。 随着设备进入Doze模式的时间越长，间歇性地退出Doze模式的时间间隔也会越长。因为如果设备长时间不使用的话，是没必要频繁退出Doze模式来执行同步等操作的，Android在这些细节上的把控使得电池寿命进一步得到了延长。 Doze模式下 网络访问被禁止。 系统忽略唤醒CPU或者屏幕操作。 系统不再执行WIFI扫描。 系统不再执行同步服务。 Alarm任务将会在下次退出Doze模式的时候执行。 最后一条表示在这种状态下Alarm任务会变得不准时，如果有非常特殊的需求让定时任务在Doze模式下也运行，Android提供了解决方案，调用AlarmManager的setAndAllowWhileIdle()或setExactAndAllowWhileIdle()方法就能让定时任务即使在Doze模式下也能正常执行了，这两个方法之间的区别和set()、setExact()方法之间的区别是一样的。 多窗口模式编程Android 7.0系统中却引入了一个非常有特色的功能——多窗口模式，它允许我们在同一个屏幕中同时打开两个应用程序。据我了解目前的大多数用户不知道这个功能，我本人也极少数时候会用到。前面写的程序不需要多写代码来支持这种模式。 在多窗口模式下，整个应用的界面会缩小很多，那么编写程序时就应该多考虑使用match_parent属性、RecyclerView、ListView、ScrollView等控件，来让应用的界面能够更好地适配各种不同尺寸的屏幕，尽量不要出现屏幕尺寸变化过大时界面就无法正常显示的情况。 多窗口模式下的生命周期多窗口模式并不会改变活动原有的生命周期，只是会将用户最近交互过的那个活动设置为运行状态，而将多窗口模式下另外一个可见的活动设置为暂停状态。如果这时用户又去和暂停的活动进行交互，那么该活动就变成运行状态，之前处于运行状态的活动变成暂停状态。 这里可以自己把两个Demo的生命周期的函数加入log来体验这种窗口模式下的生命周期 编写程序的时候，就可以将一些关键性的点考虑进去了。比如说，在多窗口模式下，用户仍然可以看到处于暂停状态的应用，那么像视频播放器之类的应用在此时就应该能继续播放视频才对。因此，我们最好不要在活动的onPause()方法中去处理视频播放器的暂停逻辑，而是应该在onStop()方法中去处理，并且在onStart()方法恢复视频的播放。 针对于进入多窗口模式时活动会被重新创建，如果你想改变这一默认行为，可以在AndroidManifest.xml中对活动进行如下配置 123456&lt;activity android:name=".MainActivity" android:label="Fruits" android:configChanges="orientation|keyboardHidden|screenSize|screenLayout"&gt; ...&lt;/activity&gt; 加入了这行配置之后，不管是进入多窗口模式，还是横竖屏切换，活动都不会被重新创建，而是会将屏幕发生变化的事件通知到Activity的onConfigurationChanged()方法当中。因此，如果你想在屏幕发生变化的时候进行相应的逻辑处理，那么在活动中重写onConfigurationChanged()方法即可。 禁用多窗口模式在AndroidManifest.xml的&lt;application&gt;或&lt;activity&gt;标签中加入如下属性即可 1android:resizeableActivity=["true" | "false"] 其中，true表示应用支持多窗口模式，false表示应用不支持多窗口模式，如果不配置这个属性，那么默认值为true。 虽说android:resizeableActivity这个属性的用法很简单，但是它还存在着一个问题，就是这个属性只有当项目的targetSdkVersion指定成24或者更高的时候才会有用，否则这个属性是无效的。那么比如说我们将项目的targetSdkVersion指定成23，这个时候尝试进入多窗口模式，会提示你此App在分屏模式下可能会无法正常工作，但是还是会进入分屏模式，很多的老项目，它们的targetSdkVersion都没有指定到24，针对这种情况Android规定，如果项目指定的targetSdkVersion低于24，并且活动是不允许横竖屏切换的，那么该应用也将不支持多窗口模式。 让应用不支持横竖屏切换 在AndroidManifest的&lt;activity&gt;中加入配置 1android:screenOrientation=["portrait" | "landscape"] portrait表示活动只支持竖屏，landscape表示活动只支持横屏。当然android: screenOrientation属性中还有很多其他可选值，不过最常用的就是portrait和landscape了。 123456&lt;activity android:name=".MainActivity" android:label="Fruits" android:screenOrientation="portrait"&gt; ...&lt;/activity&gt; Lambda表达式Lambda表达式却最低兼容到Android 2.3系统，基本上可以算是覆盖所有的Android手机，这是Java8的新特性。 Lambda 表达式本质上是一种匿名方法，它既没有方法名，也即没有访问修饰符和返回值类型，使用它来编写代码将会更加简洁，也更加易读。 使用 在app/build.gradle中添加配置即可 123456789101112android &#123; ... defaultConfig &#123; ... jackOptions.enabled = true &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; ...&#125; 例子开启一个新线程123new Thread(() -&gt; &#123; // 处理具体的逻辑&#125;).start(); 凡是这种只有一个待实现方法的接口，都可以使用Lambda表达式的写法。 自定义一个接口123public interface MyListener &#123; String doSomething(String a, int b);&#125; 实现方法 1234MyListener listener = (String a, int b) -&gt; &#123; String result = a + b; return result;&#125;; Java还可以根据上下文自动推断出Lambda表达式中的参数类型，因此上面的代码也可以简化成如下写法 1234MyListener listener = (a, b) -&gt; &#123; String result = a + b; return result;&#125;; Java将会自动推断出参数a是String类型，参数b是int类型，从而使得我们的代码变得更加精简。 举例123456public void hello(MyListener listener) &#123; String a = "Hello Lambda"; int b = 1024; String result = listener.doSomething(a, b); Log.d("TAG", result);&#125; 我们在调用hello()这个方法的时候就可以这样写 1234hello((a, b) -&gt; &#123; String result = a + b; return result;&#125;); 其实只要是符合接口中只有一个待实现方法这个规则的功能，都是可以使用Lambda表达式来编写的。除了刚才举例说明的开启子线程之外，还有像设置点击事件之类的功能也是非常适合使用Lambda表达式的。 设置点击事件1234Button button = (Button) findViewById(R.id.button);button.setOnClickListener((v) -&gt; &#123; // 处理点击事件&#125;); 当接口的待实现方法有且只有一个参数的时候，我们还可以进一步简化，将参数外面的括号去掉 1234Button button = (Button) findViewById(R.id.button);button.setOnClickListener(v -&gt; &#123; // 处理点击事件&#125;); 我有点不适应这种写法…]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>进阶</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[额外篇：Git相关]]></title>
    <url>%2F2019%2F02%2F21%2F%E9%A2%9D%E5%A4%96%E7%AF%87%EF%BC%9AGit%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Git简介Git是一个开源的分布式版本控制工具，它的开发者是Linux操作系统的作者Linus Torvalds。Git被开发出来的初衷是为了更好地管理Linux内核，而现在却早已被广泛应用于全球各种大中小型的项目中。 安装Git安装Git的方法有很多，我个人使用的Mac，可以直接使用brew进行安装。 如果是Windows就去https://git-for-windows.github.io下载安装包进行安装 创建代码仓库使用Git建议使用命令进行操作，不建议使用图形界面，如果是Linux系统，直接打开shell界面，如果是Windows，找到Git bash打开 配置身份12git config --global user.name "XXX"git config --global user.email "XXX" 把”XXX”替换成自己的名字和邮箱即可，使用git config --global user.name可以查询当前设置的用户姓名，查询邮箱同理 创建仓库（Repository）是用于保存版本管理所需信息的地方，所有本地提交的代码都会被提交到代码仓库中，如果有需要还可以再推送到远程仓库中。这里我尝试给我的一个Demo建立一个代码仓库 shell进入到项目的目录下 输入命令git init,会提示已经初始化空仓库于你的项目文件夹下，文件夹下就多出一个.git的隐藏文件夹，这个文件夹就是用来记录本地所有git操作的，如果要删除本地仓库，删除这个文件夹即可 提交本地代码提交代码只需要用到add和commit命令就可以了，add用于把想要提交的代码先添加进来，commit是真正的执行提交操作，比如添加build.gradle文件，则输入命令 1git add build.gradle 如果想要添加某个目录就在add后面添加上目录名即可，如果想全部添加就输入git add . 我把所有文件都添加进去 提交，输入git commit -m &quot;First commit.&quot;,在commit的后面一定要加上-m来加上提交的描述信息，没有描述信息会被认定为不合法 忽略文件在安卓项目的build目录下都是编译项目的时候生成的文件，不应该将这一份文件添加到版本控制当中，Git提供了一种可配性很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的目录下是否存在一个名为.gitignore的文件，如果存在的话，就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意.gitignore中指定的文件或目录是可以使用“*”通配符的。 Android Studio在创建项目的时候已经帮我们创建好了这个文件，一个在根目录下面，一个在app模块下面。 可以任意修改这两个文件来满足我们的需求，比如app模块下所有测试文件都只是给我自己使用的，那么修改app/.gitignore文件即可 123/build/src/test/src/androidTest 查看修改内容在进行了第一次代码提交之后，我们后面还可能会对项目不断地进行维护或添加新功能等。比较理想的情况是每当完成了一小块功能，就执行一次提交。但是如果某个功能牵扯到的代码比较多，有可能写到后面的时候我们就已经忘记前面修改了什么东西了。 使用git status即可，但是目前我们的代码没有修改过，会提示项目中没有任何可提交的文件，现在去修改一下代码 再次输入，会提示我如下 如果想查看更改的内容，输入git diff 想查看的文件路径,减号代表删除的，加号代表增加的 撤销未提交的更改代码未add的情况刚才修改了代码中的50为60，现在如果想撤销更改可以使用checkout命令，用法 1git checkout 文件路径 刚才做的修改已经撤销了 已经add的情况如果代码修改了，并且已经add过了，就要先使用git reset HEAD 文件路径,然后使用checkout命令即可 查看提交记录 使用git log即可查看历史提交信息 如果只想查看一条记录可以在命令中指定记录的id，git log id -l，使用-l参数表示只想看到一条记录 查看记录具体修改了什么，加入-p参数即可 分支的用法分支是版本控制工具中比较高级且比较重要的一个概念，它主要的作用就是在现有代码的基础上开辟一个分叉口，使得代码可以在主干线和分支线上同时进行开发，且相互之间不会影响。 通常情况下，只在主干线上进行开发是完全没有问题的，不过一旦涉及出版本的情况，如果不建立分支的话，你就会非常地头疼。举个简单的例子吧，比如说你们公司研发了一款不错的软件，最近刚刚完成，并推出了1.0版本。但是领导是不会让你们闲着的，马上提出了新的需求，让你们投入到了1.1版本的开发工作当中。过了几个星期，1.1版本的功能已完成了一半，但是这个时候有用户反馈，之前上线的1.0版本发现了几个重大的bug，严重影响软件的正常使用。领导也相当重视这个问题，要求你们立刻修复这些bug，并重新发布1.0版本，但这个时候你就非常为难了，你会发现根本没法去修复这些bug。因为现在1.1版本已开发一半了，如果在现有代码的基础上修复这些bug，那么更新的1.0版本将会带有一半1.1版本的功能！进退两难了是不是？但是如果你使用了分支的话，就完全不会存在这个让人头疼的问题。你只需要在发布1.0版本的时候建立一个分支，然后在主干线上继续开发1.1版本的功能。当1.0版本上发现任何bug的时候，就在分支线上进行修改，然后发布新的1.0版本，并记得将修改后的代码合并到主干线上。这样的话，不仅可以轻松解决掉1.0版本存在的bug，而且保证了主干线上的代码也已经修复了这些bug，当1.1版本发布时就不会有同样的bug存在了。 查看分支使用git branch命令查看即可，但是项目中还没有分支，就会只显示一个* master 创建一个分支1git branch version1.0 这样就创建了一个名字为version1.0的分支，现在再用git branch命令就会显示出来 切换分支是master上有一个*号，说明目前是在master分支上的，要切换分支使用如下命令 1git checkout version1.0 两个分支上的修改都互不影响 合并分支如果我们在version1.0上修复了一个bug，现在想将代码合并到master上去 12git checkout mastergit merge version1.0 合并分支可能会出现代码冲突的情况，这个要自己排查 删除分支1git branch -D version1.0 与远程版本库协作如果你是一个人在开发，那么使用版本控制工具就远远无法发挥出它真正强大的功能。没错，所有版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发。每个人的电脑上都会有一份代码，当团队的某个成员在自己的电脑上编写完成了某个功能后，就将代码提交到服务器，其他的成员只需要将服务器上的代码同步到本地，就能保证整个团队所有人的代码都相同。这样的话，每个团队成员就可以各司其职，大家共同来完成一个较为庞大的项目。 这就需要有一个远程的版本库，团队的每个成员都从这个版本库中获取到最原始的代码，然后各自进行开发，并且以后每次提交的代码都同步到远程版本库上就可以了。另外，团队中的每个成员最好都要养成经常从版本库中获取最新代码的习惯，不然的话，大家的代码就很有可能经常出现冲突。 下载远程库的代码 比如远程版本库地址为https://github.com/example/test.git 将代码下载到本地的命令git clone https://github.com/example/test.git 提交修改 对代码进行了修改以后把本地修改同步到远程版本库git push origin master,其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支上，上述命令就完成了将本地代码同步到https://github.com/example/test.git这个版本库的master分支上的功能 同步远程库的修改到本地 Git提供了两种命令来完成此功能，分别是fetch和pull，fetch的语法规则和push是差不多的 执行git fetch origin master命令以后，会将远程库上的代码同步到本地，但是同步下来的代码不会合并到任何分支上，而是存到一个origin/master分支上，然后我们通过diff命令来查看远程库上的版本修改了哪些东西git diff origin/master，之后再调用merge命令将origin/master分支上的修改合并到主分支上即可git merge origin/master pull命令是相当于将fetch和merge合并到一起了，它从远程库获取最新的代码并同步到本地git pull origin master 将代码托管到GitHub上GitHub是全球最大的代码托管网站，主要是借助Git来进行版本控制的。任何开源软件都可以免费地将代码提交到GitHub上，以零成本的代价进行代码托管。GitHub的官网地址是https://github.com 注册GitHub 点击start a project来创建一个版本库 创建一个Android项目 将远程版本库克隆到本地,点击这里复制地址 终端进入创建的项目目录，输入git clone 地址把远程库克隆到本地 现在将当前文件夹下的所有文件复制到上一层并删除当前的目录，最终项目结构如下 添加到文件到版本控制git add . 提交git commit -m &quot;测试提交&quot; 将提交的内容同步到远程库git push origin master，会让你输入用户名和密码进行校验 大概的用法就是这样了，平时很少用，了解一下 配置SSH Key实现无密码Push Windows用户可以用Xshell一类的工具生成，MacOS直接用ssh-keygen -t rsa -C &quot;邮箱&quot;来生成，生成的Key在当前用户 ~/.ssh 目录中。 找到目录中的id_rsa.pub，将其中的内容复制 打开Github，点击头像-Settings-SSH and GPG keys-New SSH Key，然后把之前复制的内容填进去，Title自己填就行了 验证 找到之前创建的测试项目，点击Clone or download按钮，选择Use SSH，然后复制地址 使用git clone 地址将项目clone下来，然后修改项目中的文件 git add .添加文件 git commit -m &quot;描述&quot;提交修改 git push提交到Github，现在不需要密码了]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Servlet建立小型应用服务器]]></title>
    <url>%2F2019%2F02%2F21%2F%E4%BD%BF%E7%94%A8Servlet%E5%BB%BA%E7%AB%8B%E5%B0%8F%E5%9E%8B%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言前段时间写App遇到了需要服务器的情况，这里使用的是Servlet，需要用到的工具和软件： Tomcat-9.0.16 JDK-8u202,这里我的网盘提供三个版本的，分别是Linux-x64、Windows-x64、MacOSx-x64 JSON、Servlet、Mysql需要的jar包 下载地址：Servlet服务器所需文件 把文件下载下来，其中jdk环境变量配置好，Tomcat放到自己想放的位置，如果是Mac可以直接用brew安装tomcat （我这里提供的是我用的版本，mysql版本和jdk自己可以换，和本机不一致可能会出错） 配置IDEAIDEA对于学生是免费的，使用学校.edu.cn的邮箱进行申请就可以免费使用，到期了还可以续期，十分方便，当然使用别的例如Ecplise也可以 配置项目文件结构 打开IDEA新建一个Java Web项目，Tomcat那里暂时不用管，我是因为之前配置过了所以有 在WEB-INF文件夹下创建classes文件夹和lib文件夹（这一步不知道是不是必须的，我在网上看到的教程是这样的），后面会用到这个文件夹,classes目录用来存放编译后的class文件，lib用来存放依赖的jar包 打开File-Project Structure-Modules，选中自己的项目，Paths选项卡，勾选 “Use module compile output path”，将 “Output path” 和 “Test output path” 都改为之前创建的classes目录 点击Dependencies选项卡，点击“+”,选择Jars…，然后选择创建的lib文件夹，选择Jar Directory，最后Apply即可 设置配置打包方式Artifacts，选择Artifacts，一般这里保持默认即可，勾选“Show content of elements”，表示显示详细的内容列表 配置Tomcat 点击IDEA菜单的Run-Edit Configurations-Run Configurations，点击”+”-Tomcat Server-Local，创建一个新的Tomcat容器 在”Name”处输入新的服务名，点击Application server-Configure，弹出Tomcat Server窗口，选择本地安装的Tomcat目录（Mac通过brew安装的Tomcat在/usr/local/Cellar/tomcat文件夹中，需要选择/usr/local/Cellar/tomcat/9.0.16/libexec目录，别的直接选择安装的Tomcat的目录就行了） 测试在项目的index.jsp中添加想显示的字符 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;"Hello" &lt;/body&gt;&lt;/html&gt; 然后点击绿色三角形就可以测试了 成功运行 写Servlet测试类这里我做一个数据库连接验证账户是否存在的Demo，我们把需要的jar导入到项目中，右键点击我们创建的lib文件夹，打开目录，把刚才下载的JSON、Mysql、Servlet包放进目录中 然后右键点击项目中的lib文件夹，点击add as library， 添加的Jar包都有一个箭头就说明成功了 写一个用户类 123456789101112public class User &#123; private String userName; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125;&#125; 数据库操作类DBManager，继承HttpServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.ResultSet;import java.util.logging.Level;import java.util.logging.Logger;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;public class DBManager extends HttpServlet &#123; ServletConfig config; private static String username; private static String password; private static String url; private static Connection connection; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); this.config=config; username=config.getInitParameter("DBUsername"); password=config.getInitParameter("DBPassword"); url=config.getInitParameter("ConnectionURL"); &#125; public static Connection getConnection()&#123; try&#123; Class.forName("com.mysql.jdbc.Driver").newInstance(); connection= DriverManager.getConnection(url,username,password); &#125;catch(ClassNotFoundException | InstantiationException | IllegalAccessException | SQLException ex)&#123; Logger.getLogger(DBManager.class.getName()).log(Level.SEVERE,null,ex); &#125; return connection; &#125; //关闭连接 public static void closeAll(Connection connection, Statement statement, ResultSet resultSet)&#123; try&#123; if(resultSet!=null)&#123; resultSet.close(); &#125; if(statement!=null)&#123; statement.close(); &#125; if(connection!=null)&#123; connection.close(); &#125; &#125;catch(SQLException ex)&#123; Logger.getLogger(DBManager.class.getName()).log(Level.SEVERE,null,ex); &#125; &#125; //没有 public static void closeAll(Connection connection, Statement statement)&#123; try&#123; if(statement!=null)&#123; statement.close(); &#125; if(connection!=null)&#123; connection.close(); &#125; &#125;catch(SQLException ex)&#123; Logger.getLogger(DBManager.class.getName()).log(Level.SEVERE,null,ex); &#125; &#125;&#125; UserDAO类，负责用户相关数据操作（这里我的数据库表名为users，只有一个字段userName） 1234567891011121314151617181920212223242526272829303132333435363738import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.logging.Level;import java.util.logging.Logger;public class UserDAO &#123; //查询账户是否存在 public static Boolean queryUser(String userName)&#123; //连接数据库 Connection connection=DBManager.getConnection(); PreparedStatement preparedStatement=null; ResultSet resultSet=null; //SQL查询 StringBuilder sqlStatement=new StringBuilder(); sqlStatement.append("select * from users where userName=?"); //设置数据库的字段值 try&#123; preparedStatement=connection.prepareStatement(sqlStatement.toString()); preparedStatement.setString(1,userName); resultSet=preparedStatement.executeQuery(); if(resultSet.next())&#123; return true; &#125;else&#123; return false; &#125; &#125;catch(SQLException e)&#123; Logger.getLogger(UserDAO.class.getName()).log(Level.SEVERE,null,e); return null; &#125;finally &#123; DBManager.closeAll(connection,preparedStatement,resultSet); &#125; &#125;&#125; LoginServlet，用来进行登陆服务，继承自HttpServlet，使用ctrl+o快捷键可以快速添加重写方法，这里重写doPost和doGet即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import net.sf.json.JSONObject;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置响应内容编码 resp.setContentType("text/html;charset=utf-8"); req.setCharacterEncoding("utf-8"); resp.setCharacterEncoding("utf-8"); try(PrintWriter out=resp.getWriter())&#123; //获取请求中传过来的账号 String userName=req.getParameter("userName").trim(); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(); JSONObject jsonObject = new JSONObject(); //验证是否存在这个人 if (login(userName)) &#123; params.put("Result", "success"); &#125; else &#123; params.put("Result", "failed"); &#125; jsonObject.put("params", params); out.write(jsonObject.toString()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; private Boolean login(String userName)&#123; return UserDAO.queryUser(userName); &#125;&#125; 创建数据库，这里我就使用本地数据库Mysql 创建一个数据库，创建一个表users，字段id主键，userName 这里我增加一个用户叫admin 配置web.xml 这里要把servlet都写进去才会正常运行 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/Login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DBManager&lt;/servlet-name&gt; &lt;servlet-class&gt;DBManager&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;DBUsername&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;DBPassword&lt;/param-name&gt; &lt;param-value&gt;123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;ConnectionURL&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/testDB&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DBManager&lt;/servlet-name&gt; &lt;url-pattern&gt;/DBManager&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; DBManager中配置了数据库的参数 点击运行项目 用浏览器访问localhost:8080/JavaWebTest_war_exploded/Login?userName=admin,这里的Login是我在web.xml中配置&lt;url-pattern&gt;/Login&lt;/url-pattern&gt;参数的时候配置的，后面跟的是参数，多个参数用&amp;隔开即可，比如我做的是验证账号密码的，就写成...Login?userName=admin&amp;password=xxx就行了，这里我只有账号 返回如下的结果，用户存在，验证成功 最后 这就是一个简易的服务器，客户端访问对应的地址，服务器返回信息，在实际操作中一般参数都会进行加密以后传输，建议使用post方法向服务器提交信息，因为get方法中参数直接跟在链接后面，有些参数在经过URLEncode以后会带有比如+号，传输到服务器上，服务器解读出来就会当成空格处理，解析出来就不对了，用post可以有效避免这种情况 关于在客户端处理返回信息的就自己使用JSON处理即可，因为Demo返回的是JSON信息，客户端获取到返回的信息再进行相应的逻辑操作即可]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Servlet</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二章：MaterialDesign实战]]></title>
    <url>%2F2019%2F01%2F27%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%EF%BC%9AMaterialDesign%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[长久以来，大多数人都认为Android系统的UI并不算美观，至少没有iOS系统的美观。以至于很多IT公司在进行应用界面设计的时候，为了保证双平台的统一性，强制要求Android端的界面风格必须和iOS端一致。这种情况在现实工作当中实在是太常见了，虽然我认为这是非常不合理的。因为对于一般用户来说，他们不太可能会在两个操作系统上分别去使用同一个应用，但是却必定会在同一个操作系统上使用不同的应用。因此，同一个操作系统中各个应用之间的界面统一性要远比一个应用在双平台的界面统一性重要得多，只有这样，才能给使用者带来更好的用户体验。 但问题在于，Android标准的界面设计风格并不是特别被大众所接受，很多公司都觉得自己完全可以设计出更加好看的界面，从而导致Android平台的界面风格长期难以得到统一。为了解决这个问题，谷歌也是祭出了杀手锏，在2014年Google I/O大会上重磅推出了一套全新的界面设计语言——Material Design。 什么是Material DesignMaterial Design是由谷歌的设计工程师们基于传统优秀的设计原则，结合丰富的创意和科学技术所发明的一套全新的界面设计语言，包含了视觉、运动、互动效果等特性。那么谷歌凭什么认为Material Design就能解决Android平台界面风格不统一的问题呢？一言以蔽之，好看！ 不过，在重磅推出之后，Material Design的普及程度却不能说是特别理想。因为这只是一个推荐的设计规范，主要是面向UI设计人员的，而不是面向开发者的。很多开发者可能根本就搞不清楚什么样的界面和效果才叫Material Design，就算搞清楚了，实现起来也会很费劲，因为不少Material Design的效果是很难实现的，而Android中却几乎没有提供相应的API支持，一切都要靠开发者自己从零写起。 谷歌当然也意识到了这个问题，于是在2015年的Google I/O大会上推出了一个Design Support库，这个库将Material Design中最具代表性的一些控件和效果进行了封装，使得开发者在即使不了解Material Design的情况下也能非常轻松地将自己的应用material化。本章中我们就将对Design Support这个库进行深入的学习，并且配合一些其他的控件来完成一个优秀的Material Design应用。 Toolbar对于Toolbar你暂时应该还是比较陌生的，但是对于它的另一个相关控件ActionBar，你就应该有点熟悉了。 回忆一下，我们曾经在3.4.1小节为了使用一个自定义的标题栏，而把系统原生的ActionBar隐藏掉。没错，每个活动最顶部的那个标题栏其实就是ActionBar，之前我们编写的所有程序里一直都有ActionBar的身影。 不过ActionBar由于其设计的原因，被限定只能位于活动的顶部，从而不能实现一些Material Design的效果，因此官方现在已经不再建议使用ActionBar了。那么本书中我也就不准备再介绍ActionBar的用法了，而是直接讲解现在更加推荐使用的Toolbar。 Toolbar的强大之处在于，它不仅继承了ActionBar的所有功能，而且灵活性很高，可以配合其他控件来完成一些Material Design的效果。 任何一个新建的项目都会包含ActionBar，这是根据项目指定的主题来的，打开AndroidManifest.xml文件，其中android:theme=&quot;@style/AppTheme&quot;指定了一个AppTheme的主题，而这个主题是在res/values/styles.xml中定义的，代码如下 1234567891011&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 这里定义了一个叫AppTheme的主题，然后指定它的parent主题是Theme.AppCompat.Light.DarkActionBar。这个DarkActionBar是一个深色的ActionBar主题，我们之前所有的项目中自带的ActionBar就是因为指定了这个主题才出现的。 现在我们准备使用Toolbar来替代ActionBar，因此需要指定一个不带ActionBar的主题，通常有Theme.AppCompat.NoActionBar和Theme.AppCompat.Light.NoActionBar这两种主题可选。其中Theme.AppCompat.NoActionBar表示深色主题，它会将界面的主体颜色设成深色，陪衬颜色设成淡色。而Theme.AppCompat.Light.NoActionBar表示淡色主题，它会将界面的主体颜色设成淡色，陪衬颜色设成深色。 我们之前的应用都是淡色，这里也用淡色 修改代码 1234567891011&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 观察一下AppTheme中的属性重写，这里重写了colorPrimary、colorPrimaryDark和colorAccent这3个属性的颜色。 除了上述3个属性之外，我们还可以通过textColorPrimary、windowBackground和navigationBarColor等属性来控制更多位置的颜色。不过唯独colorAccent这个属性比较难理解，它不只是用来指定这样一个按钮的颜色，而是更多表达了一个强调的意思，比如一些控件的选中状态也会使用colorAccent的颜色。 修改activity_main.xml的代码 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" xmlns:app="http://schemas.android.com/apk/res-auto" tools:context=".MainActivity"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;/FrameLayout&gt; xmlns:app指定了一个新的命名空间，由于每个布局文件都会使用xmlns:android来指定一个命名空间，因此我们才能一直使用android:id、android: layout_width等写法，那么这里指定了xmlns:app，也就是说现在可以使用app:attribute这样的写法了，由于Material Design是在Android 5.0系统中才出现的，而很多的material属性在5.0之前的系统中并不存在，那么为了能够兼容之前的老系统，我们就不能使用android:attribute这样的写法了，而是应该使用app:attribute 接下来定义了一个Toolbar控件，这个控件是由appcompat-v7库提供的。这里我们给Toolbar指定了一个id，将它的宽度设置为match_parent，高度设置为actionBar的高度，背景色设置为colorPrimary。不过下面的部分就稍微有点难理解了，由于我们刚才在styles.xml中将程序的主题指定成了淡色主题，因此Toolbar现在也是淡色主题，而Toolbar上面的各种元素就会自动使用深色系，这是为了和主体颜色区别开。但是这个效果看起来就会很差，之前使用ActionBar时文字都是白色的，现在变成黑色的会很难看。那么为了能让Toolbar单独使用深色主题，这里我们使用android:theme属性，将Toolbar的主题指定成了ThemeOverlay.AppCompat.Dark.ActionBar。但是这样指定完了之后又会出现新的问题，如果Toolbar中有菜单按钮（我们在2.2.5小节中学过），那么弹出的菜单项也会变成深色主题，这样就再次变得十分难看，于是这里使用了app:popupTheme属性单独将弹出的菜单项指定成了淡色主题。之所以使用app:popupTheme，是因为popupTheme这个属性是在Android 5.0系统中新增的，我们使用app:popupTheme的话就可以兼容Android 5.0以下的系统了。 修改MainActivity的代码 1234567891011121314151617package com.zanecode6574.materialtest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.Toolbar;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); &#125;&#125; 这里直接打Toolbar会出来两个选择，而这里用的是v7库中的，注意选择.虽然看上去和之前的标题栏没什么两样，但其实它已经是Toolbar而不是ActionBar了。因此它现在也具备了实现Material Design效果的能力 Toolbar常用功能label属性，指定Toolbar中显示的内容 修改AndroidManifest中的代码 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.zanecode6574.materialtest"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" android:label="测试material"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 这里给activity增加了一个android:label属性，用于指定在Toolbar中显示的文字内容，如果没有指定的话，会默认使用application中指定的label内容，也就是我们的应用名称。 到这里我发现之前有些单词我给打错了，material打成了material，不管了，不影响 添加一些Action按钮 提前准备图片作为图标,可以放在drawable-xxhdpi目录下,我这里就直接用那个默认图标算了 在res目录下新建文件夹menu，然后在menu中新建Menu resource file，命名为toolbar.xml文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/backup" android:icon="@mipmap/ic_launcher" android:title="Backup" app:showAsAction="always"/&gt; &lt;item android:id="@+id/delete" android:icon="@mipmap/ic_launcher" android:title="Delete" app:showAsAction="ifRoom"/&gt; &lt;item android:id="@+id/settings" android:icon="@mipmap/ic_launcher" android:title="Settings" app:showAsAction="never"/&gt;&lt;/menu&gt; 我们通过&lt;item&gt;标签来定义action按钮，android:id用于指定按钮的id，android:icon用于指定按钮的图标，android:title用于指定按钮的文字。 接着使用app:showAsAction来指定按钮的显示位置，之所以这里再次使用了app命名空间，同样是为了能够兼容低版本的系统。showAsAction主要有以下几种值可选：always表示永远显示在Toolbar中，如果屏幕空间不够则不显示；ifRoom表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中；never则表示永远显示在菜单当中。注意，Toolbar中的action按钮只会显示图标，菜单中的action按钮只会显示文字。 修改MainActivity的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.zanecode6574.materialtest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import android.widget.Toolbar;public class MainActivity extends AppCompatActivity &#123; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); &#125;&#125; 在onCreateOptionsMenu()方法中加载了toolbar.xml这个菜单文件，然后在onOptionsItemSelected()方法中处理各个按钮的点击事件。 Toolbar上面现在显示了两个action按钮，这是因为Backup按钮指定的显示位置是always，Delete按钮指定的显示位置是ifRoom，而现在屏幕空间很充足，因此两个按钮都会显示在Toolbar中。另外一个Settings按钮由于指定的显示位置是never，所以不会显示在Toolbar中，点击一下最右边的菜单按钮来展开菜单项，你就能找到Settings按钮了。 滑动菜单滑动菜单可以说是Material Design中最常见的效果之一了，在许多著名的应用（如Gmail、Google+等）中，都有滑动菜单的功能。虽说这个功能看上去好像挺复杂的，不过借助谷歌提供的各种工具，我们可以很轻松地实现非常炫酷的滑动菜单效果 DrawerLayout所谓的滑动菜单就是将一些菜单选项隐藏起来，而不是放置在主屏幕上，然后可以通过滑动的方式将菜单显示出来。这种方式既节省了屏幕空间，又实现了非常好的动画效果，是Material Design中推荐的做法。 不过如果我们全靠自己去实现上述功能的话，难度恐怕就很大了。幸运的是，谷歌提供了一个DrawerLayout控件，借助这个控件，实现滑动菜单简单又方便。 用法它是一个布局，在布局中允许放入两个直接子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。 修改activity_main.xml中的代码 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;/FrameLayout&gt; &lt;TextView android:layout_gravity="start" android:layout_width="match_parent" android:layout_height="match_parent" android:text="这是菜单" android:background="#FFF"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 最外层的控件使用了DrawerLayout，这个控件是由support-v4库提供的。DrawerLayout中放置了两个直接子控件，第一个子控件是FrameLayout，用于作为主屏幕中显示的内容，当然里面还有我们刚刚定义的Toolbar。第二个子控件这里使用了一个TextView，用于作为滑动菜单中显示的内容，其实使用什么都可以，DrawerLayout并没有限制只能使用固定的控件。 但是关于第二个子控件有一点需要注意，layout_gravity这个属性是必须指定的，因为我们需要告诉DrawerLayout滑动菜单是在屏幕的左边还是右边，指定left表示滑动菜单在左边，指定right表示滑动菜单在右边。这里我指定了start，表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边。 添加按钮启动滑动菜单书上也是准备了图标的，我这里还是用默认图标，别问为什么，懒得找 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zanecode6574.materialtest;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import android.widget.Toolbar;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout=findViewById(R.id.drawer_layout); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.mipmap.ic_launcher); &#125; &#125;&#125; 首先调用findViewById()方法得到了DrawerLayout的实例，然后调用getSupportActionBar()方法得到了ActionBar的实例，虽然这个ActionBar的具体实现是由Toolbar来完成的。接着调用ActionBar的setDisplayHomeAsUpEnabled()方法让导航按钮显示出来，又调用了setHomeAsUpIndicator()方法来设置一个导航按钮图标。实际上，Toolbar最左侧的这个按钮就叫作HomeAsUp按钮，它默认的图标是一个返回的箭头，含义是返回上一个活动。很明显，这里我们将它默认的样式和作用都进行了修改。 接下来在onOptionsItemSelected()方法中对HomeAsUp按钮的点击事件进行处理，HomeAsUp按钮的id永远都是android.R.id.home。然后调用DrawerLayout的openDrawer()方法将滑动菜单展示出来，注意openDrawer()方法要求传入一个Gravity参数，为了保证这里的行为和XML中定义的一致，我们传入了GravityCompat.START。 NavigationView在滑动菜单页面可以定制任意的布局，不过谷歌给我们提供了一种更好的方法——使用NavigationView。NavigationView是Design Support库中提供的一个控件，它不仅是严格按照Material Design的要求来进行设计的，而且还可以将滑动菜单页面的实现变得非常简单。 添加依赖 12implementation 'com.android.support:design:28.0.0'implementation 'de.hdodenhof:circleimageview:2.1.0' 这里添加了两行依赖关系，第一行就是Design Support库，第二行是一个开源项目CircleImageView，它可以用来轻松实现图片圆形化的功能，我们待会就会用到它。 CircleImageView 的项目主页地址是：https://github.com/hdodenhof/CircleImageView 在开始准备NavigationView之前，需要提前准备好两个东西：menu和headerLayout。menu是用来在NavigationView中显示具体的菜单项的，headerLayout则是用来在NavigationView中显示头部布局的。 图片我直接也用那个默认的，方便 在menu文件夹下创建新的Menu resource file，命名为nav_menu.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_call" android:icon="@mipmap/ic_launcher" android:title="Call"/&gt; &lt;item android:id="@+id/nav_friends" android:icon="@mipmap/ic_launcher" android:title="Friends"/&gt; &lt;item android:id="@+id/nav_location" android:icon="@mipmap/ic_launcher" android:title="Location"/&gt; &lt;item android:id="@+id/nav_mail" android:icon="@mipmap/ic_launcher" android:title="Mail"/&gt; &lt;item android:id="@+id/nav_task" android:icon="@mipmap/ic_launcher" android:title="Tasks"/&gt; &lt;/group&gt;&lt;/menu&gt; 我们首先在&lt;menu&gt;中嵌套了一个&lt;group&gt;标签，然后将group的checkableBehavior属性指定为single。group表示一个组，checkableBehavior指定为single表示组中的所有菜单项只能单选。 那么下面我们来看一下这些菜单项吧。这里一共定义了5个item，分别使用android:id属性指定菜单项的id，android:icon属性指定菜单项的图标，android:title属性指定菜单项显示的文字。就是这么简单，现在我们已经把menu准备好了。 接下来应该准备headerLayout了，这是一个可以随意定制的布局，不过我并不想将它做得太复杂。这里简单起见，我们就在headerLayout中放置头像、用户名、邮箱地址这3项内容吧。这里头像书上用了一张图，我呢，继续用那个默认图标 在layout文件夹新建Layout resource file，名字为nav_header.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="180dp" android:padding="10dp" android:background="?attr/colorPrimary"&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:layout_width="70dp" android:layout_height="70dp" android:id="@+id/icon_image" android:src="@mipmap/ic_launcher" android:layout_centerInParent="true" /&gt; &lt;TextView android:id="@+id/mail" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:text="ZaneCode6574@qq.com" android:textColor="#FFF" android:textSize="14sp"/&gt; &lt;TextView android:id="@+id/username" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_above="@+id/mail" android:text="ZaneCode6574" android:textColor="#FFF" android:textSize="14sp"/&gt;&lt;/RelativeLayout&gt; 布局文件的最外层是一个RelativeLayout，我们将它的宽度设为match_parent，高度设为180dp，这是一个NavigationView比较适合的高度，然后指定它的背景色为colorPrimary。在RelativeLayout中我们放置了3个控件，CircleImageView是一个用于将图片圆形化的控件，它的用法非常简单，基本和ImageView是完全一样的，这里给它指定了一张图片作为头像，然后设置为居中显示。另外两个TextView分别用于显示用户名和邮箱地址 修改activity_main.xml的代码 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;/FrameLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 我们将之前的TextView换成了NavigationView，这样滑动菜单中显示的内容也就变成NavigationView了。这里又通过app:menu和app:headerLayout属性将我们刚才准备好的menu和headerLayout设置了进去，这样NavigationView就定义完成了。 修改MainACtivity设置点击事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.zanecode6574.materialtest;import android.support.annotation.NonNull;import android.support.design.widget.NavigationView;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;import android.widget.Toolbar;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout=findViewById(R.id.drawer_layout); NavigationView navigationView=findViewById(R.id.nav_view); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.mipmap.ic_launcher); &#125; navigationView.setCheckedItem(R.id.nav_call); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125;&#125; 悬浮按钮和可交互提示立面设计是Material Design中一条非常重要的设计思想，也就是说，按照Material Design的理念，应用程序的界面不仅仅只是一个平面，而应该是有立体效果的。在官方给出的示例中，最简单且最具代表性的立面设计就是悬浮按钮了，这种按钮不属于主界面平面的一部分，而是位于另外一个维度的，因此就会给人一种悬浮的感觉。 FloatingActionButtonFloatingActionButton是Design Support库中提供的一个控件，这个控件可以帮助我们比较轻松地实现悬浮按钮的效果。 这里又要准备一张图，我呢，你懂的 修改activity_main.xml的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/ic_launcher" /&gt; &lt;/FrameLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 仔细观察的话，会发现这个悬浮按钮的下面还有一点阴影。其实这很好理解，因为FloatingActionButton是悬浮在当前界面上的，既然是悬浮，那么就理所应当会有投影，Design Support库连这种细节都帮我们考虑到了。说到悬浮，其实我们还可以指定FloatingActionButton的悬浮高度，使用app:elevation=&quot;&quot;属性即可，高度值越大，投影范围也越大，但是投影效果越淡，高度值越小，投影范围也越小，但是投影效果越浓。当然这些效果的差异其实都不怎么明显，我个人感觉使用默认的FloatingActionButton效果就已经足够了 增加点击事件 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.zanecode6574.materialtest;import android.support.annotation.NonNull;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.NavigationView;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;import android.widget.Toolbar;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FloatingActionButton fab=findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了悬浮按钮", Toast.LENGTH_SHORT).show(); &#125; &#125;); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout=findViewById(R.id.drawer_layout); NavigationView navigationView=findViewById(R.id.nav_view); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.mipmap.ic_launcher); &#125; navigationView.setCheckedItem(R.id.nav_call); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125;&#125; SnackbarSnackbar并不是Toast的替代品，它们两者之间有着不同的应用场景。Toast的作用是告诉用户现在发生了什么事情，但同时用户只能被动接收这个事情，因为没有什么办法能让用户进行选择。而Snackbar则在这方面进行了扩展，它允许在提示当中加入一个可交互按钮，当用户点击按钮的时候可以执行一些额外的逻辑操作。打个比方，如果我们在执行删除操作的时候只弹出一个Toast提示，那么用户要是误删了某个重要数据的话肯定会十分抓狂吧，但是如果我们增加一个Undo按钮，就相当于给用户提供了一种弥补措施，从而大大降低了事故发生的概率，提升了用户体验。 Snackbar的用法也非常简单，它和Toast是基本相似的，只不过可以额外增加一个按钮的点击事件。 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.zanecode6574.materialtest;import android.support.annotation.NonNull;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.NavigationView;import android.support.design.widget.Snackbar;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;import android.widget.Toolbar;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FloatingActionButton fab=findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v,"数据已经删除",Snackbar.LENGTH_SHORT).setAction("撤销", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "数据已经恢复", Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); &#125; &#125;); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout=findViewById(R.id.drawer_layout); NavigationView navigationView=findViewById(R.id.nav_view); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.mipmap.ic_launcher); &#125; navigationView.setCheckedItem(R.id.nav_call); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125;&#125; 调用了Snackbar的make()方法来创建一个Snackbar对象，make()方法的第一个参数需要传入一个View，只要是当前界面布局的任意一个View都可以，Snackbar会使用这个View来自动查找最外层的布局，用于展示Snackbar。第二个参数就是Snackbar中显示的内容，第三个参数是Snackbar显示的时长。这些和Toast都是类似的。 接着这里又调用了一个setAction()方法来设置一个动作，从而让Snackbar不仅仅是一个提示，而是可以和用户进行交互的。简单起见，我们在动作按钮的点击事件里面弹出一个Toast提示。最后调用show()方法让Snackbar显示出来。 但是，这个Snakbar弹出来的时候挡住了悬浮按钮,借助CoordinatorLayout可以解决这个问题 CoordinatorLayoutCoordinaLayout可以说是加强版的FrameLayout CoordinatorLayout可以监听其所有子控件的各种事件，然后自动帮助我们做出最为合理的响应。举个简单的例子，刚才弹出的Snackbar提示将悬浮按钮遮挡住了，而如果我们能让CoordinatorLayout监听到Snackbar的弹出事件，那么它会自动将内部的FloatingActionButton向上偏移，从而确保不会被Snackbar遮挡到。 至于CoordinatorLayout的使用也非常简单，我们只需要将原来的FrameLayout替换一下就可以了。 刚才说的是CoordinatorLayout可以监听其所有子控件的各种事件，但是Snackbar好像并不是CoordinatorLayout的子控件吧，为什么它却可以被监听到呢？ 其实道理很简单，还记得我们在Snackbar的make()方法中传入的第一个参数吗？这个参数就是用来指定Snackbar是基于哪个View来触发的，刚才我们传入的是FloatingActionButton本身，而FloatingActionButton是CoordinatorLayout中的子控件，因此这个事件就理所应当能被监听到了。 卡片式布局虽然现在materialTest中已经应用了非常多的Material Design效果，不过你会发现，界面上最主要的一块区域还处于空白状态。这块区域通常都是用来放置应用的主体内容的，我准备使用一些精美的水果图片来填充这部分区域。 那么为了要让水果图片也能material化，本节中我们将会学习如何实现卡片式布局的效果。卡片式布局也是materials Design中提出的一个新的概念，它可以让页面中的元素看起来就像在卡片中一样，并且还能拥有圆角和投影，下面我们就开始具体学习一下。 老规矩，默认图 CardViewCardView是用于实现卡片式布局效果的重要控件，由appcompat-v7库提供。实际上，CardView也是一个FrameLayout，只是额外提供了圆角和阴影等效果，看上去会有立体的感觉。 基本用法 12345678910&lt;android.support.v7．widget.CardView android:layout_width="match_parent" android:layout_height="wrap_content" app:cardCornerRadius="4dp" app:elevation="5dp"&gt; &lt;TextView android:id="@+id/info_text" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/android.support.v7．widget.CardView&gt; 定义了一个CardView布局，我们可以通过app:cardCornerRadius属性指定卡片圆角的弧度，数值越大，圆角的弧度也越大。另外还可以通过app:elevation属性指定卡片的高度，高度值越大，投影范围也越大，但是投影效果越淡，高度值越小，投影范围也越小，但是投影效果越浓，这一点和FloatingActionButton是一致的。 然后我们在CardView布局中放置了一个TextView，那么这个TextView就会显示在一张卡片当中了，CardView的用法就是这么简单。 为了能够充分利用屏幕的空间，这里我准备综合运用一下第3章中学到的知识，使用RecyclerView来填充materialTest项目的主界面部分。 添加依赖 123implementation 'com.android.support:recyclerview-v7:28.0.0'implementation 'com.android.support:cardview-v7:28.0.0'implementation 'com.github.bumptech.glide:glide:3.7.0' 最后一行，这里添加了一个Glide库的依赖。Glide是一个超级强大的图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF图片、甚至是本地视频。最重要的是，Glide的用法非常简单，只需一行代码就能轻松实现复杂的图片加载功能，因此这里我们准备用它来加载水果图片 Glide的项目主页地址是：https://github.com/bumptech/glide 修改activity_main.xml中的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/ic_launcher" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 定义类Fruit 123456789101112131415161718192021222324252627package com.zanecode6574.materialtest;public class Fruit &#123; private String name; private int imageId; public Fruit(String name,int imageId)&#123; this.name=name; this.imageId=imageId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getImageId() &#123; return imageId; &#125; public void setImageId(int imageId) &#123; this.imageId = imageId; &#125;&#125; 为RecyclerView的子项指定一个我们自定义的布局 在layout下新建fruit_item.xml 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v7.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_margin="5dp" app:cardCornerRadius="4dp"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/fruit_image" android:layout_width="match_parent" android:layout_height="100dp" android:scaleType="centerCrop"/&gt; &lt;TextView android:id="@+id/fruit_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_margin="5dp" android:textSize="16sp"/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 使用了CardView来作为子项的最外层布局，从而使得RecyclerView中的每个元素都是在卡片当中的。CardView由于是一个FrameLayout，因此它没有什么方便的定位方式，这里我们只好在CardView中再嵌套一个LinearLayout，然后在LinearLayout中放置具体的内容。 内容倒也没有什么特殊的地方，就是定义了一个ImageView用于显示水果的图片，又定义了一个TextView用于显示水果的名称，并让TextView在水平方向上居中显示。注意在ImageView中我们使用了一个scaleType属性，这个属性可以指定图片的缩放模式。由于各张水果图片的长宽比例可能都不一致，为了让所有的图片都能填充满整个ImageView，这里使用了centerCrop模式，它可以让图片保持原有比例填充满ImageView，并将超出屏幕的部分裁剪掉。 为RecyclerView准备一个适配器 新建FruitAdapter类，让这个适配器继承自RecyclerView.Adapter，指定泛型为FruitAdapter.ViewHolder 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.zanecode6574.materialtest;import android.content.Context;import android.support.annotation.NonNull;import android.support.v7.widget.CardView;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import com.bumptech.glide.Glide;import java.util.List;public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private Context mContext; private List&lt;Fruit&gt; mFruitList; static class ViewHolder extends RecyclerView.ViewHolder&#123; CardView cardView; ImageView fruitImage; TextView fruitName; public ViewHolder(@NonNull View itemView) &#123; super(itemView); cardView=(CardView)itemView; fruitImage=(ImageView)itemView.findViewById(R.id.fruit_image); fruitName=(TextView)itemView.findViewById(R.id.fruit_name); &#125; &#125; public FruitAdapter(List&lt;Fruit&gt; fruitList)&#123; mFruitList=fruitList; &#125; @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; if(mContext==null)&#123; mContext=viewGroup.getContext(); &#125; View view=LayoutInflater.from(mContext).inflate(R.layout.fruit_item,viewGroup,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int i) &#123; Fruit fruit=mFruitList.get(i); viewHolder.fruitName.setText(fruit.getName()); Glide.with(mContext).load(fruit.getImageId()).into(viewHolder.fruitImage); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125;&#125; Glide的用法实在是太简单了。首先调用Glide.with()方法并传入一个Context、Activity或Fragment参数，然后调用load()方法去加载图片，可以是一个URL地址，也可以是一个本地路径，或者是一个资源id，最后调用into()方法将图片设置到具体某一个ImageView中就可以了。 为什么要使用Glide而不是传统的设置图片方式呢？因为这次我从网上找的这些水果图片像素都非常高，如果不进行压缩就直接展示的话，很容易就会引起内存溢出。而使用Glide就完全不需要担心这回事，因为Glide在内部做了许多非常复杂的逻辑操作，其中就包括了图片压缩，我们只需要安心按照Glide的标准用法去加载图片就可以了。 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.zanecode6574.materialtest;import android.support.annotation.NonNull;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.NavigationView;import android.support.design.widget.Snackbar;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;import android.widget.Toolbar;import java.util.ArrayList;import java.util.List;import java.util.Random;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; private Fruit[] fruits=&#123;new Fruit("Apple",R.mipmap.ic_launcher),new Fruit("Banana",R.mipmap.ic_launcher) ,new Fruit("Orange",R.mipmap.ic_launcher),new Fruit("Pear",R.mipmap.ic_launcher) &#125;; private List&lt;Fruit&gt; fruitList=new ArrayList&lt;&gt;(); private FruitAdapter adapter; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); RecyclerView recyclerView=findViewById(R.id.recycler_view); GridLayoutManager layoutManager=new GridLayoutManager(this,2); recyclerView.setLayoutManager(layoutManager); adapter=new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); FloatingActionButton fab=findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v,"数据已经删除",Snackbar.LENGTH_SHORT).setAction("撤销", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "数据已经恢复", Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); &#125; &#125;); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout=findViewById(R.id.drawer_layout); NavigationView navigationView=findViewById(R.id.nav_view); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.mipmap.ic_launcher); &#125; navigationView.setCheckedItem(R.id.nav_call); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125; private void initFruits()&#123; fruitList.clear(); for(int i=0;i&lt;50;i++)&#123; Random random=new Random(); int index=random.nextInt(fruits.length); fruitList.add(fruits[index]); &#125; &#125;&#125; 在MainActivity中我们首先定义了一个数组，数组里面存放了很多个Fruit的实例，每个实例都代表着一种水果。然后在initFruits()方法中，先是清空了一下fruitList中的数据，接着使用一个随机函数，从刚才定义的Fruit数组中随机挑选一个水果放入到fruitList当中，这样每次打开程序看到的水果数据都会是不同的。另外，为了让界面上的数据多一些，这里使用了一个循环，随机挑选50个水果。 之后的用法就是RecyclerView的标准用法了，不过这里使用了GridLayoutManager这种布局方式。在第3章中我们已经学过了LinearLayoutManager和StaggeredGridLayoutManager，现在终于将所有的布局方式都补齐了。GridLayoutManager的用法也没有什么特别之处，它的构造函数接收两个参数，第一个是Context，第二个是列数，这里我们希望每一行中会有两列数据。 但是，现在Toolbar被挡住了，我们需要用AppBarLayout来解决 AppBarLayout由于RecyclerView和Toolbar都是放置在CoordinatorLayout中的，而前面已经说过，CoordinatorLayout就是一个加强版的FrameLayout，那么FrameLayout中的所有控件在不进行明确定位的情况下，默认都会摆放在布局的左上角，从而也就产生了遮挡的现象。 使用Design Support库中提供的另外一个工具——AppBarLayout。AppBarLayout实际上是一个垂直方向的LinearLayout，它在内部做了很多滚动事件的封装，并应用了一些Material Design的设计理念。 将Toolbar嵌套到AppBarLayout中 给RecyclerView指定一个布局行为 修改activity_main.xml中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/ic_launcher" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 刚才有提到过，说AppBarLayout中应用了一些Material Design的设计理念，好像从上面的例子完全体现不出来呀。事实上，当RecyclerView滚动的时候就已经将滚动事件都通知给AppBarLayout了，只是我们还没进行处理而已。那么下面就让我们来进一步优化，看看AppBarLayout到底能实现什么样的Material Design效果。 当AppBarLayout接收到滚动事件的时候，它内部的子控件其实是可以指定如何去影响这些事件的，通过app:layout_scrollFlags属性就能实现 修改activity_main.xml中的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:layout_scrollFlags="scroll|enterAlways|snap" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/ic_launcher" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 在Toolbar中添加了一个app:layout_scrollFlags属性，并将这个属性的值指定成了scroll|enterAlways|snap。其中，scroll表示当RecyclerView向上滚动的时候，Toolbar会跟着一起向上滚动并实现隐藏；enterAlways表示当RecyclerView向下滚动的时候，Toolbar会跟着一起向下滚动并重新显示。snap表示当Toolbar还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示。 下拉刷新谷歌为了让Android的下拉刷新风格能有一个统一的标准，于是在Material Design中制定了一个官方的设计规范。当然，我们并不需要去深入了解这个规范到底是什么样的，因为谷歌早就提供好了现成的控件，我们只需要在项目中直接使用就可以了。 SwipeRefreshLayout就是用于实现下拉刷新功能的核心类，它是由support-v4库提供的。我们把想要实现下拉刷新功能的控件放置到SwipeRefreshLayout中，就可以迅速让这个控件支持下拉刷新。那么在materialTest项目中，应该支持下拉刷新功能的控件自然就是RecyclerView了。 修改acitivty_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:layout_scrollFlags="scroll|enterAlways|snap" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@mipmap/ic_launcher" /&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id="@+id/swipe_refresh" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="start" app:menu="@menu/nav_menu" app:headerLayout="@layout/nav_header"&gt; &lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 这里我们在RecyclerView的外面又嵌套了一层SwipeRefreshLayout，这样RecyclerView就自动拥有下拉刷新功能了。另外需要注意，由于RecyclerView现在变成了SwipeRefreshLayout的子控件，因此之前使用app:layout_behavior声明的布局行为现在也要移到SwipeRefreshLayout中才行。 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.zanecode6574.materialtest;import android.support.annotation.NonNull;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.NavigationView;import android.support.design.widget.Snackbar;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v4.widget.SwipeRefreshLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;import android.widget.Toolbar;import java.util.ArrayList;import java.util.List;import java.util.Random;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; private SwipeRefreshLayout swipeRefreshLayout; private Fruit[] fruits=&#123;new Fruit("Apple",R.mipmap.ic_launcher),new Fruit("Banana",R.mipmap.ic_launcher) ,new Fruit("Orange",R.mipmap.ic_launcher),new Fruit("Pear",R.mipmap.ic_launcher) &#125;; private List&lt;Fruit&gt; fruitList=new ArrayList&lt;&gt;(); private FruitAdapter adapter; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case R.id.backup: Toast.makeText(this, "选中了backup按钮", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "选中delete按钮", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "选中了Settings按钮", Toast.LENGTH_SHORT).show(); break; case android.R.id.home: mDrawerLayout.openDrawer(GravityCompat.START); default: break; &#125; return true; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); swipeRefreshLayout=findViewById(R.id.swipe_refresh); swipeRefreshLayout.setColorSchemeResources(R.color.colorPrimary); swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; refreshFruits(); &#125; &#125;); initFruits(); RecyclerView recyclerView=findViewById(R.id.recycler_view); GridLayoutManager layoutManager=new GridLayoutManager(this,2); recyclerView.setLayoutManager(layoutManager); adapter=new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); FloatingActionButton fab=findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(v,"数据已经删除",Snackbar.LENGTH_SHORT).setAction("撤销", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "数据已经恢复", Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); &#125; &#125;); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); setSupportActionBar(toolbar); mDrawerLayout=findViewById(R.id.drawer_layout); NavigationView navigationView=findViewById(R.id.nav_view); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); actionBar.setHomeAsUpIndicator(R.mipmap.ic_launcher); &#125; navigationView.setCheckedItem(R.id.nav_call); navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem menuItem) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); &#125; private void initFruits()&#123; fruitList.clear(); for(int i=0;i&lt;50;i++)&#123; Random random=new Random(); int index=random.nextInt(fruits.length); fruitList.add(fruits[index]); &#125; &#125; private void refreshFruits()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; Thread.sleep(2000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; initFruits(); adapter.notifyDataSetChanged(); swipeRefreshLayout.setRefreshing(false); &#125; &#125;); &#125; &#125;).start(); &#125;&#125; 首先通过findViewById()方法拿到SwipeRefreshLayout的实例，然后调用setColorSchemeResources()方法来设置下拉刷新进度条的颜色，这里我们就使用主题中的colorPrimary作为进度条的颜色了。 接着调用setOnRefreshListener()方法来设置一个下拉刷新的监听器，当触发了下拉刷新操作的时候就会回调这个监听器的onRefresh()方法，然后我们在这里去处理具体的刷新逻辑就可以了。 通常情况下，onRefresh()方法中应该是去网络上请求最新的数据，然后再将这些数据展示出来。这里简单起见，我们就不和网络进行交互了，而是调用一个refreshFruits()方法进行本地刷新操作。refreshFruits()方法中先是开启了一个线程，然后将线程沉睡两秒钟。之所以这么做，是因为本地刷新操作速度非常快，如果不将线程沉睡的话，刷新立刻就结束了，从而看不到刷新的过程。 沉睡结束之后，这里使用了runOnUiThread()方法将线程切换回主线程，然后调用initFruits()方法重新生成数据，接着再调用FruitAdapter的notifyDataSetChanged()方法通知数据发生了变化，最后调用SwipeRefreshLayout的setRefreshing()方法并传入false，用于表示刷新事件结束，并隐藏刷新进度条。 可折叠式标题栏虽说我们现在的标题栏是使用Toolbar来编写的，不过它看上去和传统的ActionBar其实没什么两样，只不过可以响应RecyclerView的滚动事件来进行隐藏和显示。而Material Design中并没有限定标题栏必须是长这个样子的，事实上，我们可以根据自己的喜好随意定制标题栏的样式。那么本节中我们就来实现一个可折叠式标题栏的效果，需要借助CollapsingToolbarLayout这个工具。 CollapsingToolbarLayoutCollapsingToolbarLayout是一个作用于Toolbar基础之上的布局，它也是由Design Support库提供的。CollapsingToolbarLayout可以让Toolbar的效果变得更加丰富，不仅仅是展示一个标题栏，而是能够实现非常华丽的效果。 CollapsingToolbarLayout是不能独立存在的，它在设计的时候就被限定只能作为AppBarLayout的直接子布局来使用。而AppBarLayout又必须是CoordinatorLayout的子布局。 新建活动作为水果的详情展示界面,命名为FruitActivity 编辑activity_fruit.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/fruit_image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" app:layout_collapseMode="parallax"/&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 在新的布局中android:theme属性指定了一个ThemeOverlay.AppCompat.Dark.ActionBar的主题，其实对于这部分我们也并不陌生，因为之前在activity_main.xml中给Toolbar指定的也是这个主题，只不过这里要实现更加高级的Toolbar效果，因此需要将这个主题的指定提到上一层来。 app:contentScrim属性用于指定CollapsingToolbarLayout在趋于折叠状态以及折叠之后的背景色，其实CollapsingToolbarLayout在折叠之后就是一个普通的Toolbar，那么背景色肯定应该是colorPrimary了，具体的效果我们待会儿就能看到。 app:layout_scrollFlags属性我们也是见过的，只不过之前是给Toolbar指定的，现在也移到外面来了。其中，scroll表示CollapsingToolbarLayout会随着水果内容详情的滚动一起滚动，exitUntilCollapsed表示当CollapsingToolbarLayout随着滚动完成折叠之后就保留在界面上，不再移出屏幕。 在CollapsingToolbarLayout中定义了一个ImageView和一个Toolbar，也就意味着，这个高级版的标题栏将是由普通的标题栏加上图片组合而成的。这里定义的大多数属性我们都是见过的，就不再解释了，只有一个app:layout_collapseMode比较陌生。它用于指定当前控件在CollapsingToolbarLayout折叠过程中的折叠模式，其中Toolbar指定成pin，表示在折叠的过程中位置始终保持不变，ImageView指定成parallax，表示会在折叠的过程中产生一定的错位偏移，这种模式的视觉效果会非常好。 水果内容详情的最外层布局使用了一个NestedScrollView，注意它和AppBarLayout是平级的。我们之前在9.2.1小节学过ScrollView的用法，它允许使用滚动的方式来查看屏幕以外的数据，而NestedScrollView在此基础之上还增加了嵌套响应滚动事件的功能。由于CoordinatorLayout本身已经可以响应滚动事件了，因此我们在它的内部就需要使用NestedScrollView或RecyclerView这样的布局。另外，这里还通过app:layout_behavior属性指定了一个布局行为，这和之前在RecyclerView中的用法是一模一样的。 不管是ScrollView还是NestedScrollView，它们的内部都只允许存在一个直接子布局。因此，如果我们想要在里面放入很多东西的话，通常都会先嵌套一个LinearLayout，然后再在LinearLayout中放入具体的内容 水果详情页编写完了以后，还可以在界面上添加一个悬浮按钮，加入的话我们会活得一些额外的动画效果，这里举例加入一个表示评论的按钮 这里加入了一个FloatingActionButton，它和AppBarLayout以及NestedScrollView是平级的。FloatingActionButton中使用app:layout_anchor属性指定了一个锚点，我们将锚点设置为AppBarLayout，这样悬浮按钮就会出现在水果标题栏的区域内，接着又使用app:layout_anchorGravity属性将悬浮按钮定位在标题栏区域的右下角。其他一些属性都比较简单，就不再进行解释了。 修改FruitActivity中的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zanecode6574.materialtest;import android.content.Intent;import android.support.design.widget.CollapsingToolbarLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.MenuItem;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toolbar;import com.bumptech.glide.Glide;public class FruitActivity extends AppCompatActivity &#123; public static final String FRUIT_NAME="fruit_name"; public static final String FRUIT_IMAGE_ID="fruit_image_id"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_fruit); Intent intent=getIntent(); String fruitName=intent.getStringExtra(FRUIT_NAME); int fruitImageId=intent.getIntExtra(FRUIT_IMAGE_ID,0); android.support.v7.widget.Toolbar toolbar=findViewById(R.id.toolbar); CollapsingToolbarLayout collapsingToolbarLayout=findViewById(R.id.collapsing_toolbar); ImageView fruitImageView=findViewById(R.id.fruit_image_view); TextView fruitContentText=findViewById(R.id.fruit_content_text); setSupportActionBar(toolbar); ActionBar actionBar=getSupportActionBar(); if(actionBar!=null)&#123; actionBar.setDisplayHomeAsUpEnabled(true); &#125; collapsingToolbarLayout.setTitle(fruitName); Glide.with(this).load(fruitImageId).into(fruitImageView); String fruitContent=generateFruitContent(fruitName); fruitContentText.setText(fruitContent); &#125; private String generateFruitContent(String fruitName)&#123; StringBuilder fruitContent=new StringBuilder(); for(int i=0;i&lt;100;i++)&#123; fruitContent.append(fruitName); &#125; return fruitContent.toString(); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch(item.getItemId())&#123; case android.R.id.home: finish(); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; FruitActivity中的代码并不是很复杂。首先，在onCreate()方法中，我们通过Intent获取到传入的水果名和水果图片的资源id，然后通过findViewById()方法拿到刚才在布局文件中定义的各个控件的实例。接着就是使用了Toolbar的标准用法，将它作为ActionBar显示，并启用HomeAsUp按钮。由于HomeAsUp按钮的默认图标就是一个返回箭头，这正是我们所期望的，因此就不用再额外设置别的图标了。 接下来开始填充界面上的内容，调用CollapsingToolbarLayout的setTitle()方法将水果名设置成当前界面的标题，然后使用Glide加载传入的水果图片，并设置到标题栏的ImageView上面。接着需要填充水果的内容详情，由于这只是一个示例程序，并不需要什么真实的数据，所以我使用了一个generateFruitContent()方法将水果名循环拼接500次，从而生成了一个比较长的字符串，将它设置到了TextView上面。 最后，我们在onOptionsItemSelected()方法中处理了HomeAsUp按钮的点击事件，当点击了这个按钮时，就调用finish()方法关闭当前的活动，从而返回上一个活动。 修改FruitAdapter的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zanecode6574.materialtest;import android.content.Context;import android.content.Intent;import android.support.annotation.NonNull;import android.support.v7.widget.CardView;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import com.bumptech.glide.Glide;import java.util.List;public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; &#123; private Context mContext; private List&lt;Fruit&gt; mFruitList; static class ViewHolder extends RecyclerView.ViewHolder&#123; CardView cardView; ImageView fruitImage; TextView fruitName; public ViewHolder(@NonNull View itemView) &#123; super(itemView); cardView=(CardView)itemView; fruitImage=itemView.findViewById(R.id.fruit_image); fruitName=itemView.findViewById(R.id.fruit_name); &#125; &#125; public FruitAdapter(List&lt;Fruit&gt; fruitList)&#123; mFruitList=fruitList; &#125; @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; if(mContext==null)&#123; mContext=viewGroup.getContext(); &#125; View view=LayoutInflater.from(mContext).inflate(R.layout.fruit_item,viewGroup,false); final ViewHolder holder=new ViewHolder(view); holder.cardView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position=holder.getAdapterPosition(); Fruit fruit=mFruitList.get(position); Intent intent=new Intent(mContext,FruitActivity.class); intent.putExtra(FruitActivity.FRUIT_NAME,fruit.getName()); intent.putExtra(FruitActivity.FRUIT_IMAGE_ID,fruit.getImageId()); mContext.startActivity(intent); &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(@NonNull ViewHolder viewHolder, int i) &#123; Fruit fruit=mFruitList.get(i); viewHolder.fruitName.setText(fruit.getName()); Glide.with(mContext).load(fruit.getImageId()).into(viewHolder.fruitImage); &#125; @Override public int getItemCount() &#123; return mFruitList.size(); &#125;&#125; 充分利用状态栏空间Android 5.0系统之前，我们是无法对状态栏的背景或颜色进行操作的，那个时候也还没有Material Design的概念。但是Android 5.0及之后的系统都是支持这个功能的，因此这里我们就来实现一个系统差异型的效果，在Android 5.0及之后的系统中，使用背景图和状态栏融合的模式，在之前的系统中使用普通的模式。 想要让背景图能够和系统状态栏融合，需要借助android:fitsSystemWindows这个属性来实现。在CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout这种嵌套结构的布局中，将控件的android:fitsSystemWindows属性指定成true，就表示该控件会出现在系统状态栏里。对应到我们的程序，那就是水果标题栏中的ImageView应该设置这个属性了。不过只给ImageView设置这个属性是没有用的，我们必须将ImageView布局结构中的所有父布局都设置上这个属性才可以 修改activity_fruit.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appBar" android:layout_width="match_parent" android:layout_height="250dp" android:fitsSystemWindows="true"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:contentScrim="?attr/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed" android:fitsSystemWindows="true"&gt; &lt;ImageView android:id="@+id/fruit_image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" app:layout_collapseMode="parallax" android:fitsSystemWindows="true"/&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior" &gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.CardView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="15dp" android:layout_marginLeft="15dp" android:layout_marginRight="15dp" android:layout_marginTop="35dp" app:cardCornerRadius="4dp"&gt; &lt;TextView android:id="@+id/fruit_content_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="10dp"/&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_margin="16dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" app:layout_anchor="@id/appBar" app:layout_anchorGravity="bottom|end" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 即使我们将android:fitsSystemWindows属性都设置好了还是没有用的，因为还必须在程序的主题中将状态栏颜色指定成透明色才行。指定成透明色的方法很简单，在主题中将android:statusBarColor属性的值指定成@android:color/transparent就可以了。但问题在于，android:statusBarColor这个属性是从API 21，也就是Android 5.0系统开始才有的，之前的系统无法指定这个属性。那么，系统差异型的功能实现就要从这里开始了。 在res文件夹新建目录values-v21,新建一个Values resource file，名字为styles.xml 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;style name="FruitActivityTheme" parent="AppTheme"&gt; &lt;item name="android:statusBarColor"&gt; @android:color/transparent &lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 这里我们定义了一个FruitActivityTheme主题，它是专门给FruitActivity使用的。FruitActivityTheme的parent主题是AppTheme，也就是说，它继承了AppTheme中的所有特性。然后我们在FruitActivityTheme中将状态栏的颜色指定成透明色，由于values-v21目录是只有Android 5.0及以上的系统才会去读取的，因此这么声明是没有问题的。 由于安卓5.0一下的系统无法识别，因此还需要对values/styles.xml文件进行修改 1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="FruitActivityTheme." parent="AppTheme"&gt; &lt;/style&gt;&lt;/resources&gt; 修改AndroidManifest.xml中的代码 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.zanecode6574.materialtest"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity" android:label="测试material"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".FruitActivity" android:theme="@style/FruitActivityTheme"&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
        <tag>界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章：基于位置的服务]]></title>
    <url>%2F2019%2F01%2F26%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[说到只有在移动设备上才能实现的技术，很容易就让人联想到基于位置的服务（Location Based Service）。由于移动设备相比于电脑可以随身携带，我们通过地理定位的技术就可以随时得知自己所在的位置，从而围绕这一点开发出很多有意思的应用。 简介基于位置的服务简称LBS，随着移动互联网的兴起，这个技术在最近的几年里十分火爆。其实它本身并不是什么时髦的技术，主要的工作原理就是利用无线电通讯网络或GPS等定位方式来确定出移动设备所在的位置，而这种定位技术早在很多年前就已经出现了。 那为什么LBS技术直到最近几年才开始流行呢？这主要是因为，在过去移动设备的功能极其有限，即使定位到了设备所在的位置，也就仅仅只是定位到了而已，我们并不能在位置的基础上进行一些其他的操作。而现在就大大不同了，有了Android系统作为载体，我们可以利用定位出的位置进行许多丰富多彩的操作。比如说天气预报程序可以根据用户所在的位置自动选择城市，发微博的时候我们可以向朋友们晒一下自己在哪里，不认识路的时候随时打开地图就可以查询路线，等等。 基于位置的服务所围绕的核心就是要先确定出用户所在的位置。通常有两种技术方式可以实现：一种是通过GPS定位，一种是通过网络定位。GPS定位的工作原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种定位方式精确度非常高，但缺点是只能在室外使用，室内基本无法接收到卫星的信号。网络定位的工作原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，这种定位方式精确度一般，但优点是在室内室外都可以使用。 Android对这两种定位方式都提供了相应的API支持，但是由于一些特殊原因，Google的网络服务在中国不可访问，从而导致网络定位方式的API失效。而GPS定位虽然不需要网络，但是必须要在室外才可以使用，因此你在室内开发的时候很有可能会遇到不管使用哪种定位方式都无法成功定位的情况。 基于以上原因，我决定就不在本书中讲解Android原生定位API的用法了，而是使用一些国内第三方公司的SDK。目前国内在这一领域做得比较好的一个是百度，一个是高德。 下面是学习百度在LBS方面提供的功能。 申请API Key想在自己的应用程序里使用百度的LBS功能，首先必须申请一个API Key 打开http://lbsyun.baidu.com/进行注册 点击创建应用去申请API Key,类型选择Android SDK 发布版SHA1和开发版SHA1是我们申请API Key所必须填写的一个字段，它指的是打包程序时所用签名文件的SHA1指纹，可以通过Android Studio查看到 打开Android Studio中的任意一个项目，点击右侧工具栏的Gradle→项目名→:app→Tasks→ android，这里展示了一个Android Studio项目中所有内置的Gradle Tasks，其中signingReport这个Task就可以用来查看签名文件信息。 双击signingReport就会看到sha1的值 目前我们使用的是debug.keystore文件所生成的指纹，这是Android自动生成的一个用于测试的签名文件。而当你的应用程序发布时还需要创建一个正式的签名文件，如果要得到它的指纹，可以在cmd中输入如下命令：keytool -list -v –keystore &lt;签名文件路径&gt;,然后输入正确的密码就可以了。创建签名文件的方法我们将在第15章中学习。 现在得到的这个SHA1指纹实际上是一个开发版的SHA1指纹，不过因为暂时我们还没有一个发布版的SHA1指纹，因此这两个值都填成一样的就可以了。 包名选项由于现在我们的应用还不存在，暂时预定一个即可 最后提交即可 使用百度定位配置LBS Sdk 新建一个LBSTest项目，包名指定为刚才自己写的那个 下载百度LBS开放平台的SDK，这里地址跟书上不同了，自己找找吧 下载的文件libs目录下的内容又分为两部分，BaiduLBS_Android.jar这个文件是Java层要使用到的，其他子目录下的so文件是Native层要用到的。so文件是用C/C++语言进行编写，然后再用NDK编译出来的。当然这里我们并不需要去编写C/C++的代码，因为百度都已经做好了封装，但是我们需要将libs目录下的每一个文件都放置到正确的位置。 将BaiduLBS_Android.jar添加到项目的app/libs文件夹下 展开src/main目录，新建一个jniLibs目录，然后把压缩包内剩下的所有放到这个目录中 虽然所有新创建的项目中，app/build.gradle文件都会默认配置以下这段声明： 1234dependencies &#123;compile fileTree(dir: 'libs', include: ['*.jar'])...&#125; 这表示会将libs目录下所有以.jar结尾的文件添加到当前项目的引用中。但是由于我们是直接将Jar包复制到libs目录下的，并没有修改gradle文件，因此不会弹出我们平时熟悉的Sync Now提示。这个时候必须手动点击一下Android Studio顶部工具栏中的Sync按钮。 确定自己的经纬度 修改activity_main.xml的代码 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:id="@+id/position_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 修改AndroidManifest中的代码 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" package="com.zanecode6574.lbstest"&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="EZI9oQzACy3CCAGVFoI7yWqmz9f2F1Zw"/&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name="com.baidu.location.f" android:enabled="true" android:process=":remote"/&gt; &lt;/application&gt;&lt;/manifest&gt; 首先添加了很多行权限声明，每一个权限都是百度LBS SDK内部要用到的。然后在标签的内部添加了一个标签，这个标签的android:name部分是固定的，必须填com.baidu.lbsapi.API_KEY，android:value部分则应该填入我们在11.2节申请到的API Key。最后，还需要再注册一个LBS SDK中的服务，不用对这个服务的名字感到疑惑，因为百度LBS SDK中的代码都是混淆过的。 这里申请了一堆权限，然后又两个提示权限只会授予系统应用，可能是版本问题 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.zanecode6574.lbstest;import android.Manifest;import android.content.pm.PackageManager;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import com.baidu.location.BDLocation;import com.baidu.location.BDLocationListener;import com.baidu.location.LocationClient;import com.baidu.mapapi.map.BaiduMap;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLocationClient =new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); positionText=findViewById(R.id.position_text_view); List&lt;String&gt; permissionList=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.READ_PHONE_STATE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if(!permissionList.isEmpty())&#123; String[] permissions=permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; requestLocation(); &#125; &#125; private void requestLocation()&#123; mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(this, "必须同意所有权限才能使用应用", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125;else&#123; Toast.makeText(this, "发生未知错误!", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(final BDLocation bdLocation) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; StringBuilder currentPosition=new StringBuilder(); currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("线：").append(bdLocation.getLongitude()).append("\n"); currentPosition.append("定位方式"); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); &#125; &#125;); &#125; &#125;&#125; 在onCreate()方法中，我们首先创建了一个LocationClient的实例，LocationClient的构建函数接收一个Context参数，这里调用getApplicationContext()方法来获取一个全局的Context参数并传入。 然后调用LocationClient的registerLocationListener()方法来注册一个定位监听器，当获取到位置信息的时候，就会回调这个定位监听器。 接下来看一下这里运行时权限的用法，由于我们在AndroidManifest.xml中声明了很多权限，参考一下7.2.1小节中的危险权限表格可以发现，其中ACCESS_COARSE_LOCATION、ACCESS_FINE_LOCATION、READ_PHONE_STATE、WRITE_EXTERNAL_STORAGE这4个权限是需要进行运行时权限处理的，不过由于ACCESS_COARSE_LOCATION和ACCESS_FINE_LOCATION都属于同一个权限组，因此两者只要申请其一就可以了。 一次性申请3个权限：这里我们使用了一种新的用法，首先创建一个空的List集合，然后依次判断这3个权限有没有被授权，如果没被授权就添加到List集合中，最后将List转换成数组，再调用ActivityCompat.requestPermissions()方法一次性申请。 除此之外，onRequestPermissionsResult()方法中对权限申请结果的逻辑处理也和之前有所不同，这次我们通过一个循环将申请的每个权限都进行了判断，如果有任何一个权限被拒绝，那么就直接调用finish()方法关闭当前程序，只有当所有权限都被用户同意了，才会调用requestLocation()方法开始地理位置定位。 requestLocation()方法中的代码比较简单，只是调用了一下LocationClient的start()方法就能开始定位了。定位的结果会回调到我们前面注册的监听器当中，也就是MyLocationListener。 观察一下MyLocationListener的onReceiveLocation()方法中，在这里我们通过BDLocation的getLatitude()方法获取当前位置的纬度，通过getLongitude()方法获取当前位置的经度，通过getLocType()方法获取当前的定位方式，最终将结果组装成一个字符串，显示到TextView上面。 定位多次 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.zanecode6574.lbstest;import android.Manifest;import android.content.pm.PackageManager;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import com.baidu.location.BDLocation;import com.baidu.location.BDLocationListener;import com.baidu.location.LocationClient;import com.baidu.location.LocationClientOption;import com.baidu.mapapi.map.BaiduMap;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLocationClient =new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); positionText=findViewById(R.id.position_text_view); List&lt;String&gt; permissionList=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.READ_PHONE_STATE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if(!permissionList.isEmpty())&#123; String[] permissions=permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; requestLocation(); &#125; &#125; private void requestLocation()&#123; initLocation(); mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(this, "必须同意所有权限才能使用应用", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125;else&#123; Toast.makeText(this, "发生未知错误!", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; private void initLocation()&#123; LocationClientOption option=new LocationClientOption(); option.setScanSpan(5000); mLocationClient.setLocOption(option); &#125; public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(final BDLocation bdLocation) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; StringBuilder currentPosition=new StringBuilder(); currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("线：").append(bdLocation.getLongitude()).append("\n"); currentPosition.append("国家:").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道").append(bdLocation.getStreet()).append("\n"); currentPosition.append("定位方式"); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); &#125; &#125;); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); &#125;&#125; 增加了一个initLocation()方法，在initLocation()方法中我们创建了一个LocationClientOption对象，然后调用它的setScanSpan()方法来设置更新的间隔。这里传入了5000，表示每5秒钟会更新一下当前的位置。最后要记得，在活动被销毁的时候一定要调用LocationClient的stop()方法来停止定位，不然程序会持续在后台不停地进行定位，从而严重消耗手机的电量。 选择定位模式之前的代码都会发现定位方式是网络，可以在手机相应设置中修改，也可以在App中强制使用GPS定位 修改MainActivity中的代码,在initLocation函数中增加option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); 看得懂的位置信息百度提供了接口能获得当前位置各种信息 修改MainActivity中的代码,在initLocation函数中增加option.setIsNeedAddress(true); 使用百度地图让地图显示出来 修改activity_main.xml的代码 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;TextView android:id="@+id/position_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;com.baidu.mapapi.map.MapView android:id="@+id/bmapView" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true" /&gt;&lt;/LinearLayout&gt; 修改MainACtivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.zanecode6574.lbstest;import android.Manifest;import android.content.pm.PackageManager;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import com.baidu.location.BDLocation;import com.baidu.location.BDLocationListener;import com.baidu.location.LocationClient;import com.baidu.location.LocationClientOption;import com.baidu.mapapi.SDKInitializer;import com.baidu.mapapi.map.BaiduMap;import com.baidu.mapapi.map.MapView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; private MapView mapView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient =new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mapView=findViewById(R.id.bmapView); positionText=findViewById(R.id.position_text_view); List&lt;String&gt; permissionList=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.READ_PHONE_STATE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if(!permissionList.isEmpty())&#123; String[] permissions=permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; requestLocation(); &#125; &#125; private void requestLocation()&#123; initLocation(); mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(this, "必须同意所有权限才能使用应用", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125;else&#123; Toast.makeText(this, "发生未知错误!", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; private void initLocation()&#123; LocationClientOption option=new LocationClientOption(); option.setScanSpan(1000); option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(final BDLocation bdLocation) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; StringBuilder currentPosition=new StringBuilder(); currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("线：").append(bdLocation.getLongitude()).append("\n"); currentPosition.append("国家:").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道").append(bdLocation.getStreet()).append("\n"); currentPosition.append("定位方式"); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); &#125; &#125;); &#125; &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); &#125;&#125; 首先需要调用SDKInitializer的initialize()方法来进行初始化操作，initialize()方法接收一个Context参数，这里我们调用getApplicationContext()方法来获取一个全局的Context参数并传入。 注意初始化操作一定要在setContentView()方法前调用，不然的话就会出错。接下来我们调用findViewById()方法获取到了MapView的实例，这个实例在后面的功能当中还会用到。 另外还需要重写onResume()、onPause()和onDestroy()这3个方法，在这里对MapView进行管理，以保证资源能够及时地得到释放。 移动到我的位置 百度LBS SDK的API中提供了一个BaiduMap类，它是地图的总控制器，调用MapView的getMap()方法就能获取到BaiduMap的实例，如下所示：BaiduMap baiduMap = mapView.getMap(); 有了BaiduMap后，我们就能对地图进行各种各样的操作了，比如设置地图的缩放级别以及将地图移动到某一个经纬度上。百度地图将缩放级别的取值范围限定在3到19之间，其中小数点位的值也是可以取的，值越大，地图显示的信息就越精细。比如我们想要将缩放级别设置成12.5，就可以这样写： 12MapStatusUpdate update = MapStatusUpdateFactory.zoomTo(12.5f);baiduMap.animateMapStatus(update); 其中MapStatusUpdateFactory的zoomTo()方法接收一个float型的参数，就是用于设置缩放级别的，这里我们传入12.5f。zoomTo()方法返回一个MapStatusUpdate对象，我们把这个对象传入BaiduMap的animateMapStatus()方法当中即可完成缩放功能。 那么怎样才能让地图移动到某一个经纬度上呢？这就需要借助LatLng类了。其实LatLng并没有什么太多的用法，主要就是用于存放经纬度值的，它的构造方法接收两个参数，第一个参数是纬度值，第二个参数是经度值。之后调用MapStatusUpdateFactory的newLatLng()方法将LatLng对象传入，newLatLng()方法返回的也是一个MapStatusUpdate对象，我们再把这个对象传入BaiduMap的animateMapStatus()方法当中，就可以将地图移动到指定的经纬度上了，写法如下： 123LatLng ll = new LatLng(39.915, 116.404);MapStatusUpdate update = MapStatusUpdateFactory.newLatLng(ll);baiduMap.animateMapStatus(update); 上述代码就实现了将地图移动到北纬39.915度、东经116.404度这个位置的功能。 修改MainActivity的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package com.zanecode6574.lbstest;import android.Manifest;import android.content.pm.PackageManager;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import com.baidu.location.BDLocation;import com.baidu.location.BDLocationListener;import com.baidu.location.LocationClient;import com.baidu.location.LocationClientOption;import com.baidu.mapapi.SDKInitializer;import com.baidu.mapapi.map.BaiduMap;import com.baidu.mapapi.map.MapStatusUpdate;import com.baidu.mapapi.map.MapStatusUpdateFactory;import com.baidu.mapapi.map.MapView;import com.baidu.mapapi.model.LatLng;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; private MapView mapView; private BaiduMap baiduMap; private boolean isFirstLocate=true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient =new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mapView=findViewById(R.id.bmapView); baiduMap=mapView.getMap(); positionText=findViewById(R.id.position_text_view); List&lt;String&gt; permissionList=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.READ_PHONE_STATE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if(!permissionList.isEmpty())&#123; String[] permissions=permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; requestLocation(); &#125; &#125; private void requestLocation()&#123; initLocation(); mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(this, "必须同意所有权限才能使用应用", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125;else&#123; Toast.makeText(this, "发生未知错误!", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; private void navigateTo(BDLocation location)&#123; if(isFirstLocate)&#123; LatLng ll=new LatLng(location.getLatitude(),location.getLongitude()); MapStatusUpdate update=MapStatusUpdateFactory.newLatLng(ll); baiduMap.animateMapStatus(update); update=MapStatusUpdateFactory.zoomTo(20f); baiduMap.animateMapStatus(update); isFirstLocate=false; &#125; &#125; private void initLocation()&#123; LocationClientOption option=new LocationClientOption(); option.setScanSpan(1000); option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(final BDLocation bdLocation) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; StringBuilder currentPosition=new StringBuilder(); currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("线：").append(bdLocation.getLongitude()).append("\n"); currentPosition.append("国家:").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道").append(bdLocation.getStreet()).append("\n"); currentPosition.append("定位方式"); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); &#125; &#125;); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation || bdLocation.getLocType() ==BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; &#125; &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); &#125;&#125; 主要是加入了一个navigateTo()方法。这个方法中的代码也很好理解，先是将BDLocation对象中的地理位置信息取出并封装到LatLng对象中，然后调用MapStatusUpdateFactory的newLatLng()方法并将LatLng对象传入，接着将返回的MapStatusUpdate对象作为参数传入到BaiduMap的animateMapStatus()方法当中，和上面介绍的用法是一模一样的。并且这里为了让地图信息可以显示得更加丰富一些，我们将缩放级别设置成了16。另外还有一点需要注意，上述代码当中我们使用了一个isFirstLocate变量，这个变量的作用是为了防止多次调用animateMapStatus()方法，因为将地图移动到我们当前的位置只需要在程序第一次定位的时候调用一次就可以了。 写好了navigateTo()方法之后，剩下的事情就简单了，当定位到设备当前位置的时候，我们在onReceiveLocation()方法中直接把BDLocation对象传给navigateTo()方法，这样就能够让地图移动到设备所在的位置了。 让自己显示在地图上百度LBS SDK当中提供了一个MyLocationData.Builder类，这个类是用来封装设备当前所在位置的，我们只需将经纬度信息传入到这个类的相应方法当中就可以了，如下所示： 123MyLocationData.Builder locationBuilder = new MyLocationData.Builder();locationBuilder.latitude(39.915);locationBuilder.longitude(116.404); MyLocationData.Builder类还提供了一个build()方法，当我们把要封装的信息都设置完成之后，只需要调用它的build()方法，就会生成一个MyLocationData的实例，然后再将这个实例传入到BaiduMap的setMyLocationData()方法当中，就可以让设备当前的位置显示在地图上了，写法如下： 12MyLocationData locationData = locationBuilder.build();baiduMap.setMyLocationData(locationData); 修改MainACtivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.zanecode6574.lbstest;import android.Manifest;import android.content.pm.PackageManager;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import com.baidu.location.BDLocation;import com.baidu.location.BDLocationListener;import com.baidu.location.LocationClient;import com.baidu.location.LocationClientOption;import com.baidu.mapapi.SDKInitializer;import com.baidu.mapapi.map.BaiduMap;import com.baidu.mapapi.map.MapStatusUpdate;import com.baidu.mapapi.map.MapStatusUpdateFactory;import com.baidu.mapapi.map.MapView;import com.baidu.mapapi.map.MyLocationData;import com.baidu.mapapi.model.LatLng;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public LocationClient mLocationClient; private TextView positionText; private MapView mapView; private BaiduMap baiduMap; private boolean isFirstLocate=true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mLocationClient =new LocationClient(getApplicationContext()); mLocationClient.registerLocationListener(new MyLocationListener()); SDKInitializer.initialize(getApplicationContext()); setContentView(R.layout.activity_main); mapView=findViewById(R.id.bmapView); baiduMap=mapView.getMap(); baiduMap.setMyLocationEnabled(true); positionText=findViewById(R.id.position_text_view); List&lt;String&gt; permissionList=new ArrayList&lt;&gt;(); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.ACCESS_FINE_LOCATION)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.ACCESS_FINE_LOCATION); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.READ_PHONE_STATE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.READ_PHONE_STATE); &#125; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; permissionList.add(Manifest.permission.WRITE_EXTERNAL_STORAGE); &#125; if(!permissionList.isEmpty())&#123; String[] permissions=permissionList.toArray(new String[permissionList.size()]); ActivityCompat.requestPermissions(MainActivity.this,permissions,1); &#125;else&#123; requestLocation(); &#125; &#125; private void requestLocation()&#123; initLocation(); mLocationClient.start(); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if(grantResults.length&gt;0)&#123; for(int result:grantResults)&#123; if(result!=PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(this, "必须同意所有权限才能使用应用", Toast.LENGTH_SHORT).show(); finish(); return; &#125; &#125; requestLocation(); &#125;else&#123; Toast.makeText(this, "发生未知错误!", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; private void navigateTo(BDLocation location)&#123; if(isFirstLocate)&#123; LatLng ll=new LatLng(location.getLatitude(),location.getLongitude()); MapStatusUpdate update=MapStatusUpdateFactory.newLatLng(ll); baiduMap.animateMapStatus(update); update=MapStatusUpdateFactory.zoomTo(20f); baiduMap.animateMapStatus(update); isFirstLocate=false; &#125; MyLocationData.Builder locationBuilder=new MyLocationData.Builder(); locationBuilder.latitude(location.getLatitude()); locationBuilder.longitude(location.getLongitude()); MyLocationData locationData=locationBuilder.build(); baiduMap.setMyLocationData(locationData); &#125; private void initLocation()&#123; LocationClientOption option=new LocationClientOption(); option.setScanSpan(1000); option.setLocationMode(LocationClientOption.LocationMode.Device_Sensors); option.setIsNeedAddress(true); mLocationClient.setLocOption(option); &#125; public class MyLocationListener implements BDLocationListener&#123; @Override public void onReceiveLocation(final BDLocation bdLocation) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; StringBuilder currentPosition=new StringBuilder(); currentPosition.append("纬度：").append(bdLocation.getLatitude()).append("\n"); currentPosition.append("线：").append(bdLocation.getLongitude()).append("\n"); currentPosition.append("国家:").append(bdLocation.getCountry()).append("\n"); currentPosition.append("省：").append(bdLocation.getProvince()).append("\n"); currentPosition.append("市：").append(bdLocation.getCity()).append("\n"); currentPosition.append("区：").append(bdLocation.getDistrict()).append("\n"); currentPosition.append("街道").append(bdLocation.getStreet()).append("\n"); currentPosition.append("定位方式"); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation)&#123; currentPosition.append("GPS"); &#125;else if(bdLocation.getLocType()==BDLocation.TypeNetWorkLocation)&#123; currentPosition.append("网络"); &#125; positionText.setText(currentPosition); &#125; &#125;); if(bdLocation.getLocType()==BDLocation.TypeGpsLocation || bdLocation.getLocType() ==BDLocation.TypeNetWorkLocation)&#123; navigateTo(bdLocation); &#125; &#125; &#125; @Override protected void onResume() &#123; super.onResume(); mapView.onResume(); &#125; @Override protected void onPause() &#123; super.onPause(); mapView.onPause(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mLocationClient.stop(); mapView.onDestroy(); baiduMap.setMyLocationEnabled(false); &#125;&#125; 在navigateTo()方法中，我们添加了MyLocationData的构建逻辑，将Location中包含的经度和纬度分别封装到了MyLocationData.Builder当中，最后把MyLocationData设置到了BaiduMap的setMyLocationData()方法当中。注意这段逻辑必须写在isFirstLocate这个if条件语句的外面，因为让地图移动到我们当前的位置只需要在第一次定位的时候执行，但是设备在地图上显示的位置却应该是随着设备的移动而实时改变的。 另外，根据百度地图的限制，如果我们想要使用这一功能，一定要事先调用BaiduMap的setMyLocationEnabled()方法将此功能开启，否则设备的位置将无法在地图上显示。而在程序退出的时候，也要记得将此功能给关闭掉。]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>位置服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十章：探究服务]]></title>
    <url>%2F2019%2F01%2F25%2F%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E6%8E%A2%E7%A9%B6%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[简介服务（Service）是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。 不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。 另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况。 Android多线程编程当我们需要执行一些耗时操作，比如说发起一条网络请求时，考虑到网速等其他原因，服务器未必会立刻响应我们的请求，如果不将这类操作放在子线程里去运行，就会导致主线程被阻塞住，从而影响用户对软件的正常使用。 线程基本用法方法一 定义一个线程只需要新建一个类继承自Thread，然后重写父类的run()方法，并在里面编写耗时逻辑即可 123456class MyThread extends Thread&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125; 启动线程只需要new出MyThread的实例，然后调用它的start()方法，这样run()方法中的代码就会在子线程当中运行了new MyThread().start(); 方法二 使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现Runnable接口的方式来定义一个线程 123456class MyThread implements Runnable &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125; 启动线程的方法 12MyThread myThread = new MyThread();new Thread(myThread).start(); Thread的构造函数接收一个Runnable参数，而我们new出的MyThread正是一个实现了Runnable接口的对象，所以可以直接将它传入到Thread的构造函数里。接着调用Thread的start()方法，run()方法中的代码就会在子线程当中运行了。 方法三 使用匿名类的方式 123456new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125;&#125;).start(); 在子线程中更新UI和其他许多GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常。 新建AndroidThreadTest项目 修改activity_main.xml的代码 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/change_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="修改文字"/&gt; &lt;TextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="Hello" android:textSize="20sp"/&gt;&lt;/RelativeLayout&gt; 修改MainActivity中的代码 12345678910111213141516171819202122232425262728293031323334353637383940package com.zanecode6574.androidthreadtest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView text; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text=findViewById(R.id.text); Button changeText=findViewById(R.id.change_text); changeText.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; text.setText("改变了！"); &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 这个代码如果去点击按钮是会崩溃的，因为安卓不允许在子线程更新UI，有些时候，我们必须在子线程里去执行一些耗时任务，然后根据任务的执行结果来更新相应的UI控件，对于这种情况，Android提供了一套异步消息处理机制，完美地解决了在子线程中进行UI操作的问题。 修改MainACtivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zanecode6574.androidthreadtest;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView text; public static final int UPDATE_TEXT=1; private Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case UPDATE_TEXT: text.setText("我改了！"); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text=findViewById(R.id.text); Button changeText=findViewById(R.id.change_text); changeText.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.change_text: new Thread(new Runnable() &#123; @Override public void run() &#123; Message message=new Message(); message.what=UPDATE_TEXT; handler.sendMessage(message); &#125; &#125;).start(); break; default: break; &#125; &#125;&#125; 这样就完全没有问题,我们先是定义了一个整型常量UPDATE_TEXT，用于表示更新TextView这个动作。然后新增一个Handler对象，并重写父类的handleMessage()方法，在这里对具体的Message进行处理。如果发现Message的what字段的值等于UPDATE_TEXT，就将TextView显示的内容修改。 对于Change Text按钮的点击事件中的代码。可以看到，这次我们并没有在子线程里直接进行UI操作，而是创建了一个Message（android.os.Message）对象，并将它的what字段的值指定为UPDATE_TEXT，然后调用Handler的sendMessage()方法将这条Message发送出去。很快，Handler就会收到这条Message，并在handleMessage()方法中对它进行处理。注意此时handleMessage()方法中的代码就是在主线程当中运行的了，所以我们可以放心地在这里进行UI操作。接下来对Message携带的what字段的值进行判断，如果等于UPDATE_TEXT，就将TextView显示的内容修改。 解析异步消息处理机制Android中的异步消息处理主要由4个部分组成：Message、Handler、MessageQueue和Looper。其中Message和Handler在上一小节中我们已经接触过了，而MessageQueue和Looper还是全新的概念。 Message：Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据。上一小节中我们使用到了Message的what字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用obj字段携带一个Object对象。 Handler：Handler顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用Handler的sendMessage()方法，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。 MessageQueue：MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。 Looper：Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中也只会有一个Looper对象。 异步消息处理流程：首先需要在主线程当中创建一个Handler对象，并重写handleMessage()方法。然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去。之后这条消息会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage()方法中。由于Handler是在主线程中创建的，所以此时handleMessage()方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行UI操作了。 使用AsyncTask为了更加方便我们在子线程中对UI进行操作，Android还提供了另外一些好用的工具，比如AsyncTask。借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask背后的实现原理也是基于异步消息处理机制的，只是Android帮我们做了很好的封装而已。 AsyncTask基本用法由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定3个泛型参数，这3个参数的用途如下。 Params：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。 Progress：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。 Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 一个简单的自定义AsyncTask123class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; ...&#125; 这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。 当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下4个。 onPreExecute()：这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground(Params…)：这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress (Progress…)方法来完成。 onProgressUpdate(Progress…)：当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。 onPostExecute(Result)：当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 一个比较完整的自定义AsyncTask123456789101112131415161718192021222324252627282930313233343536class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123; @Override protected void onPreExecute() &#123; progressDialog.show(); // 显示进度对话框 &#125; @Override protected Boolean doInBackground(Void... params) &#123; try &#123; while (true) &#123; int downloadPercent = doDownload(); // 这是一个虚构的方法 publishProgress(downloadPercent); if (downloadPercent &gt;= 100) &#123; break; &#125; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; // 在这里更新下载进度 progressDialog.setMessage("Downloaded " + values[0] + "%"); &#125; @Override protected void onPostExecute(Boolean result) &#123; progressDialog.dismiss(); // 关闭进度对话框 // 在这里提示下载结果 if (result) &#123; Toast.makeText(context, "Download succeeded", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, " Download failed", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 在这个DownloadTask中，我们在doInBackground()方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。注意这里虚构了一个doDownload()方法，这个方法用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了，由于doInBackground()方法是在子线程中运行的，在这里肯定不能进行UI操作，所以我们可以调用publishProgress()方法并将当前的下载进度传进来，这样onProgressUpdate()方法就会很快被调用，在这里就可以进行UI操作了。当下载完成后，doInBackground()方法会返回一个布尔型变量，这样onPostExecute()方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的Toast提示，从而完成整个DownloadTask任务。 使用AsyncTask的诀窍就是，在doInBackground()方法中执行具体的耗时任务，在onProgressUpdate()方法中进行UI操作，在onPostExecute()方法中执行一些任务的收尾工作。 如果想要启动这个任务，只需编写以下代码即可：new DownloadTask().execute(); 服务的基本用法定义一个服务 新建一个ServiceTest项目 新建Service：右击com.example.servicetest→New→Service→Service 12345678910111213141516package com.zanecode6574.servicetest;import android.app.Service;import android.content.Intent;import android.os.IBinder;public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125;&#125; MyService是继承自Service类的，说明这是一个服务。目前MyService中可以算是空空如也，但有一个onBind()方法特别醒目。这个方法是Service中唯一的一个抽象方法，所以必须要在子类里实现。我们会在后面的小节中使用到onBind()方法，目前可以暂时将它忽略掉。 重写服务中的一些方法 12345678910111213141516171819202122232425262728293031package com.zanecode6574.servicetest;import android.app.Service;import android.content.Intent;import android.os.IBinder;public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; onCreate()、onStartCommand()和onDestroy()这3个方法是每个服务中最常用到的3个方法了。其中onCreate()方法会在服务创建的时候调用，onStartCommand()方法会在每次服务启动的时候调用，onDestroy()方法会在服务销毁的时候调用。 通常情况下，如果我们希望服务一旦启动就立刻去执行某个动作，就可以将逻辑写在onStartCommand()方法里。而当服务销毁时，我们又应该在onDestroy()方法中去回收那些不再使用的资源。 另外需要注意，每一个服务都需要在AndroidManifest.xml文件中进行注册才能生效，这是Android四大组件共有的特点。 但是Android Studio已经帮我们添加好了 启动和停止服务启动和停止的方法主要是借助Intent来实现的 修改activity_main.xml中的代码 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/start_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="启动服务"/&gt; &lt;Button android:id="@+id/stop_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="停止服务"/&gt;&lt;/LinearLayout&gt; 修改MainActivity中的代码 1234567891011121314151617181920212223242526272829303132333435363738package com.zanecode6574.servicetest;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService=findViewById(R.id.start_service); Button stopService=findViewById(R.id.stop_service); startService.setOnClickListener(this); stopService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.start_service: Intent startIntent=new Intent(this, MyService.class); startService(startIntent); break; case R.id.stop_service: Intent stopIntent=new Intent(this,MyService.class); stopService(stopIntent); break; default: break; &#125; &#125;&#125; 如果没有点击Stop Service按钮，服务就会一直处于运行状态。那服务有没有什么办法让自已停止下来呢？当然可以，只需要在MyService的任何一个位置调用stopSelf()方法就能让这个服务停止下来了。 onCreate()方法是在服务第一次创建的时候调用的，而onStartCommand()方法则在每次启动服务的时候都会调用，由于刚才我们是第一次点击Start Service按钮，服务此时还未创建过，所以两个方法都会执行，之后如果你再连续多点击几次Start Service按钮，你就会发现只有onStartCommand()方法可以得到执行了。 活动和服务进行通信比如说，目前我们希望在MyService里提供一个下载功能，然后在活动中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的Binder对象来对下载功能进行管理 修改MyService中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zanecode6574.servicetest;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class MyService extends Service &#123; private DownloadBinder mBinder=new DownloadBinder(); class DownloadBinder extends Binder&#123; public void startDownload()&#123; Log.d("MyService", "开始下载！"); &#125; public int getProgress()&#123; Log.d("MyService", "获取下载进度执行!"); return 0; &#125; &#125; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. return mBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 这里我们新建了一个DownloadBinder类，并让它继承自Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功能，我们在这两个方法中分别打印了一行日志。接着，在MyService中创建了DownloadBinder的实例，然后在onBind()方法里返回了这个实例，这样MyService中的工作就全部完成了。 在布局中新增两个按钮 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/start_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="启动服务"/&gt; &lt;Button android:id="@+id/stop_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="停止服务"/&gt; &lt;Button android:id="@+id/bind_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="绑定服务"/&gt; &lt;Button android:id="@+id/unbind_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="取消绑定服务"/&gt;&lt;/LinearLayout&gt; 修改MainActivity中的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.zanecode6574.servicetest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private MyService.DownloadBinder downloadBinder; private ServiceConnection connection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder=(MyService.DownloadBinder)service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService=findViewById(R.id.start_service); Button stopService=findViewById(R.id.stop_service); Button bindService=findViewById(R.id.bind_service); Button unbindService=findViewById(R.id.unbind_service); startService.setOnClickListener(this); stopService.setOnClickListener(this); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.start_service: Intent startIntent=new Intent(this, MyService.class); startService(startIntent); break; case R.id.stop_service: Intent stopIntent=new Intent(this,MyService.class); stopService(stopIntent); break; case R.id.bind_service: Intent bindIntent=new Intent(this,MyService.class); bindService(bindIntent,connection,BIND_AUTO_CREATE); break; case R.id.unbind_service: unbindService(connection); default: break; &#125; &#125;&#125; 这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，这两个方法分别会在活动与服务成功绑定以及活动与服务的连接断开的时候调用。在onServiceConnected()方法中，我们又通过向下转型得到了DownloadBinder的实例，有了这个实例，活动和服务之间的关系就变得非常紧密了。 现在我们可以在活动中根据具体的场景来调用DownloadBinder中的任何public方法，即实现了指挥服务干什么服务就去干什么的功能。这里仍然只是做了个简单的测试，在onServiceConnected()方法中调用了DownloadBinder的startDownload()和getProgress()方法。 当然，现在活动和服务其实还没进行绑定呢，这个功能是在Bind Service按钮的点击事件里完成的。可以看到，这里我们仍然是构建出了一个Intent对象，然后调用bindService()方法将MainActivity和MyService进行绑定。bindService()方法接收3个参数，第一个参数就是刚刚构建出的Intent对象，第二个参数是前面创建出的ServiceConnection的实例，第三个参数则是一个标志位，这里传入BIND_AUTO_CREATE表示在活动和服务进行绑定后自动创建服务。这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。 然后如果我们想解除活动和服务之间的绑定该怎么办呢？调用一下unbindService()方法就可以了，这也是Unbind Service按钮的点击事件里实现的功能。 注意任何一个服务在整个应用程序范围内都是通用的，即MyService不仅可以和MainActivity绑定，还可以和任何一个其他的活动进行绑定，而且在绑定完成后它们都可以获取到相同的DownloadBinder实例。 服务的生命周期服务也有自己的生命周期，前面我们使用到的onCreate()、onStartCommand()、onBind()和onDestroy()等方法都是在服务的生命周期内可能回调的方法。 一旦在项目的任何位置调用了Context的startService()方法，相应的服务就会启动起来，并回调onStartCommand()方法。如果这个服务之前还没有创建过，onCreate()方法会先于onStartCommand()方法执行。服务启动了之后会一直保持运行状态，直到stopService()或stopSelf()方法被调用。注意，虽然每调用一次startService()方法，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService()方法，只需调用一次stopService()或stopSelf()方法，服务就会停止下来了。 还可以调用Context的bindService()来获取一个服务的持久连接，这时就会回调服务中的onBind()方法。类似地，如果这个服务之前还没有创建过，onCreate()方法会先于onBind()方法执行。之后，调用方可以获取到onBind()方法里返回的IBinder对象的实例，这样就能自由地和服务进行通信了。只要调用方和服务之间的连接没有断开，服务就会一直保持运行状态。 当调用了startService()方法后，又去调用stopService()方法，这时服务中的onDestroy()方法就会执行，表示服务已经销毁了。类似地，当调用了bindService()方法后，又去调用unbindService()方法，onDestroy()方法也会执行 需要注意，我们是完全有可能对一个服务既调用了startService()方法，又调用了bindService()方法的，这种情况下该如何才能让服务销毁掉呢？根据Android系统的机制，一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。 服务的更多技巧使用前台服务服务几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是服务的系统优先级还是比较低的，当系统出现内存不足的情况时，就有可能会回收掉正在后台运行的服务。如果你希望服务可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务。前台服务和普通服务最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止服务被回收掉才使用前台服务的，有些项目由于特殊的需求会要求必须使用前台服务，比如说彩云天气这款天气预报应用，它的服务在后台更新天气数据的同时，还会在系统状态栏一直显示当前的天气信息. 创建一个前台服务 修改MyService中的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.zanecode6574.servicetest;import android.app.Notification;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.util.Log;public class MyService extends Service &#123; private DownloadBinder mBinder=new DownloadBinder(); class DownloadBinder extends Binder&#123; public void startDownload()&#123; Log.d("MyService", "开始下载！"); &#125; public int getProgress()&#123; Log.d("MyService", "获取下载进度执行!"); return 0; &#125; &#125; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. return mBinder; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d("MyService", "onCreate函数执行了！"); Intent intent=new Intent(this,MainActivity.class); PendingIntent pi=PendingIntent.getActivity(this,0,intent,0); Notification notification=new NotificationCompat.Builder(this) .setContentTitle("这是一个标题") .setContentText("这是内容") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); startForeground(1,notification); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 这就是我们在第8章中学习的创建通知的方法。只不过这次在构建出Notification对象后并没有使用NotificationManager来将通知显示出来，而是调用了startForeground()方法。这个方法接收两个参数，第一个参数是通知的id，类似于notify()方法的第一个参数，第二个参数则是构建出的Notification对象。调用startForeground()方法后就会让MyService变成一个前台服务，并在系统状态栏显示出来。 这段代码在安卓8以上会闪退，原因不明，估计是因为有些写法不一样了，待修改 使用IntentService服务中的代码都是默认运行在主线程当中的，如果直接在服务里去处理一些耗时的逻辑，就很容易出现ANR（Application Not Responding）的情况。 所以这个时候就需要用到Android多线程编程的技术了，我们应该在服务的每个具体的方法里开启一个子线程，然后在这里去处理那些耗时的逻辑。 一个比较标准的服务： 12345678910111213public class MyService extends Service &#123; ... @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125;&#125; 这种服务一旦启动之后，就会一直处于运行状态，必须调用stopService()或者stopSelf()方法才能让服务停止下来。 实现让服务完成以后自动停止 1234567891011121314public class MyService extends Service &#123; ... @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 处理具体的逻辑 stopSelf(); &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125;&#125; IntentService类 为了可以简单地创建一个异步的、会自动停止的服务，Android专门提供了一个IntentService类 新建一个MyIntentService类继承自IntentService 12345678910111213141516171819202122232425package com.zanecode6574.servicetest;import android.app.IntentService;import android.content.Intent;import android.util.Log;import org.jetbrains.annotations.Nullable;public class MyIntentService extends IntentService &#123; public MyIntentService()&#123; super("MyIntentService"); //调用父类的有参构造函数 &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; //打印当前线程的id Log.d("MyIntentService", "线程id是"+ Thread.currentThread().getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService", "onDestory执行了"); &#125;&#125; 这里首先要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数。然后要在子类中去实现onHandleIntent()这个抽象方法，在这个方法中可以去处理一些具体的逻辑，而且不用担心ANR的问题，因为这个方法已经是在子线程中运行的了。这里为了证实一下，我们在onHandleIntent()方法中打印了当前线程的id。另外根据IntentService的特性，这个服务在运行结束后应该是会自动停止的，所以我们又重写了onDestroy()方法，在这里也打印了一行日志，以证实服务是不是停止掉了。 修改activity_main.xml的代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/start_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="启动服务"/&gt; &lt;Button android:id="@+id/stop_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="停止服务"/&gt; &lt;Button android:id="@+id/bind_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="绑定服务"/&gt; &lt;Button android:id="@+id/unbind_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="取消绑定服务"/&gt; &lt;Button android:id="@+id/start_intent_service" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="启动Intent服务"/&gt;&lt;/LinearLayout&gt; 修改MainActivity代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.zanecode6574.servicetest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private MyService.DownloadBinder downloadBinder; private ServiceConnection connection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder=(MyService.DownloadBinder)service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService=findViewById(R.id.start_service); Button stopService=findViewById(R.id.stop_service); Button bindService=findViewById(R.id.bind_service); Button unbindService=findViewById(R.id.unbind_service); Button startIntentService=findViewById(R.id.start_intent_service); startService.setOnClickListener(this); stopService.setOnClickListener(this); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); startIntentService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.start_service: Intent startIntent=new Intent(this, MyService.class); startService(startIntent); break; case R.id.stop_service: Intent stopIntent=new Intent(this,MyService.class); stopService(stopIntent); break; case R.id.bind_service: Intent bindIntent=new Intent(this,MyService.class); bindService(bindIntent,connection,BIND_AUTO_CREATE); break; case R.id.unbind_service: unbindService(connection); break; case R.id.start_intent_service: //打印主线程id Log.d("MainActivity", "主线程ID: "+Thread.currentThread().getId()); Intent intentService=new Intent(this,MyIntentService.class); startService(intentService); break; default: break; &#125; &#125;&#125; 在AndroidManifest.xml中注册服务 1&lt;service android:name=".MyIntentService"/&gt; 服务实践-完整版下载这个实践会用到7/8/9/10章的知识，做一个完整的下载 创建一个ServicePractice项目 添加依赖implementation &#39;com.squareup.okhttp3:okhttp:3.12.1&#39; 定义回调接口，对下载过程中的各种状态进行监听和回调，新建DownloadListener接口 1234567public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; 使用AsyncTask实现下载功能,新建DownloadTask类继承自AsyncTask 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package com.zanecode6574.servicepractice;import android.os.AsyncTask;import android.os.Environment;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class DownloadTask extends AsyncTask&lt;String,Integer,Integer&gt; &#123; public static final int TYPE_SUCCESS=0; public static final int TYPE_FAILED=1; public static final int TYPE_PAUSED=2; public static final int TYPE_CANCELED=3; private DownloadListener listener; private boolean isCanceled=false; private boolean isPaused=false; private int lastProgress; public DownloadTask(DownloadListener listener)&#123; this.listener=listener; &#125; @Override protected Integer doInBackground(String... params) &#123; InputStream is=null; RandomAccessFile saveFile=null; File file=null; try&#123; long downloadLength=0; //记录已经下载的文件长度 String downloadUrl=params[0]; //substring：返回该字符串的子字符串。子字符串从指定索引处的字符开始，一直延伸到该字符串的末尾。 //lastIndexOf：返回该字符串中指定子字符串最后一次出现的索引。空字符串“”的最后一次出现被认为发生在索引值&#123;@code this.length()&#125;处。 String fileName=downloadUrl.substring(downloadUrl.lastIndexOf("/")); String directory=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file=new File(directory+fileName); if(file.exists())&#123; downloadLength=file.length(); &#125; long contentLength=getContentLength(downloadUrl); if(contentLength==0)&#123; return TYPE_FAILED; &#125;else if(contentLength==downloadLength)&#123; return TYPE_SUCCESS; &#125; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() //断点下载，Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容。 .addHeader("RANGE","bytes="+downloadLength+"-") .url(downloadUrl) .build(); Response response=client.newCall(request).execute(); if(response!=null)&#123; is=response.body().byteStream(); saveFile=new RandomAccessFile(file,"rw"); saveFile.seek(downloadLength); //跳过已经下载的字节 byte[] b=new byte[1024]; int total=0; int len; while((len=is.read(b))!=-1)&#123; if(isCanceled)&#123; return TYPE_CANCELED; &#125;else if(isPaused)&#123; return TYPE_PAUSED; &#125;else&#123; total+=len; //write(byte[] b,int off, int len)：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 saveFile.write(b,0,len); //计算已经下载的百分比 int progress=(int)((total+downloadLength)*100/contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(is!=null)&#123; is.close(); &#125; if(saveFile!=null)&#123; saveFile.close(); &#125; if(isCanceled &amp;&amp; file!=null)&#123; file.delete(); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; return TYPE_FAILED; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; int progress=values[0]; if(progress&gt;lastProgress)&#123; listener.onProgress(progress); lastProgress=progress; &#125; &#125; @Override protected void onPostExecute(Integer status) &#123; switch(status)&#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); break; default: break; &#125; &#125; public void pauseDownload()&#123; isPaused=true; &#125; public void cancelDownload()&#123; isCanceled=true; &#125; private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url(downloadUrl) .build(); Response response=client.newCall(request).execute(); if(response!=null &amp;&amp; response.isSuccessful())&#123; long contentLength=response.body().contentLength(); response.body().close(); return contentLength; &#125; return 0; &#125;&#125; 首先看一下AsyncTask中的3个泛型参数：第一个泛型参数指定为String，表示在执行AsyncTask的时候需要传入一个字符串参数给后台任务；第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位；第三个泛型参数指定为Integer，则表示使用整型数据来反馈执行结果。 接下来我们定义了4个整型常量用于表示下载的状态，TYPE_SUCCESS表示下载成功，TYPE_FAILED表示下载失败，TYPE_PAUSED表示暂停下载，TYPE_CANCELED表示取消下载。然后在DownloadTask的构造函数中要求传入一个刚刚定义的DownloadListener参数，我们待会就会将下载的状态通过这个参数进行回调。 接着就是要重写doInBackground()、onProgressUpdate()和onPostExecute()这3个方法了，我们之前已经学习过这3个方法各自的作用，因此在这里它们各自所负责的任务也是明确的：doInBackground()方法用于在后台执行具体的下载逻辑，onProgressUpdate()方法用于在界面上更新当前的下载进度，onPostExecute()用于通知最终的下载结果。 看一下doInBackground()方法，首先我们从参数中获取到了下载的URL地址，并根据URL地址解析出了下载的文件名，然后指定将文件下载到Environment.DIRECTORY_DOWNLOADS目录下，也就是SD卡的Download目录。我们还要判断一下Download目录中是不是已经存在要下载的文件了，如果已经存在的话则读取已下载的字节数，这样就可以在后面启用断点续传的功能。 接下来先是调用了getContentLength()方法来获取待下载文件的总长度，如果文件长度等于0则说明文件有问题，直接返回TYPE_FAILED，如果文件长度等于已下载文件长度，那么就说明文件已经下载完了，直接返回TYPE_SUCCESS即可。 紧接着使用OkHttp来发送一条网络请求，需要注意的是，这里在请求中添加了一个header，用于告诉服务器我们想要从哪个字节开始下载，因为已下载过的部分就不需要再重新下载了。接下来读取服务器响应的数据，并使用Java的文件流方式，不断从网络上读取数据，不断写入到本地，一直到文件全部下载完成为止。在这个过程中，我们还要判断用户有没有触发暂停或者取消的操作，如果有的话则返回TYPE_PAUSED或TYPE_CANCELED来中断下载，如果没有的话则实时计算当前的下载进度， 然后调用publishProgress()方法进行通知。暂停和取消操作都是使用一个布尔型的变量来进行控制的，调用pauseDownload()或cancelDownload()方法即可更改变量的值。 接下来看一下onProgressUpdate()方法，这个方法就简单得多了，它首先从参数中获取到当前的下载进度，然后和上一次的下载进度进行对比，如果有变化的话则调用DownloadListener的onProgress()方法来通知下载进度更新。 最后是onPostExecute()方法，也非常简单，就是根据参数中传入的下载状态来进行回调。下载成功就调用DownloadListener的onSuccess()方法，下载失败就调用onFailed()方法，暂停下载就调用onPaused()方法，取消下载就调用onCanceled()方法。 这样我们就把具体的下载功能完成了，下面为了保证DownloadTask可以一直在后台运行，我们还需要创建一个下载的服务。右击com.example.servicebestpractice→New→Service→Service，新建DownloadService，然后修改其中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.zanecode6574.servicepractice;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Environment;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.widget.Toast;import java.io.File;public class DownloadService extends Service &#123; private DownloadTask downloadTask; private String downloadUrl; private DownloadListener listener=new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification("下载中...",progress)); &#125; @Override public void onSuccess() &#123; downloadTask=null; //下载成功将前台服务通知关闭并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1,getNotification("下载成功！",-1)); Toast.makeText(DownloadService.this, "下载成功！", Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask=null; stopForeground(true); getNotificationManager().notify(1,getNotification("下载失败！",-1)); Toast.makeText(DownloadService.this, "下载失败！", Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask=null; Toast.makeText(DownloadService.this, "下载暂停！", Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask=null; stopForeground(true); Toast.makeText(DownloadService.this, "下载取消！", Toast.LENGTH_SHORT).show(); &#125; &#125;; private DownloadBinder mBinder=new DownloadBinder(); class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadTask==null)&#123; downloadUrl=url; downloadTask=new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification("下载中...",0)); Toast.makeText(DownloadService.this, "下载中", Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload()&#123; if(downloadTask!=null)&#123; downloadTask.pauseDownload(); &#125; &#125; public void cancelDownload()&#123; if(downloadTask!=null)&#123; downloadTask.cancelDownload(); &#125;else&#123; if(downloadUrl!=null)&#123; //取消下载的时候删除文件关闭通知 String fileName=downloadUrl.substring(downloadUrl.lastIndexOf("/")); String directory=Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file=new File(directory+fileName); if(file.exists())&#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, "下载取消！", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; public DownloadService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. return mBinder; &#125; private NotificationManager getNotificationManager()&#123; return (NotificationManager)getSystemService(NOTIFICATION_SERVICE); &#125; private Notification getNotification(String title, int progress)&#123; Intent intent=new Intent(this,MainActivity.class); PendingIntent pi=PendingIntent.getActivity(this,0,intent,0); NotificationCompat.Builder builder=new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if(progress&gt;=0)&#123; //当progress大于或等于0时才需要显示下载进度 builder.setContentText(progress+"%"); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; 首先这里创建了一个DownloadListener的匿名类实例，并在匿名类中实现了onProgress()、onSuccess()、onFailed()、onPaused()和onCanceled()这5个方法。 在onProgress()方法中，我们调用getNotification()方法构建了一个用于显示下载进度的通知，然后调用NotificationManager的notify()方法去触发这个通知，这样就可以在下拉状态栏中实时看到当前下载的进度了。在 onSuccess()方法中，我们首先是将正在下载的前台通知关闭，然后了创建一个新的通知用于告诉用户下载成功了。其他几个方法也都是类似的，分别用于告诉用户下载失败、暂停和取消这几个事件。 接下来为了要让DownloadService可以和活动进行通信，我们又创建了一个DownloadBinder。DownloadBinder中提供了startDownload()、pauseDownload()和cancelDownload()这3个方法，那么顾名思义，它们分别是用于开始下载、暂停下载和取消下载的。 在startDownload()方法中，我们创建了一个DownloadTask的实例，把刚才的DownloadListener作为参数传入，然后调用execute()方法开启下载，并将下载文件的URL地址传入到execute()方法中。同时，为了让这个下载服务成为一个前台服务，我们还调用了startForeground()方法，这样就会在系统状态栏中创建一个持续运行的通知了。 接着往下看，pauseDownload()方法中的代码就非常简单了，就是简单地调用了一下DownloadTask中的pauseDownload()方法。cancelDownload()方法中的逻辑也基本类似，但是要注意，取消下载的时候我们需要将正在下载的文件删除掉，这一点和暂停下载是不同的。 另外，DownloadService类中所有使用到的通知都是调用getNotification()方法进行构建的，这个方法中的代码我们之前基本都是学过的，只有一个setProgress()方法没有见过。setProgress()方法接收3个参数，第一个参数传入通知的最大进度，第二个参数传入通知的当前进度，第三个参数表示是否使用模糊进度条，这里传入false。设置完setProgress()方法，通知上就会有进度条显示出来了。 修改activity_main.xml中的代码 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/start_download" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="开始下载"/&gt; &lt;Button android:id="@+id/pause_download" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="暂停下载"/&gt; &lt;Button android:id="@+id/cancel_download" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="取消下载"/&gt; &lt;/LinearLayout&gt; 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.zanecode6574.servicepractice;import android.Manifest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.content.pm.PackageManager;import android.os.IBinder;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder=(DownloadService.DownloadBinder)service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload=findViewById(R.id.start_download); Button pauseDownload=findViewById(R.id.pause_download); Button cancelDownload=findViewById(R.id.cancel_download); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent=new Intent(this,DownloadService.class); startService(intent); //启动服务 bindService(intent,connection,BIND_AUTO_CREATE); //绑定服务 if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125; &#125; @Override public void onClick(View v) &#123; if(downloadBinder==null)&#123; return; &#125; switch(v.getId())&#123; case R.id.start_download: String url="https://raw.githubusercontent.com/guolindev/eclipse/master/eclipse-inst-win64.exe"; downloadBinder.startDownload(url); break; case R.id.pause_download: downloadBinder.pauseDownload(); break; case R.id.cancel_download: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch(requestCode)&#123; case 1: if(grantResults.length&gt;0 &amp;&amp; grantResults[0]!=PackageManager.PERMISSION_GRANTED)&#123; Toast.makeText(this, "拒绝权限将不能使用App", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 这里我们首先创建了一个ServiceConnection的匿名类，然后在onServiceConnected()方法中获取到 DownloadBinder的实例，有了这个实例，我们就可以在活动中调用服务提供的各种方法了。 接下来看一下onCreate()方法，在这里我们对各个按钮都进行了初始化操作并设置了点击事件，然后分别调用了startService()和bindService()方法来启动和绑定服务。这一点至关重要，因为启动服务可以保证DownloadService一直在后台运行，绑定服务则可以让MainActivity和DownloadService进行通信，因此两个方法调用都必不可少。 在onCreate()方法的最后，我们还进行了WRITE_EXTERNAL_STORAGE的运行时权限申请，因为下载文件是要下载到SD卡的Download目录下的，如果没有这个权限的话，我们整个程序都无法正常工作。 接下来的代码就非常简单了，在onClick()方法中我们对点击事件进行判断，如果点击了开始按钮就调用DownloadBinder的startDownload()方法，如果点击了暂停按钮就调用pauseDownload()方法，如果点击了取消按钮就调用cancelDownload()方法。startDownload()方法中你可以传入任意的下载地址，这里我使用了一个Eclipse的下载地址，以此向这个Android平台上曾经最出色的开发工具致敬。 另外还有一点需要注意，如果活动被销毁了，那么一定要记得对服务进行解绑，不然就有可能会造成内存泄漏。这里我们在onDestroy()方法中完成了解绑操作。 在AndroidManifest中申明权限 12&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 截止到这里我还比较懵圈，因为之前的线程没有记住那几个的用法，所以这个整合起来就有点看不懂，复习是肯定要得，不复习是不可能的，只有回来背下来那些用法才能写写程序这样。还有，为啥不直接调用系统下载程序（偷懒必备）。]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>服务</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章：使用网络技术]]></title>
    <url>%2F2019%2F01%2F24%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Android手机肯定也是可以上网的，所以作为开发者，我们就需要考虑如何利用网络来编写出更加出色的应用程序，像QQ、微博、微信等常见的应用都会大量使用网络技术。本章主要会讲述如何在手机端使用HTTP协议和服务器端进行网络交互，并对服务器返回的数据进行解析，这也是Android中最常使用到的网络技术 WebView用法WebView可以在应用程序内加载网页，不用调用别的浏览器 新建WebViewTest项目 修改activity_main.xml，添加一个WebView控件 修改MainActivity 12345678910111213141516171819202122package com.zanecode6574.webviewtest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.webkit.WebChromeClient;import android.webkit.WebView;import android.webkit.WebViewClient;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); WebView webView=findViewById(R.id.web_view); webView.getSettings().setJavaScriptEnabled(true); webView.setWebViewClient(new WebViewClient()); webView.loadUrl("https://zanecode6574.com"); &#125;&#125; 使用http协议访问网络使用HttpURLConnection在过去，Android上发送HTTP请求一般有两种方式：HttpURLConnection和HttpClient。不过由于HttpClient存在API数量过多、扩展困难等缺点，Android团队越来越不建议我们使用这种方式。终于在Android 6.0系统中，HttpClient的功能被完全移除了。 HttpURLConnection的用法。 首先需要获取到HttpURLConnection的实例，一般只需new出一个URL对象，并传入目标的网络地址，然后调用一下openConnection()方法即可，如下所示： 12URL url = new URL("http://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection(); 在得到了HttpURLConnection的实例之后，我们可以设置一下HTTP请求所使用的方法。常用的方法主要有两个：GET和POST。GET表示希望从服务器那里获取数据，而POST则表示希望提交数据给服务器。写法如下： 1connection.setRequestMethod("GET"); 接下来就可以进行一些自由的定制了，比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等。这部分内容根据自己的实际情况进行编写，示例写法如下： 12connection.setConnectTimeout(8000);connection.setReadTimeout(8000); 之后再调用getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取，如下所示： 1InputStream in = connection.getInputStream(); 最后可以调用disconnect()方法将这个HTTP连接关闭掉，如下所示： 1connection.disconnect(); 新建NetworkTest项目 修改activity_main.xml中的代码 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center_horizontal" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/send_request" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/response_text" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 修改MainActivity的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest=findViewById(R.id.send_request); responseText=findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; //开启线程来发起网络请求 new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection=null; BufferedReader reader=null; try&#123; URL url=new URL("https://zanecode6574.com"); connection=(HttpURLConnection)url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream in=connection.getInputStream(); //对输入流进行获取 reader=new BufferedReader(new InputStreamReader(in)); StringBuilder response=new StringBuilder(); String line; while((line=reader.readLine())!=null)&#123; response.append(line); &#125; showResponse(response.toString()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if(reader!=null)&#123; try&#123; reader.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //在这里进行ui操作将结果显示到界面上 responseText.setText(response); &#125; &#125;); &#125;&#125; 在AndroidManifest中申明网络权限 如果要发送POST，只需要将HTTP请求方法改成POST，然后在获取输入流之前把要提交的数据写出即可，每条数据要以键值对的方式存在，数据以数据之间用&amp;隔开,比如向服务器提交用户名密码 123connection.setRequestMethod("POST");DataOutputStream out = new DataOutputStream(connection.getOutputStream());out.writeBytes("username=admin&amp;password=123456"); 使用OkHttp有许多出色的网络通信库都可以替代原生的HttpURLConnection，而其中OkHttp无疑是做得最出色的一个。OkHttp是由鼎鼎大名的Square公司开发的，这个公司在开源事业上面贡献良多，除了OkHttp之外，还开发了像Picasso、Retrofit等著名的开源项目。OkHttp不仅在接口封装上面做得简单易用，就连在底层实现上也是自成一派，比起原生的HttpURLConnection，可以说是有过之而无不及，现在已经成了广大Android开发者首选的网络通信库。(我以为是HttpClient，结果到这里才发现已经被弃用了) OkHttp项目地址：https://github.com/square/okhttp 在之前的项目基础上修改即可，添加依赖implementation &quot;com.squareup.okhttp3:okhttp:3.12.1&quot; OkHttp用法 首先需要创建一个OkHttpClient的实例，如下所示： 1OkHttpClient client = new OkHttpClient(); 如果想发起一条HTTP请求，就需要创建一个Request对象： 1Request request = new Request.Builder().build(); 上述代码只是创建了一个空的Request对象，并没有什么实际作用，我们可以在最终的build()方法之前连缀很多其他方法来丰富这个Request对象。比如可以通过url()方法来设置目标的网络地址，如下所示： 123Request request = new Request.Builder().url("http://www.baidu.com").build(); 之后调用OkHttpClient的newCall()方法来创建一个Call对象，并调用它的execute()方法来发送请求并获取服务器返回的数据，写法如下： 1Response response = client.newCall(request).execute(); 其中Response对象就是服务器返回的数据了，我们可以使用如下写法来得到返回的具体内容： 1String responseData = response.body().string(); 如果是发起一条POST请求会比GET请求稍微复杂一点，我们需要先构建出一个Request Body对象来存放待提交的参数，如下所示： 1234RequestBody requestBody = new FormBody.Builder().add("username", "admin").add("password", "123456").build(); 然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入： 1234Request request = new Request.Builder().url("http://www.baidu.com").post(requestBody).build(); 接下来的操作就和GET请求一样了，调用execute()方法来发送请求并获取服务器返回的数据即可。 实践使用OkHttp 直接在之前的项目上修改即可，修改MainActivity的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.zanecode6574.networktest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import static java.lang.Thread.sleep;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest=findViewById(R.id.send_request); responseText=findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if(v.getId()==R.id.send_request)&#123; sendRequestWithOkHttp(); &#125; &#125; private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url("https://zanecode6574.com") .build(); Response response=client.newCall(request).execute(); String responseData=response.body().string(); showResponse(responseData); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; responseText.setText(response); &#125; &#125;); &#125;&#125; 这个返回的字符串我发现比上面的方法多了很多空行 解析XML格式数据通常情况下，每个需要访问网络的应用程序都会有一个自己的服务器，我们可以向服务器提交数据，也可以从服务器上获取数据。不过这个时候就出现了一个问题，这些数据到底要以什么样的格式在网络上传输呢？随便传递一段文本肯定是不行的，因为另一方根本就不会知道这段文本的用途是什么。因此，一般我们都会在网络上传输一些格式化后的数据，这种数据会有一定的结构规格和语义，当另一方收到数据消息之后就可以按照相同的结构规格进行解析，从而取出他想要的那部分内容。在网络上传输数据时最常用的格式有两种：XML和JSON，下面我们就来一个一个地进行学习，本节首先学习一下如何解析XML格式的数据。 这里我们使用Apache服务器搭建一个简易的服务器，书上使用的是Windows，我使用的Mac,自带Apache服务,我就只写Mac的操作方式了 启动Apache服务器 打开终端，输入sudo -i，这里我是为了避免每次都要输入sudo 输入apachectl -v查看apache版本 输入apachectl -k start启动 在浏览器访问127.0.0.1测试服务是否启动成功 配置服务器 在当前Mac用户的文件夹下创建自己的Apache服务器文件夹，我这里命名为MyApache 进入/etc/apache2文件夹，这里我用finder进入的，可以自己用终端直接进入 配置httpd.conf文件 修改DocumentRoot和&lt;Directory ···这里为自己的Apache服务器文件夹路径 找到Options FollowSymLinks Multiviews,修改为Options Indexes FollowSymLinks Multiviews 把LoadModule php7_module libexec/apache2/libphp7.so前面的#去掉 回到etc目录下，拷贝php.ini.default文件为php.ini 重启Apache服务器，终端输入apachectl -k restart 再次访问127.0.0.1应该是这样了 在浏览器验证XML文件 在自己的MyApache文件夹下创建文件get_data.xml 1234567891011121314151617&lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;Google Maps&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;2&lt;/id&gt; &lt;name&gt;Chrome&lt;/name&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;3&lt;/id&gt; &lt;name&gt;Google Play&lt;/name&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/app&gt;&lt;/apps&gt; 浏览器访问127.0.0.1/get_data.xml Pull解析方式解析XML格式的数据其实也有挺多种方式的，本节中我们学习比较常用的两种，Pull解析和SAX解析。 在之前的项目基础上修改即可，修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.zanecode6574.networktest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserFactory;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.StringReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import static java.lang.Thread.sleep;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest=findViewById(R.id.send_request); responseText=findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if(v.getId()==R.id.send_request)&#123; sendRequestWithOkHttp(); &#125; &#125; private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url("http://10.0.2.2/get_data.xml") .build(); Response response=client.newCall(request).execute(); String responseData=response.body().string(); parseXMLWithPull(responseData); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; responseText.setText(response); &#125; &#125;); &#125; private void parseXMLWithPull(String xmlData)&#123; try&#123; XmlPullParserFactory factory=XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser=factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlData)); int eventType=xmlPullParser.getEventType(); String id=""; String name=""; String version=""; while(eventType!=XmlPullParser.END_DOCUMENT)&#123; String nodeName=xmlPullParser.getName(); switch(eventType)&#123; //开始解析某个节点 case XmlPullParser.START_TAG:&#123; if("id".equals(nodeName))&#123; //xmlPullParser.nextText()； //如果当前事件是START_TAG，则如果下一个元素是文本，则返回元素内容；如果下一个事件是END_TAG，则返回空字符串，否则抛出异常。成功调用此函数后，解析器将定位在END_TAG上。 id=xmlPullParser.nextText(); &#125;else if("name".equals(nodeName))&#123; name=xmlPullParser.nextText(); &#125;else if("version".equals(nodeName))&#123; version=xmlPullParser.nextText(); &#125; break; &#125; //完成解析某个节点 case XmlPullParser.END_TAG:&#123; if("app".equals(nodeName))&#123; Log.d("MainActivity", "Id是:"+id+" "+"名字是:"+name+" "+"版本:"+version); &#125; break; &#125; default: break; &#125; //xmlPullParser.next()； //获取下一个解析事件。 //空元素(如)将报告两个单独的事件:START_TAG, END_TAG -必须保留空元素对的解析等价性。 //当在END_TAG调用next()时，要两次才是START_TAG。 eventType=xmlPullParser.next(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 首先是将HTTP请求的地址改成了http://10.0.2.2/get_data.xml，10.0.2.2对于模拟器来说就是电脑本机的IP地址。在得到了服务器返回的数据后，我们并不再直接将其展示，而是调用了parseXMLWithPull()方法来解析服务器返回的数据。 parseXMLWithPull()方法中的代码:这里首先要获取到一个XmlPullParserFactory的实例，并借助这个实例得到XmlPullParser对象，然后调用XmlPullParser的setInput()方法将服务器返回的XML数据设置进去就可以开始解析了。解析的过程也非常简单，通过getEventType()可以得到当前的解析事件，然后在一个while循环中不断地进行解析，如果当前的解析事件不等于XmlPullParser.END_DOCUMENT，说明解析工作还没完成，调用next()方法后可以获取下一个解析事件。 在while循环中，我们通过getName()方法得到当前节点的名字，如果发现节点名等于id、name或version，就调用nextText()方法来获取节点内具体的内容，每当解析完一个app节点后就将获取到的内容打印出来。 SAX解析方式Pull解析方式虽然非常好用，但它并不是我们唯一的选择。SAX解析也是一种特别常用的XML解析方式，虽然它的用法比Pull解析要复杂一些，但在语义方面会更加清楚。 通常情况下会新建一个类继承自DefaultHandler,并重写父类的五个方法 123456789101112131415161718192021222324public class MyHandler extends DefaultHandler &#123; @Override public void startDocument() throws SAXException &#123; &#125; @Override public void startElement(String uri, String localName, String qName, Attributesattributes) throws SAXException &#123; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; &#125; @Override public void endElement(String uri, String localName, String qName) throwsSAXException &#123; &#125; @Override public void endDocument() throws SAXException &#123; &#125;&#125; startDocument()方法会在开始XML解析的时候调用 startElement()方法会在开始解析某个节点的时候调用 characters()方法会在获取节点中内容的时候调用 endElement()方法会在完成解析某个节点的时候调用 endDocument()方法会在完成整个XML解析的时候调用 其中，startElement()、characters()和endElement()这3个方法是有参数的，从XML中解析出的数据就会以参数的形式传入到这些方法中。需要注意的是，在获取节点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制 新建类ContentHandler继承自DefaultHandler 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zanecode6574.networktest;import android.util.Log;import org.xml.sax.Attributes;import org.xml.sax.SAXException;import org.xml.sax.helpers.DefaultHandler;public class ContentHandler extends DefaultHandler &#123; private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder version; @Override public void startDocument() throws SAXException &#123; id=new StringBuilder(); name=new StringBuilder(); version=new StringBuilder(); &#125; @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; //记录当前节点名 nodeName=localName; &#125; @Override public void characters(char[] ch, int start, int length) throws SAXException &#123; //根据节点名字判断将内容添加到哪一个StringBuilder中 if("id".equals(nodeName))&#123; id.append(ch,start,length); &#125;else if("name".equals(nodeName))&#123; name.append(ch,start,length); &#125;else if("version".equals(nodeName))&#123; version.append(ch,start,length); &#125; &#125; @Override public void endElement(String uri, String localName, String qName) throws SAXException &#123; if("app".equals(localName))&#123; Log.d("ContentHandler", "Id:"+id.toString().trim()+" "+"名字:"+name.toString().trim()+" "+"版本:"+version.toString().trim()); //最后要将StringBuilder清空 id.setLength(0); name.setLength(0); version.setLength(0); &#125; &#125; @Override public void endDocument() throws SAXException &#123; super.endDocument(); &#125;&#125; 我们首先给id、name和version节点分别定义了一个StringBuilder对象，并在startDocument()方法里对它们进行了初始化。每当开始解析某个节点的时候，startElement()方法就会得到调用，其中localName参数记录着当前节点的名字，这里我们把它记录下来。接着在解析节点中具体内容的时候就会调用characters()方法，我们会根据当前的节点名进行判断，将解析出的内容添加到哪一个StringBuilder对象中。最后在endElement()方法中进行判断，如果app节点已经解析完成，就打印出id、name和version的内容。需要注意的是，目前id、name和version中都可能是包括回车或换行符的，因此在打印之前我们还需要调用一下trim()方法，并且打印完成后还要将StringBuilder的内容清空掉，不然的话会影响下一次内容的读取。 修改MainActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.zanecode6574.networktest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import org.xml.sax.InputSource;import org.xml.sax.XMLReader;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserFactory;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.StringReader;import java.net.HttpURLConnection;import java.net.URL;import javax.xml.parsers.SAXParserFactory;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import static java.lang.Thread.sleep;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest=findViewById(R.id.send_request); responseText=findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if(v.getId()==R.id.send_request)&#123; sendRequestWithOkHttp(); &#125; &#125; private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url("http://10.0.2.2/get_data.xml") .build(); Response response=client.newCall(request).execute(); String responseData=response.body().string(); parseXMLWithSAX(responseData); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; responseText.setText(response); &#125; &#125;); &#125; private void parseXMLWithPull(String xmlData)&#123; try&#123; XmlPullParserFactory factory=XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser=factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlData)); int eventType=xmlPullParser.getEventType(); String id=""; String name=""; String version=""; while(eventType!=XmlPullParser.END_DOCUMENT)&#123; String nodeName=xmlPullParser.getName(); switch(eventType)&#123; //开始解析某个节点 case XmlPullParser.START_TAG:&#123; if("id".equals(nodeName))&#123; //xmlPullParser.nextText()； //如果当前事件是START_TAG，则如果下一个元素是文本，则返回元素内容；如果下一个事件是END_TAG，则返回空字符串，否则抛出异常。成功调用此函数后，解析器将定位在END_TAG上。 id=xmlPullParser.nextText(); &#125;else if("name".equals(nodeName))&#123; name=xmlPullParser.nextText(); &#125;else if("version".equals(nodeName))&#123; version=xmlPullParser.nextText(); &#125; break; &#125; //完成解析某个节点 case XmlPullParser.END_TAG:&#123; if("app".equals(nodeName))&#123; Log.d("MainActivity", "Id是:"+id+" "+"名字是:"+name+" "+"版本:"+version); &#125; break; &#125; default: break; &#125; //xmlPullParser.next()； //获取下一个解析事件。 //空元素(如)将报告两个单独的事件:START_TAG, END_TAG -必须保留空元素对的解析等价性。 //当在END_TAG调用next()时，要两次才是START_TAG。 eventType=xmlPullParser.next(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; private void parseXMLWithSAX(String xmlData)&#123; try&#123; SAXParserFactory factory=SAXParserFactory.newInstance(); XMLReader xmlReader=factory.newSAXParser().getXMLReader(); ContentHandler handler=new ContentHandler(); //将ContentHandler中的实例设置到XMLReader中 xmlReader.setContentHandler(handler); //开始解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 得到了服务器返回的数据后，我们这次去调用parseXMLWithSAX()方法来解析XML数据。parseXMLWithSAX()方法中先是创建了一个SAXParserFactory的对象，然后再获取到XMLReader对象，接着将我们编写的ContentHandler的实例设置到XMLReader中，最后调用parse()方法开始执行解析就好了。 解析JSON格式数据JSON的主要优势在于它的体积更小，在网络上传输的时候可以更省流量。但缺点在于，它的语义性较差，看起来不如XML直观。 在自己的Apache服务器根目录创建一个get_data.json文件 123[&#123;"id":"5","version":"5.5","name":"Clash of Clans"&#125;,&#123;"id":"6","version":"7.0","name":"Boom Beach"&#125;,&#123;"id":"7","version":"3.5","name":"Clash Royale"&#125;] 使用JSONObject解析JSON数据也有很多种方法，可以使用官方提供的JSONObject，也可以使用谷歌的开源库GSON。另外，一些第三方的开源库如Jackson、FastJSON等也非常不错。 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.zanecode6574.networktest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import org.json.JSONArray;import org.json.JSONObject;import org.xml.sax.InputSource;import org.xml.sax.XMLReader;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserFactory;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.StringReader;import java.net.HttpURLConnection;import java.net.URL;import javax.xml.parsers.SAXParserFactory;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import static java.lang.Thread.sleep;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest=findViewById(R.id.send_request); responseText=findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if(v.getId()==R.id.send_request)&#123; sendRequestWithOkHttp(); &#125; &#125; private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url("http://10.0.2.2/get_data.json") .build(); Response response=client.newCall(request).execute(); String responseData=response.body().string(); //parseXMLWithSAX(responseData); parseJSONWithJSONObject(responseData); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; responseText.setText(response); &#125; &#125;); &#125; private void parseXMLWithPull(String xmlData)&#123; try&#123; XmlPullParserFactory factory=XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser=factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlData)); int eventType=xmlPullParser.getEventType(); String id=""; String name=""; String version=""; while(eventType!=XmlPullParser.END_DOCUMENT)&#123; String nodeName=xmlPullParser.getName(); switch(eventType)&#123; //开始解析某个节点 case XmlPullParser.START_TAG:&#123; if("id".equals(nodeName))&#123; //xmlPullParser.nextText()； //如果当前事件是START_TAG，则如果下一个元素是文本，则返回元素内容；如果下一个事件是END_TAG，则返回空字符串，否则抛出异常。成功调用此函数后，解析器将定位在END_TAG上。 id=xmlPullParser.nextText(); &#125;else if("name".equals(nodeName))&#123; name=xmlPullParser.nextText(); &#125;else if("version".equals(nodeName))&#123; version=xmlPullParser.nextText(); &#125; break; &#125; //完成解析某个节点 case XmlPullParser.END_TAG:&#123; if("app".equals(nodeName))&#123; Log.d("MainActivity", "Id是:"+id+" "+"名字是:"+name+" "+"版本:"+version); &#125; break; &#125; default: break; &#125; //xmlPullParser.next()； //获取下一个解析事件。 //空元素(如)将报告两个单独的事件:START_TAG, END_TAG -必须保留空元素对的解析等价性。 //当在END_TAG调用next()时，要两次才是START_TAG。 eventType=xmlPullParser.next(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; private void parseXMLWithSAX(String xmlData)&#123; try&#123; SAXParserFactory factory=SAXParserFactory.newInstance(); XMLReader xmlReader=factory.newSAXParser().getXMLReader(); ContentHandler handler=new ContentHandler(); //将ContentHandler中的实例设置到XMLReader中 xmlReader.setContentHandler(handler); //开始解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; private void parseJSONWithJSONObject(String jsonData)&#123; try&#123; JSONArray jsonArray=new JSONArray(jsonData); for(int i=0;i&lt;jsonArray.length();i++)&#123; JSONObject jsonObject=jsonArray.getJSONObject(i); String id=jsonObject.getString("id"); String name=jsonObject.getString("name"); String version=jsonObject.getString("version"); Log.d("MainActivity", "Id是:"+id+" "+"名字是:"+name+" "+"版本:"+version); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 在得到了服务器返回的数据后调用parseJSONWithJSONObject()方法来解析数据。可以看到，解析JSON的代码真的非常简单，由于我们在服务器中定义的是一个JSON数组，因此这里首先是将服务器返回的数据传入到了一个JSONArray对象中。然后循环遍历这个JSONArray，从中取出的每一个元素都是一个JSONObject对象，每个JSONObject对象中又会包含id、name和version这些数据。接下来只需要调用getString()方法将这些数据取出，并打印出来即可。 个人感觉这个要简单得多，由于初学，暂时不知道两种方法实际运用的优缺点 使用GSONGSON简介谷歌提供的GSON开源库可以让解析JSON数据的工作简单到让你不敢想象的地步 项目地址:https://github.com/google/gson 添加依赖库 1implementation 'com.google.code.gson:gson:2.8.5' 书上最新的是2.7，这里我去看到是2.8.5 它主要就是可以将一段JSON格式的字符串自动映射成一个对象，从而不需要我们再手动去编写代码进行解析了。比如说一段JSON格式的数据如下所示：{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20},那我们就可以定义一个Person类，并加入name和age这两个字段，然后只需简单地调用如下代码就可以将JSON数据自动解析成一个Person对象了： 12Gson gson = new Gson();Person person = gson.fromJson(jsonData, Person.class); 如果需要解析的是一段JSON数组会稍微麻烦一点，我们需要借助TypeToken将期望解析成的数据类型传入到fromJson()方法中，如下所示： 1List&lt;Person&gt; people = gson.fromJson(jsonData, new TypeToken&lt;List&lt;Person&gt;&gt;() &#123;&#125;.getType()); 使用 新建一个App类 12345678910111213141516171819202122232425262728293031package com.zanecode6574.networktest;public class App &#123; private String id; private String name; private String version; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getVersion() &#123; return version; &#125; public void setVersion(String version) &#123; this.version = version; &#125;&#125; 修改MainActivity的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183package com.zanecode6574.networktest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import com.google.gson.Gson;import com.google.gson.reflect.TypeToken;import org.json.JSONArray;import org.json.JSONObject;import org.xml.sax.InputSource;import org.xml.sax.XMLReader;import org.xmlpull.v1.XmlPullParser;import org.xmlpull.v1.XmlPullParserFactory;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.StringReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.List;import javax.xml.parsers.SAXParserFactory;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import static java.lang.Thread.sleep;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest=findViewById(R.id.send_request); responseText=findViewById(R.id.response_text); sendRequest.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if(v.getId()==R.id.send_request)&#123; sendRequestWithOkHttp(); &#125; &#125; private void sendRequestWithOkHttp()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url("http://10.0.2.2/get_data.json") .build(); Response response=client.newCall(request).execute(); String responseData=response.body().string(); //parseXMLWithSAX(responseData); //parseJSONWithJSONObject(responseData); parseJSONWithGSON(responseData); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; private void showResponse(final String response)&#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; responseText.setText(response); &#125; &#125;); &#125; private void parseXMLWithPull(String xmlData)&#123; try&#123; XmlPullParserFactory factory=XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser=factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlData)); int eventType=xmlPullParser.getEventType(); String id=""; String name=""; String version=""; while(eventType!=XmlPullParser.END_DOCUMENT)&#123; String nodeName=xmlPullParser.getName(); switch(eventType)&#123; //开始解析某个节点 case XmlPullParser.START_TAG:&#123; if("id".equals(nodeName))&#123; //xmlPullParser.nextText()； //如果当前事件是START_TAG，则如果下一个元素是文本，则返回元素内容；如果下一个事件是END_TAG，则返回空字符串，否则抛出异常。成功调用此函数后，解析器将定位在END_TAG上。 id=xmlPullParser.nextText(); &#125;else if("name".equals(nodeName))&#123; name=xmlPullParser.nextText(); &#125;else if("version".equals(nodeName))&#123; version=xmlPullParser.nextText(); &#125; break; &#125; //完成解析某个节点 case XmlPullParser.END_TAG:&#123; if("app".equals(nodeName))&#123; Log.d("MainActivity", "Id是:"+id+" "+"名字是:"+name+" "+"版本:"+version); &#125; break; &#125; default: break; &#125; //xmlPullParser.next()； //获取下一个解析事件。 //空元素(如)将报告两个单独的事件:START_TAG, END_TAG -必须保留空元素对的解析等价性。 //当在END_TAG调用next()时，要两次才是START_TAG。 eventType=xmlPullParser.next(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; private void parseXMLWithSAX(String xmlData)&#123; try&#123; SAXParserFactory factory=SAXParserFactory.newInstance(); XMLReader xmlReader=factory.newSAXParser().getXMLReader(); ContentHandler handler=new ContentHandler(); //将ContentHandler中的实例设置到XMLReader中 xmlReader.setContentHandler(handler); //开始解析 xmlReader.parse(new InputSource(new StringReader(xmlData))); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; private void parseJSONWithJSONObject(String jsonData)&#123; try&#123; JSONArray jsonArray=new JSONArray(jsonData); for(int i=0;i&lt;jsonArray.length();i++)&#123; JSONObject jsonObject=jsonArray.getJSONObject(i); String id=jsonObject.getString("id"); String name=jsonObject.getString("name"); String version=jsonObject.getString("version"); Log.d("MainActivity", "Id是:"+id+" "+"名字是:"+name+" "+"版本:"+version); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; private void parseJSONWithGSON(String jsonData)&#123; Gson gson=new Gson(); List&lt;App&gt; appList=gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType()); for(App app:appList)&#123; Log.d("MainActivity", "Id是:"+app.getId()+" "+"名字是:"+app.getName()+" "+"版本:"+app.getVersion()); &#125; &#125;&#125; 网络编程实践一个应用程序很可能会在许多地方都使用到网络功能，而发送HTTP请求的代码基本都是相同的，如果我们每次都去编写一遍发送HTTP请求的代码，这显然是非常差劲的做法。 通常情况下我们都应该将这些通用的网络操作提取到一个公共的类里，并提供一个静态方法，当想要发起网络请求的时候，只需简单地调用一下这个方法即可。 HttpURLConnection写法 HttpUtil类 12345678910111213141516171819202122232425262728293031323334353637package com.zanecode6574.networktest;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpUtil &#123; public static String sendHttpRequest(String address) &#123; HttpURLConnection connection = null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; return response.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); return e.getMessage(); &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125;&#125; 要发起HTTP请求的时候 12String address = "http://www.baidu.com";String response = HttpUtil.sendHttpRequest(address); 缺点：网络请求通常都是耗时操作，但是sendHttpRequest()方法的内部并没有开启线程，这样就有可能导致在调用sendHttpRequest()方法的时候使得主线程被阻塞住。但是如果我们在sendHttpRequest()方法中开启了一个线程来发起HTTP请求，那么服务器响应的数据是无法进行返回的，所有的耗时逻辑都是在子线程里进行的，sendHttpRequest()方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据了。 解决办法：使用Java回调机制 定义一个接口，比如命名为HttpCallbackListener 1234public interface HttpCallbackListener &#123; void onFinish(String response); void onError(Exception e);&#125; onFinish()方法表示当服务器成功响应我们请求的时候调用，onError()表示当进行网络操作出现错误的时候调用。这两个方法都带有参数，onFinish()方法中的参数代表着服务器返回的数据，而onError()方法中的参数记录着错误的详细信息。 修改HttpUtil代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zanecode6574.networktest;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpUtil &#123; public static void sendHttpRequest(final String address, final HttpCallbackListener listener) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader (in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; if (listener != null) &#123; // 回调onFinish()方法 listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; if (listener != null) &#123; // 回调onError()方法 listener.onError(e); &#125; &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; public interface HttpCallbackListener &#123; void onFinish(String response); void onError(Exception e); &#125;&#125; 首先给sendHttpRequest()方法添加了一个HttpCallbackListener参数，并在方法的内部开启了一个子线程，然后在子线程里去执行具体的网络操作。注意，子线程中是无法通过return语句来返回数据的，因此这里我们将服务器响应的数据传入了HttpCallbackListener的onFinish()方法中，如果出现了异常就将异常原因传入到onError()方法中。 现在sendHttpRequest()方法接收两个参数了，因此我们在调用它的时候还需要将HttpCallbackListener的实例传入，如下所示： 12345678910HttpUtil.sendHttpRequest(address, new HttpCallbackListener() &#123; @Override public void onFinish(String response) &#123; // 在这里根据返回内容执行具体的逻辑 &#125; @Override public void onError(Exception e) &#123; // 在这里对异常情况进行处理 &#125;&#125;); 这样的话，当服务器成功响应的时候，我们就可以在onFinish()方法里对响应数据进行处理了。类似地，如果出现了异常，就可以在onError()方法里对异常情况进行处理。如此一来，我们就巧妙地利用回调机制将响应数据成功返回给调用方了。 OkHttp写法 在HttpUtil中加入一个sendOkHttpRequest()方法 1234567public static void sendOkHttpRequest(String address, okhttp3.Callback callback) &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback);&#125; sendOkHttpRequest()方法中有一个okhttp3．Callback参数，这个是OkHttp库中自带的一个回调接口，类似于我们刚才自己编写的HttpCallbackListener。然后在client.newCall()之后没有像之前那样一直调用execute()方法，而是调用了一个enqueue()方法，并把okhttp3．Callback参数传入。相信聪明的你已经猜到了，OkHttp在enqueue()方法的内部已经帮我们开好子线程了，然后会在子线程中去执行HTTP请求，并将最终的请求结果回调到okhttp3．Callback当中。 调用方法 1234567891011HttpUtil.sendOkHttpRequest("http://www.baidu.com", new okhttp3．Callback() &#123; @Override public void onResponse(Call call, Response response) throws IOException &#123; // 得到服务器返回的具体内容 String responseData = response.body().string(); &#125; @Override public void onFailure(Call call, IOException e) &#123; // 在这里对异常情况进行处理 &#125;&#125;); OkHttp的接口设计得确实非常人性化，它将一些常用的功能进行了很好的封装，使得我们只需编写少量的代码就能完成较为复杂的网络操作。 不管是HttpURLConnection还是OkHttp，最终的回调接口都是在子线程中运行的，因此我们不能在这里执行任何的UI操作，除非借助runOnUiThread()来进行线程转换]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>WebView</tag>
        <tag>HttpURLConnection</tag>
        <tag>OkHttp</tag>
        <tag>XML</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章：丰富你的程序-运用手机多媒体]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E4%B8%B0%E5%AF%8C%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8F-%E8%BF%90%E7%94%A8%E6%89%8B%E6%9C%BA%E5%A4%9A%E5%AA%92%E4%BD%93%2F</url>
    <content type="text"><![CDATA[简介 这章用的是实体安卓机器，打开开发者调试选项 包含了通知的用法、调用摄像头拍照、调用相册选择照片、播放音频、播放视频 使用通知通知（Notification）是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。发出一条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。Android的通知功能获得了大量用户的认可和喜爱，就连iOS系统也在5.0版本之后加入了类似的功能。 通知的基本用法通知的用法还是比较灵活的，既可以在活动里创建，也可以在广播接收器里创建，当然还可以在下一章中即将学习的服务里创建。相比于广播接收器和服务，在活动里创建通知的场景还是比较少的，因为一般只有当程序进入到后台的时候我们才需要使用通知。 通知的用法还是比较灵活的，既可以在活动里创建，也可以在广播接收器里创建，当然还可以在下一章中我们即将学习的服务里创建。相比于广播接收器和服务，在活动里创建通知的场景还是比较少的，因为一般只有当程序进入到后台的时候我们才需要使用通知。 获取NotificationManager的实例 1NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); 使用一个Builder构造器来创建Notification对象（但问题在于，几乎Android系统的每一个版本都会对通知这部分功能进行或多或少的修改，API不稳定性问题在通知上面突显得尤其严重。那么该如何解决这个问题呢？其实解决方案我们之前已经见过好几回了，就是使用support库中提供的兼容API。support-v4库中提供了一个NotificationCompat类，使用这个类的构造器来创建Notification对象，就可以保证我们的程序在所有Android系统版本上都能正常工作了） 1Notification notification = new NotificationCompat.Builder(context).build(); 我们可以在最终的build()方法之前连缀任意多的设置方法来创建一个丰富的Notification对象，先来看一些最基本的设置 12345678Notification notification = new NotificationCompat.Builder(context).setContentTitle("This is content title").setContentText("This is content text").setWhen(System.currentTimeMillis()).setSmallIcon(R.drawable.small_icon).setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.large_icon)).build(); 这里一共五个设置方法 setContentTitle()方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。 setContentText()方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。 setWhen()方法用于指定通知被创建的时间，以毫秒为单位，当下拉系统状态栏时，这里指定的时间会显示在相应的通知上。 setSmallIcon()方法用于设置通知的小图标，注意只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上。 setLargeIcon()方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。 以上工作都完成之后，只需要调用NotificationManager的notify()方法就可以让通知显示出来了。notify()方法接收两个参数，第一个参数是id，要保证为每个通知所指定的id都是不同的。第二个参数则是Notification对象，这里直接将我们刚刚创建好的Notification对象传入即可。因此，显示一个通知就可以写成：manager.notify(1, notification); 新建NotificationTest项目 添加一个发送通知的按钮 修改MainActivity中的代码 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendNotice=findViewById(R.id.send_notice); sendNotice.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.send_notice: NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification=new NotificationCompat.Builder(this) .setContentTitle("这是通知标题") .setContentText("这是通知内容") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .build(); manager.notify(1,notification); break; default: break; &#125; &#125;&#125; 这里设置按钮点击事件的代码用的另外一种，跟之前的不一样，但是好像NotificationCompat在高版本的安卓中已经弃用了，这里留起来等学完了回来更新,书上说这种写法是通用的。 给通知添加点击事件上面创建的通知是无法点击的，要实现点击事件，涉及到新的概念：PendingIntent PendingIntent从名字上看起来就和Intent有些类似，它们之间也确实存在着不少共同点。比如它们都可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等。不同的是，Intent更加倾向于去立即执行某个动作，而PendingIntent更加倾向于在某个合适的时机去执行某个动作。所以，也可以把PendingIntent简单地理解为延迟执行的Intent。 PendingIntent的用法同样很简单，它主要提供了几个静态方法用于获取PendingIntent的实例，可以根据需求来选择是使用getActivity()方法、getBroadcast()方法，还是getService()方法。这几个方法所接收的参数都是相同的，第一个参数依旧是Context，不用多做解释。第二个参数一般用不到，通常都是传入0即可。第三个参数是一个Intent对象，我们可以通过这个对象构建出PendingIntent的“意图”。第四个参数用于确定PendingIntent的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT这4种值可选，每种值的具体含义可以查看文档，通常情况下这个参数传入0就可以了。 对PendingIntent有了一定的了解后，我们再回过头来看一下NotificationCompat.Builder。这个构造器还可以再连缀一个setContentIntent()方法，接收的参数正是一个PendingIntent对象。因此，这里就可以通过PendingIntent构建出一个延迟执行的“意图”，当用户点击这条通知时就会执行相应的逻辑。 添加活动NotificationActivity 修改activity_notification.xml的代码 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".NotificationActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:textSize="24sp" android:text="这是通知的布局!" /&gt;&lt;/RelativeLayout&gt; 修改MainActivity的代码 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendNotice=findViewById(R.id.send_notice); sendNotice.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch(v.getId())&#123; case R.id.send_notice: Intent intent=new Intent(this,NotificationActivity.class); PendingIntent pi=PendingIntent.getActivity(this,0,intent,0); NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE); Notification notification=new NotificationCompat.Builder(this) .setContentTitle("这是通知标题") .setContentText("这是通知内容") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); manager.notify(1,notification); break; default: break; &#125; &#125;&#125; 先是使用Intent表达出我们想要启动NotificationActivity的“意图”，然后将构建好的Intent对象传入到PendingIntent的getActivity()方法里，以得到PendingIntent的实例，接着在NotificationCompat.Builder中调用setContentIntent()方法，把它作为参数传入即可。 此时，点击通知就会启动刚才创建的活动，但是通知不会消失，解决方法 方法1: 1234Notification notification = new NotificationCompat.Builder(this)....setAutoCancel(true).build(); 方法2 : 123456789public class NotificationActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.notification_layout); NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); manager.cancel(1); &#125;&#125; 在这种方法中，calcel()方法中传入1意思是这条通知的id，是我们发送通知的时候传入的，取消哪条就传入哪条就行了 通知进阶技巧让通知播放音乐 setSound()方法:setSound()方法接收一个Uri参数，所以在指定音频文件的时候还需要先获取到音频文件对应的URI。比如说，每个手机的/system/media/audio/ringtones目录下都有很多的音频文件，我们可以从中随便选一个音频文件. 1234Notification notification = new NotificationCompat.Builder(this)....setSound(Uri.fromFile(new File("/system/media/audio/ringtones/Luna.ogg"))).build(); 让通知控制手机震动 setVibrate()方法:使用的是vibrate这个属性。它是一个长整型的数组，用于设置手机静止和振动的时长，以毫秒为单位。下标为0的值表示手机静止的时长，下标为1的值表示手机振动的时长，下标为2的值又表示手机静止的时长，以此类推。 1234Notification notification = new NotificationCompat.Builder(this)....setVibrate(new long[] &#123;0, 1000, 1000, 1000 &#125;).build(); 手机在通知到来的时候立刻振动1秒，然后静止1秒，再振动1秒 让手机震动得申明权限&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; 让通知控制LED灯闪烁 setLights()方法:控制手机LED灯的显示，setLights()方法接收3个参数，第一个参数用于指定LED灯的颜色，第二个参数用于指定LED灯亮起的时长，以毫秒为单位，第三个参数用于指定LED灯暗去的时长，也是以毫秒为单位 1234Notification notification = new NotificationCompat.Builder(this)....setLights(Color.GREEN, 1000, 1000).build(); 实现LED灯以绿色的灯光一闪一闪的效果 使用默认效果通知 使用通知的默认效果，它会根据手机当前的环境来决定播放什么铃声 1234Notification notification = new NotificationCompat.Builder(this)....setDefaults(NotificationCompat.DEFAULT_ALL).build(); 通知的高级功能NotificationCompat.Builder这个类中还有很多高级API还没使用过 setStyle()方法让通知显示更多文字 setStyle()方法：构建出更丰富的通知，除了文字和图标以外的东西.setStyle()方法接收一个NotificationCompat.Style参数，这个参数就是用来构建具体的富文本信息的，如长文字、图片等。 123456Notification notification = new NotificationCompat.Builder(this)....setStyle(new NotificationCompat.BigTextStyle().bigText("Learn how to buildnotifications, send and sync data, and use voice actions. Get the officialAndroid IDE and developer tools to build apps for Android.")).build(); 让通知显示更多的字而不被省略，在setStyle()方法中创建了一个NotificationCompat.BigTextStyle对象，这个对象就是用于封装长文字信息的，我们调用它的bigText()方法并将文字内容传入就可以了。 通知添加大图12345Notification notification = new NotificationCompat.Builder(this)....setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.big_image))).build(); 在参数中创建了一个NotificationCompat.BigPictureStyle对象，这个对象就是用于设置大图片的，然后调用它的bigPicture()方法并将图片传入。这里我事先准备好了一张图片，通过BitmapFactory的decodeResource()方法将图片解析成Bitmap对象，再传入到bigPicture()方法中就可以了。 经测试，如果同时设置很多文字和图片，只会有后面的那个生效 setPriority()方法 setPriority()方法接收一个整型参数用于设置这条通知的重要程度，一共有5个常量值可选：PRIORITY_DEFAULT表示默认的重要程度，和不设置效果是一样的；PRIORITY_MIN表示最低的重要程度，系统可能只会在特定的场景才显示这条通知，比如用户下拉状态栏的时候；PRIORITY_LOW表示较低的重要程度，系统可能会将这类通知缩小，或改变其显示的顺序，将其排在更重要的通知之后；PRIORITY_HIGH表示较高的重要程度，系统可能会将这类通知放大，或改变其显示的顺序，将其排在比较靠前的位置；PRIORITY_MAX表示最高的重要程度，这类通知消息必须要让用户立刻看到，甚至需要用户做出响应操作。 书上设置为Max会出现通知横幅，但是我测试没有出现，可能是代码哪里错了，并且在安卓9上面无法发出通知，应该是方法比较旧了，留着后来更新 调用摄像头和相册调用摄像头拍照 新建CameraAlbumTest项目 编辑activity_main.xml文件，添加一个按钮和一个ImageView控件 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/take_photo" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="拍照"/&gt; &lt;ImageView android:id="@+id/picture" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal"/&gt;&lt;/LinearLayout&gt; 修改MainActivity代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MainActivity extends AppCompatActivity &#123; private static final int TAKE_PHOTO=1; private ImageView picture; private Uri imageUri; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button takePhoto=findViewById(R.id.take_photo); picture=findViewById(R.id.picture); takePhoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //创建FIle对象用于储存拍照后的照片 File outputImage=new File(getExternalCacheDir(),"output_image.jpg"); try&#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri=FileProvider.getUriForFile(MainActivity.this,"com.zanecode6574.cameraalbumtest.fileprovider",outputImage); &#125;else&#123; imageUri=Uri.fromFile(outputImage); &#125; //启动相机 Intent intent=new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); //将照片显示出来 &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; switch(requestCode)&#123; case TAKE_PHOTO: if(resultCode==RESULT_OK)&#123; try&#123; Bitmap bitmap=BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); picture.setImageBitmap(bitmap); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; &#125; break; default: break; &#125; super.onActivityResult(requestCode, resultCode, data); &#125;&#125; MainActivity中要做的第一件事自然是分别获取到Button和ImageView的实例，并给Button注册上点击事件，然后在Button的点击事件里开始处理调用摄像头的逻辑，我们重点看一下这部分代码。 首先这里创建了一个File对象，用于存放摄像头拍下的图片，这里我们把图片命名为output_image.jpg，并将它存放在手机SD卡的应用关联缓存目录下。什么叫作应用关联缓存目录呢？就是指SD卡中专门用于存放当前应用缓存数据的位置，调用getExternalCacheDir()方法可以得到这个目录，具体的路径是/sdcard/Android/data//cache。那么为什么要使用应用关联缓目录来存放图片呢？因为从Android 6.0系统开始，读写SD卡被列为了危险权限，如果将图片存放在SD卡的任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步。 接着会进行一个判断，如果运行设备的系统版本低于Android 7.0，就调用Uri的fromFile()方法将File对象转换成Uri对象，这个Uri对象标识着output_image.jpg这张图片的本地真实路径。否则，就调用FileProvider的getUriForFile()方法将File对象转换成一个封装过的Uri对象。getUriForFile()方法接收3个参数，第一个参数要求传入Context对象，第二个参数可以是任意唯一的字符串，第三个参数则是我们刚刚创建的File对象。之所以要进行这样一层转换，是因为从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出一个FileUriExposedException异常。而FileProvider则是一种特殊的内容提供器，它使用了和内容提供器类似的机制来对数据进行保护，可以选择性地将封装过的Uri共享给外部，从而提高了应用的安全性。 接下来构建出了一个Intent对象，并将这个Intent的action指定为android.media.action.IMAGE_CAPTURE，再调用Intent的putExtra()方法指定图片的输出地址，这里填入刚刚得到的Uri对象，最后调用startActivityForResult()来启动活动。由于我们使用的是一个隐式Intent，系统会找出能够响应这个Intent的活动去启动，这样照相机程序就会被打开，拍下的照片将会输出到output_image.jpg中。 刚才我们是使用startActivityForResult()来启动活动的，因此拍完照后会有结果返回到onActivityResult()方法中。如果发现拍照成功，就可以调用BitmapFactory的decodeStream()方法将output_image.jpg这张照片解析成Bitmap对象，然后把它设置到ImageView中显示出来。 右击res目录→New→Directory，创建一个xml目录，接着右击xml目录→New→File，创建一个file_paths.xml文件 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="" /&gt;&lt;/paths&gt; 修改AndroidManifest.xml注册内容提供器 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.zanecode6574.cameraalbumtest"&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.zanecode6574.cameraalbumtest.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"/&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 这里发现Android Studio的模拟器十分好用，相机的问题也有解决会直接给你一个场景，避免了虚拟机没有相机的尴尬情况 从相册选择照片 添加一个选择照片的按钮 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.zanecode6574.cameraalbumtest;import android.Manifest;import android.annotation.TargetApi;import android.app.Activity;import android.content.ContentUris;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.FileProvider;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; private static final int TAKE_PHOTO=1; public static final int CHOOSE_PHOTO=2; private ImageView picture; private Uri imageUri; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button takePhoto=findViewById(R.id.take_photo); picture=findViewById(R.id.picture); takePhoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //创建FIle对象用于储存拍照后的照片 File outputImage=new File(getExternalCacheDir(),"output_image.jpg"); try&#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri=FileProvider.getUriForFile(MainActivity.this,"com.zanecode6574.cameraalbumtest.fileprovider",outputImage); &#125;else&#123; imageUri=Uri.fromFile(outputImage); &#125; //启动相机 Intent intent=new Intent("android.media.action.IMAGE_CAPTURE"); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); Button chooseFromAlbum=findViewById(R.id.choose_from_album); chooseFromAlbum.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; switch(requestCode)&#123; case TAKE_PHOTO: if(resultCode==RESULT_OK)&#123; try&#123; Bitmap bitmap=BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri)); picture.setImageBitmap(bitmap); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; &#125; break; case CHOOSE_PHOTO: if(resultCode==RESULT_OK)&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT&gt;=19)&#123; //4.4及以上系统用这个方法处理 handleImageOnKitKat(data); &#125;else&#123; handleImageBeforeKitKat(data); &#125; &#125; break; default: break; &#125; super.onActivityResult(requestCode, resultCode, data); &#125; @TargetApi(19) private void handleImageOnKitKat(Intent data)&#123; String imagePath=null; Uri uri=data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; //如果是document类型的Uri，则通过document id处理 String docId=DocumentsContract.getDocumentId(uri); if("com.android.providers.media.documents".equals(uri.getAuthority()))&#123; String id=docId.split(":")[1]; //解析出数字格式的id String selection=MediaStore.Images.Media._ID+"="+id; imagePath=getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if("com.android.providers.downloads.documents".equals(uri.getAuthority()))&#123; Uri contentUri=ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"),Long.valueOf(docId)); imagePath=getImagePath(contentUri,null); &#125; &#125;else if("content".equalsIgnoreCase(uri.getScheme()))&#123; //如果是content类型的Uri imagePath=getImagePath(uri,null); &#125;else if("file".equalsIgnoreCase(uri.getScheme()))&#123; imagePath=uri.getPath(); &#125; displayImage(imagePath); &#125; private void handleImageBeforeKitKat(Intent data)&#123; Uri uri=data.getData(); String imagePath=getImagePath(uri,null); displayImage(imagePath); &#125; private String getImagePath(Uri uri,String selection)&#123; String path=null; //通过Uri和selection来获取真实的图片路径 Cursor cursor=getContentResolver().query(uri,null,selection,null,null); if(cursor!=null)&#123; if(cursor.moveToFirst())&#123; path=cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath)&#123; if(imagePath!=null)&#123; Bitmap bitmap=BitmapFactory.decodeFile(imagePath); picture.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this, "获取图片失败", Toast.LENGTH_SHORT).show(); &#125; &#125; private void openAlbum()&#123; Intent intent=new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent,CHOOSE_PHOTO); //打开相册 &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length&gt;0 &amp;&amp; grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else&#123; Toast.makeText(this, "权限被拒绝", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125; &#125;&#125; 在Choose From Album按钮的点击事件里我们先是进行了一个运行时权限处理，动态申请WRITE_EXTERNAL_STORAGE这个危险权限。为什么需要申请这个权限呢？因为相册中的照片都是存储在SD卡上的，我们要从SD卡中读取照片就需要申请这个权限。WRITE_EXTERNAL_STORAGE表示同时授予程序对SD卡读和写的能力。 当用户授权了权限申请之后会调用openAlbum()方法，这里我们先是构建出了一个Intent对象，并将它的action指定为android.intent.action.GET_CONTENT。接着给这个Intent对象设置一些必要的参数，然后调用startActivityForResult()方法就可以打开相册程序选择照片了。注意在调用startActivityForResult()方法的时候，我们给第二个参数传入的值变成了CHOOSE_PHOTO，这样当从相册选择完图片回到onActivityResult()方法时，就会进入CHOOSE_PHOTO的case来处理图片。 接下来的逻辑就比较复杂了，首先为了兼容新老版本的手机，我们做了一个判断，如果是4.4及以上系统的手机就调用handleImageOnKitKat()方法来处理图片，否则就调用handleImageBeforeKitKat()方法来处理图片。之所以要这样做，是因为Android系统从4.4版本开始，选取相册中的图片不再返回图片真实的Uri了，而是一个封装过的Uri，因此如果是4.4版本以上的手机就需要对这个Uri进行解析才行。 handleImageOnKitKat()方法中的逻辑就基本是如何解析这个封装过的Uri了。这里有好几种判断情况，如果返回的Uri是document类型的话，那就取出document id进行处理，如果不是的话，那就使用普通的方式处理。另外，如果Uri的authority是media格式的话，document id还需要再进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字id。取出的id用于构建新的Uri和条件语句，然后把这些值作为参数传入到getImagePath()方法当中，就可以获取到图片的真实路径了。拿到图片的路径之后，再调用displayImage()方法将图片显示到界面上。 相比于handleImageOnKitKat()方法，handleImageBeforeKitKat()方法中的逻辑就要简单得多了，因为它的Uri是没有封装过的，不需要任何解析，直接将Uri传入到getImagePath()方法当中就能获取到图片的真实路径了，最后同样是调用displayImage()方法来让图片显示到界面上。 缺点：目前的方式，即使照片经过裁剪，但是还是会很大，直接加载到内存中可能会导致崩溃，更好的办法是先对照片进行适当的压缩再加载到内存中。 播放音频在Android中播放音频文件一般都是使用MediaPlayer类来实现的，它对多种格式的音频文件提供了非常全面的控制方法，从而使得播放音乐的工作变得十分简单。下表列出了MediaPlayer类中一些较为常用的控制方法。 首先需要创建出一个MediaPlayer对象，然后调用setDataSource()方法来设置音频文件的路径，再调用prepare()方法使MediaPlayer进入到准备状态，接下来调用start()方法就可以开始播放音频，调用pause()方法就会暂停播放，调用reset()方法就会停止播放。 新建一个PlayAudioTest项目 修改activity_main.xml中的代码，添加三个按钮，播放、暂停、停止 在模拟器的SD卡更目录放一个名字为music.mp3的音乐文件 修改MainActivity的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.zanecode6574.playaudiotest;import android.Manifest;import android.content.pm.PackageManager;import android.media.MediaPlayer;import android.os.Environment;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;import java.io.File;import java.io.IOException;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private MediaPlayer mediaPlayer=new MediaPlayer(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button play=findViewById(R.id.play); Button pause=findViewById(R.id.pause); Button stop=findViewById(R.id.stop); play.setOnClickListener(this); pause.setOnClickListener(this); stop.setOnClickListener(this); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; initMediaPlayer(); //初始化MediaPlayer &#125; &#125; private void initMediaPlayer()&#123; try&#123; File file=new File(Environment.getExternalStorageDirectory(),"music.mp3"); mediaPlayer.setDataSource(file.getPath()); mediaPlayer.prepare(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch(requestCode)&#123; case 1: if(grantResults.length&gt;0 &amp;&amp; grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; initMediaPlayer(); &#125;else&#123; Toast.makeText(this, "拒绝权限将无法使用程序", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.play: if(!mediaPlayer.isPlaying())&#123; mediaPlayer.start(); &#125; break; case R.id.pause: if(mediaPlayer.isPlaying())&#123; mediaPlayer.pause(); &#125; break; case R.id.stop: if(mediaPlayer.isPlaying())&#123; mediaPlayer.stop(); initMediaPlayer(); &#125; break; default: break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mediaPlayer!=null)&#123; mediaPlayer.stop(); mediaPlayer.release(); &#125; &#125;&#125; 在类初始化的时候我们就先创建了一个MediaPlayer的实例，然后在onCreate()方法中进行了运行时权限处理，动态申请WRITE_EXTERNAL_STORAGE权限。这是由于待会我们会在SD卡中放置一个音频文件，程序为了播放这个音频文件必须拥有访问SD卡的权限才行。注意，在onRequestPermissionsResult()方法中，如果用户拒绝了权限申请，那么就调用finish()方法将程序直接关掉，因为如果没有SD卡的访问权限，我们这个程序将什么都干不了。 用户同意授权之后就会调用initMediaPlayer()方法为MediaPlayer对象进行初始化操作。在initMediaPlayer()方法中，首先是通过创建一个File对象来指定音频文件的路径，从这里可以看出，我们需要事先在SD卡的根目录下放置一个名为music.mp3的音频文件。后面依次调用了setDataSource()方法和prepare()方法，为MediaPlayer做好了播放前的准备。 当点击Play按钮时会进行判断，如果当前MediaPlayer没有正在播放音频，则调用start()方法开始播放。当点击Pause按钮时会判断，如果当前MediaPlayer正在播放音频，则调用pause()方法暂停播放。当点击Stop按钮时会判断，如果当前MediaPlayer正在播放音频，则调用reset()方法将MediaPlayer重置为刚刚创建的状态，然后重新调用一遍initMediaPlayer()方法。 最后在onDestroy()方法中，我们还需要分别调用stop()方法和release()方法，将与MediaPlayer相关的资源释放掉。 在AndroidManifest.xml中申明权限 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 播放视频播放视频文件其实并不比播放音频文件复杂，主要是使用VideoView类来实现的。这个类将视频的显示和控制集于一身，使得我们仅仅借助它就可以完成一个简易的视频播放器。VideoView的用法和MediaPlayer也比较类似，主要有以下常用方法 新建PlayVideo项目 修改activity_main.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center_horizontal" tools:context=".MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="center_horizontal"&gt; &lt;Button android:id="@+id/play" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="播放"/&gt; &lt;Button android:id="@+id/pause" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="暂停"/&gt; &lt;Button android:id="@+id/replay" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="恢复"/&gt; &lt;/LinearLayout&gt; &lt;VideoView android:id="@+id/video_view" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 修改MainActivity中的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.zanecode6574.videoplayer;import android.Manifest;import android.content.pm.PackageManager;import android.os.Environment;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;import android.widget.VideoView;import java.io.File;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private VideoView videoView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button play=findViewById(R.id.play); Button pause=findViewById(R.id.pause); Button replay=findViewById(R.id.replay); videoView=findViewById(R.id.video_view); play.setOnClickListener(this); pause.setOnClickListener(this); replay.setOnClickListener(this); if(ContextCompat.checkSelfPermission(MainActivity.this,Manifest.permission.WRITE_EXTERNAL_STORAGE)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; initVideoPath(); //初始化VideoView &#125; &#125; private void initVideoPath()&#123; File file=new File(Environment.getExternalStorageDirectory(),"movie.mp4"); videoView.setVideoPath(file.getPath()); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch(requestCode)&#123; case 1: if(grantResults.length&gt;0 &amp;&amp; grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; initVideoPath(); &#125;else&#123; Toast.makeText(this, "拒绝将无法使用应用!", Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: break; &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.play: if(!videoView.isPlaying())&#123; videoView.start(); &#125; break; case R.id.pause: if(videoView.isPlaying())&#123; videoView.pause(); &#125; break; case R.id.replay: if(videoView.isPlaying())&#123; videoView.resume(); &#125; break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(videoView!=null)&#123; videoView.suspend(); &#125; &#125;&#125; 在SD卡根目录放一个名字为movie.mp4的视频文件 在AndroidManifest.xml中申明权限 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章：跨程序共享数据-探究内容提供器]]></title>
    <url>%2F2019%2F01%2F20%2F%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%B7%A8%E7%A8%8B%E5%BA%8F%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-%E6%8E%A2%E7%A9%B6%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[内容提供器简介Android数据持久化的技术，包括文件存储、SharedPreferences存储以及数据库存储。但是使用这些持久化技术所保存的数据都只能在当前应用程序中访问。虽然文件和SharedPreferences存储中提供了MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE这两种操作模式，用于供给其他的应用程序访问当前应用的数据，但这两种模式在Android 4.2版本中都已被废弃了，Android官方已经不再推荐使用这种方式来实现跨程序数据共享的功能，而是应该使用更加安全可靠的内容提供器技术。 内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。目前，使用内容提供器是Android实现跨程序共享数据的标准方式。 内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。目前，使用内容提供器是Android实现跨程序共享数据的标准方式。 运行时权限简介Android的权限机制并不是什么新鲜事物，从系统的第一个版本开始就已经存在了。但其实之前Android的权限机制在保护用户安全和隐私等方面起到的作用比较有限，尤其是一些大家都离不开的常用软件，非常容易“店大欺客”。为此，Android开发团队在Android 6.0系统中引用了运行时权限这个功能，从而更好地保护了用户的安全和隐私。 Android权限机制详解安卓程序在AndroidManifest.xml中加入权限申明，在安装程序时相应的权限就会在安装界面显示出来，用户接受就安装，不接受就不安装（但是国内好像不存在这种情况，多数大应用都是管它的，申请了再说）。 Android开发团队当然也意识到了这个问题，于是在6.0系统中加入了运行时权限功能。也就是说，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。比如说一款相机应用在运行时申请了地理位置定位权限，就算我拒绝了这个权限，但是我应该仍然可以使用这个应用的其他功能，而不是像之前那样直接无法安装它。 当然，并不是所有权限都需要在运行时申请，对于用户来说，不停地授权也很烦琐。Android现在将所有的权限归成了两类，一类是普通权限，一类是危险权限。准确地讲，其实还有第三类特殊权限，不过这种权限使用得很少，因此不在本书的讨论范围之内。普通权限指的是那些不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，而不需要用户再去手动操作了，比如在BroadcastTest项目中申请的两个权限就是普通权限。危险权限则表示那些可能会触及用户隐私或者对设备安全性造成影响的权限，如获取设备联系人信息、定位设备的地理位置等，对于这部分权限申请，必须要由用户手动点击授权才可以，否则程序就无法使用相应的功能。 但是Android中有一共有上百种权限，其实危险权限总共就那么几个，除了危险权限之外，剩余的就都是普通权限了。下表列出了Android中所有的危险权限，一共是9组24个权限。 你并不需要了解表格中每个权限的作用，只要把它当成一个参照表来查看就行了。每当要使用一个权限时，可以先到这张表中来查一下，如果是属于这张表中的权限，那么就需要进行运行时权限处理，如果不在这张表中，那么只需要在AndroidManifest.xml文件中添加一下权限声明就可以了。 另外注意一下，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。 在程序运行时申请权限 新建一个RuntimePermissionTest项目,使用CALL_PHONE这个权限进行测试 在activity_main.xml布局中添加一个拨打电话的按钮 修改MainActivity的代码 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button makeCall=findViewById(R.id.make_call); makeCall.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try&#123; Intent intent=new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;catch(SecurityException e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 在按钮的点击事件中，我们构建了一个隐式Intent，Intent的action指定为Intent.ACTION_CALL，这是一个系统内置的打电话的动作，然后在data部分指定了协议是tel，号码是10086。其实这部分代码我们在2.3.3小节中就已经见过了，只不过当时指定的action是Intent.ACTION_DIAL，表示打开拨号界面，这个是不需要声明权限的，而Intent.ACTION_CALL则可以直接拨打电话，因此必须声明权限。另外为了防止程序崩溃，我们将所有操作都放在了异常捕获代码块当中。 修改AndroidManifest.xml文件,添加权限申明 1&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt; 以上代码在Android6.0以下的系统是没有问题的，但是在6.0以上，就会被禁止这个权限而无法正常工作，因为6.0以上的危险权限都要进行运行时权限处理 修改MainActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button makeCall=findViewById(R.id.make_call); makeCall.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123; Manifest.permission.CALL_PHONE &#125;,1); &#125;else&#123; call(); &#125; /* try&#123; Intent intent=new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;catch(SecurityException e)&#123; e.printStackTrace(); &#125; */ &#125; &#125;); &#125; private void call()&#123; try&#123; Intent intent=new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse("tel:10086")); startActivity(intent); &#125;catch(SecurityException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch(requestCode)&#123; case 1: if(grantResults.length&gt;0 &amp;&amp; grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; call(); &#125;else&#123; Toast.makeText(this, "权限被拒绝", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125;&#125; 这里点击拨打电话就会弹出权限申请的对话框，同意以后即可调用系统拨打电话 步骤解释 运行时权限的核心就是在程序运行过程中由用户授权我们去执行某些危险操作，程序是不可以擅自做主去执行这些危险操作的。因此，第一步就是要先判断用户是不是已经给过我们授权了，借助的是ContextCompat.checkSelfPermission()方法。checkSelfPermission()方法接收两个参数，第一个参数是Context，这个没什么好说的，第二个参数是具体的权限名，比如打电话的权限名就是Manifest.permission.CALL_PHONE，然后我们使用方法的返回值和PackageManager.PERMISSION_GRANTED做比较，相等就说明用户已经授权，不等就表示用户没有授权。 如果已经授权的话就简单了，直接去执行拨打电话的逻辑操作就可以了，这里我们把拨打电话的逻辑封装到了call()方法当中。如果没有授权的话，则需要调用ActivityCompat.requestPermissions()方法来向用户申请授权，requestPermissions()方法接收3个参数，第一个参数要求是Activity的实例，第二个参数是一个String数组，我们把要申请的权限名放在数组中即可，第三个参数是请求码，只要是唯一值就可以了，这里传入了1。 调用完了requestPermissions()方法之后，系统会弹出一个权限申请的对话框，然后用户可以选择同意或拒绝我们的权限申请，不论是哪种结果，最终都会回调到onRequestPermissionsResult()方法中，而授权的结果则会封装在grantResults参数当中。这里我们只需要判断一下最后的授权结果，如果用户同意的话就调用call()方法来拨打电话，如果用户拒绝的话我们只能放弃操作，并且弹出一条失败提示。 访问其他程序中的数据内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据，另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。 首先从使用现有的内容提供器开始,如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问。Android系统中自带的电话簿、短信、媒体库等程序都提供了类似的访问接口，这就使得第三方应用程序可以充分地利用这部分数据来实现更好的功能。 ContentResolver的基本用法 对于每一个应用程序来说，如果想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据。SQLiteDatabase中也是使用这几个方法来进行CRUD操作的，只不过它们在方法参数上稍微有一些区别。 不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个Uri参数代替，这个参数被称为内容URI。内容URI给内容提供器中的数据建立了唯一标识符，它主要由两部分组成：authority和path。 authority是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。比如某个程序的包名是com.example.app，那么该程序对应的authority就可以命名为com.example.app.provider。 path则是用于对同一应用程序中不同的表做区分的，通常都会添加到authority的后面。比如某个程序的数据库里存在两张表：table1和table2，这时就可以将path分别命名为/table1和/table2，然后把authority和path进行组合，内容URI就变成了com.example.app.provider/table1和com.example.app.provider/table2。不过，目前还很难辨认出这两个字符串就是两个内容URI，我们还需要在字符串的头部加上协议声明。 内容URI标准格式写法： 12content://com.example.app.provider/table1content://com.example.app.provider/table2 得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入，解析方法如下 1Uri uri = Uri.parse("content://com.example.app.provider/table1") 只需要调用Uri.parse()方法，就可以将内容URI字符串解析成Uri对象了。 查询数据 使用这个Uri对象来查询table1表中的数据，代码如下 123456Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder); 此处的参数和SQLiteDatabase中query()的参数很像，总体来说简单一些，参考表 查询返回的是一个Cursor对象，将数据从Cursor对象中逐个读取出来。读取的思路仍然是通过移动游标的位置来遍历Cursor的所有行，然后再取出每一行中相应列的数据，代码如下 1234567if (cursor != null) &#123; while (cursor.moveToNext()) &#123; String column1 = cursor.getString(cursor.getColumnIndex("column1")); int column2 = cursor.getInt(cursor.getColumnIndex("column2")); &#125; cursor.close();&#125; 添加数据1234ContentValues values = new ContentValues();values.put("column1", "text");values.put("column2", 1);getContentResolver().insert(uri, values); 将待添加的数据组装到ContentValues中，然后调用ContentResolver的insert()方法，将Uri和ContentValues作为参数传入即可。 更新数据1234ContentValues values = new ContentValues();values.put("column1", "");getContentResolver().update(uri, values, "column1 = ? and column2 = ?", newString[] &#123;"text", "1"&#125;); 使用了selection和selectionArgs参数来对想要更新的数据进行约束，以防止所有的行都会受影响。 删除数据1getContentResolver().delete(uri, "column2 = ?", new String[] &#123; "1" &#125;); 调用ContentResolver的delete()方法将这条数据删除掉 读取联系人练习 先给自己的虚拟机添加一些联系人，实体机请忽略 新建ContactsTest项目 修改activity_main.xml文件，添加一个ListView控件 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center_horizontal|center_vertical" tools:context=".MainActivity"&gt; &lt;ListView android:id="@+id/contacts_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/ListView&gt;&lt;/LinearLayout&gt; 修改MainActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; ArrayAdapter&lt;String&gt; adapter; List&lt;String&gt; contactsList=new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView contactsView=findViewById(R.id.contacts_view); adapter=new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,contactsList); contactsView.setAdapter(adapter); if(ContextCompat.checkSelfPermission(this,Manifest.permission.READ_CONTACTS)!=PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(this,new String[]&#123;Manifest.permission.READ_CONTACTS&#125;,1); &#125;else&#123; readContacts(); &#125; &#125; private void readContacts()&#123; Cursor cursor=null; try&#123; cursor=getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null); if(cursor!=null)&#123; while(cursor.moveToNext())&#123; String displayName=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); String Number=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); contactsList.add(displayName+"\n"+Number); &#125; adapter.notifyDataSetChanged(); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if(cursor!=null)&#123; cursor.close(); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length&gt;0 &amp;&amp; grantResults[0]==PackageManager.PERMISSION_GRANTED)&#123; readContacts(); &#125;else&#123; Toast.makeText(this, "权限被拒绝", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125; &#125;&#125; 在onCreate()方法中，我们首先获取了ListView控件的实例，并给它设置好了适配器，然后开始调用运行时权限的处理逻辑，因为READ_CONTACTS权限是属于危险权限的。关于运行时权限的处理流程相信你已经熟练掌握了，这里我们在用户授权之后调用readContacts()方法来读取系统联系人信息。 readContacts()方法，可以看到，这里使用了ContentResolver的query()方法来查询系统的联系人数据。不过传入的Uri参数直接使用ContactsContract.CommonDataKinds.Phone，该类已经帮我们做好了封装，提供了一个CONTENT_URI常量，而这个常量就是使用Uri.parse()方法解析出来的结果。 接着我们对Cursor对象进行遍历，将联系人姓名和手机号这些数据逐个取出，联系人姓名这一列对应的常量是ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME，联系人手机号这一列对应的常量是ContactsContract.CommonDataKinds.Phone.NUMBER。两个数据都取出之后，将它们进行拼接，并且在中间加上换行符，然后将拼接后的数据添加到ListView的数据源里，并通知刷新一下ListView。 最后千万不要忘记将Cursor对象关闭掉。 在AndroidManifest.xml中申明权限 1&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt; 创建自己的内容提供器新建一个类去继承ContentProvider来创建一个自己的内容提供器 新建MyProvider类继承自ContentProvider 1234567891011121314151617181920212223242526272829303132333435public class MyProvider extends ContentProvider &#123; @Override public boolean onCreate() &#123; return false; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return null; &#125; @Override public Uri insert(Uri uri,ContentValues values) &#123; return null; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125; &#125; 这里用control+o重写函数可能会出现`@androidx.annotation.Nullable`,查了一下应该是androidx库里面的东西，报错的解决办法就是在gradle.properties添加 12android.useAndroidX=trueandroid.enableJetifier=true 方法介绍 onCreate()：初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示内容提供器初始化成功，返回false则表示失败。 query()：从内容提供器中查询数据。使用uri参数来确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。 insert()：向内容提供器中添加一条数据。使用uri参数来确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的URI。 update()：更新内容提供器中已有的数据。使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。 delete()：从内容提供器中删除数据。使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。 getType()：根据传入的内容URI来返回相应的MIME类型。 几乎每一个方法都会带有Uri这个参数，这个参数也正是调用ContentResolver的增删改查方法时传递过来的。而现在，我们需要对传入的Uri参数进行解析，从中分析出调用方期望访问的表和数据。 一个标准的内容URI写法是这样的： 1content://com.example.app.provider/table1 这就表示调用方期望访问的是com.example.app这个应用的table1表中的数据。除此之外，我们还可以在这个内容URI的后面加上一个id，如下所示 1content://com.example.app.provider/table1/1 这就表示调用方期望访问的是com.example.app这个应用的table1表中id为1的数据 内容URI的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以id结尾就表示期望访问该表中拥有相应id的数据。我们可以使用通配符的方式来分别匹配这两种格式的内容URI，规则如下。 *：表示匹配任意长度的任意字符。 #：表示匹配任意长度的数字。 所以，一个能够匹配任意表的内容URI格式就可以写成 1content://com.example.app.provider/* 而一个能够匹配table1表中任意一行数据的内容URI格式就可以写成 1content://com.example.app.provider/table1/# 接着，我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。 UriMatcher中提供了一个addURI()方法，这个方法接收3个参数，可以分别把authority、path和一个自定义代码传进去。这样，当调用UriMatcher的match()方法时，就可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。 修改MyProvider中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MyProvider extends ContentProvider &#123; public static final int TABLE1_DIR= 0; public static final int TABLE1_ITEM= 1; public static final int TABLE2_DIR = 2; public static final int TABLE2_ITEM = 3; private static UriMatcher uriMatcher; static&#123; uriMatcher=new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI("com.zanecode6574.app.provider","table1",TABLE1_DIR); uriMatcher.addURI("com.zanecoed6574.app.provider","table1/#",TABLE1_ITEM); uriMatcher.addURI("com.zanecode6574.app.provider","table2",TABLE2_DIR); uriMatcher.addURI("com.zanecoed6574.app.provider","table2/#",TABLE2_ITEM); &#125; @Override public boolean onCreate() &#123; return false; &#125; @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; switch(uriMatcher.match(uri))&#123; case TABLE1_DIR: //查询表1中的所有数据 break; case TABLE1_ITEM: //查询table1表中的单条数据 break; case TABLE2_DIR: //同上可得 break; case TABLE2_ITEM: //同上可得 break; default: break; &#125; return null; &#125; @Override public Uri insert(Uri uri,ContentValues values) &#123; return null; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125;&#125; MyProvider中新增了4个整型常量，其中TABLE1_DIR表示访问table1表中的所有数据，TABLE1_ITEM表示访问table1表中的单条数据，TABLE2_DIR表示访问table2表中的所有数据，TABLE2_ITEM表示访问table2表中的单条数据。 在静态代码块里我们创建了UriMatcher的实例，并调用addURI()方法，将期望匹配的内容URI格式传递进去，注意这里传入的路径参数是可以使用通配符的。然后当query()方法被调用的时候，就会通过UriMatcher的match()方法对传入的Uri对象进行匹配，如果发现UriMatcher中某个内容URI格式成功匹配了该Uri对象，则会返回相应的自定义代码，然后我们就可以判断出调用方期望访问的到底是什么数据了。 上述代码只是以query()方法为例做了个示范，其实insert()、update()、delete()这几个方法的实现也是差不多的，它们都会携带Uri这个参数，然后同样利用UriMatcher的match()方法判断出调用方期望访问的是哪张表，再对该表中的数据进行相应的操作就可以了。 getType()方法是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。一个内容URI所对应的MIME字符串主要由3部分组成，Android对这3个部分做了如下格式规定。 必须以vnd开头。 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/ 最后接上vnd.&lt;authority&gt;.&lt;path&gt; 所以，对于content://com.example.app.provider/table1这个内容URI，它所对应的MIME类型就可以写成vnd.android.cursor.dir/vnd.com.example.app.provider.table1,对于content://com.example.app.provider/table1/1这个内容URI，它所对应的MIME类型就可以写成：vnd.android.cursor.item/vnd.com.example.app.provider.table1 继续完善MyProvider 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MyProvider extends ContentProvider &#123; public static final int TABLE1_DIR= 0; public static final int TABLE1_ITEM= 1; public static final int TABLE2_DIR = 2; public static final int TABLE2_ITEM = 3; private static UriMatcher uriMatcher; static&#123; uriMatcher=new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI("com.zanecode6574.app.provider","table1",TABLE1_DIR); uriMatcher.addURI("com.zanecoed6574.app.provider","table1/#",TABLE1_ITEM); uriMatcher.addURI("com.zanecode6574.app.provider","table2",TABLE2_DIR); uriMatcher.addURI("com.zanecoed6574.app.provider","table2/#",TABLE2_ITEM); &#125; @Override public boolean onCreate() &#123; return false; &#125; @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; switch(uriMatcher.match(uri))&#123; case TABLE1_DIR: //查询表1中的所有数据 break; case TABLE1_ITEM: //查询table1表中的单条数据 break; case TABLE2_DIR: //同上可得 break; case TABLE2_ITEM: //同上可得 break; default: break; &#125; return null; &#125; @Override public Uri insert(Uri uri,ContentValues values) &#123; return null; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; switch(uriMatcher.match(uri))&#123; case TABLE1_DIR: return "vnd.android.cursor.dir/vnd.com.zanecode6574.app.provider.table1"; case TABLE1_ITEM: return "vnd.android.cursor.item/vnd.com.zanecode6574.app.provider.table1"; case TABLE2_DIR: return "vnd.android.cursor.dir/vnd.com.zanecode6574.app.provider.table2"; case TABLE2_ITEM: return "vnd.android.cursor.item/vnd.com.zanecode6574.app.provider.table2"; default: break; &#125; return null; &#125;&#125; 如何才能保证隐私数据不会泄漏出去呢？其实多亏了内容提供器的良好机制，这个问题在不知不觉中已经被解决了。因为所有的CRUD操作都一定要匹配到相应的内容URI格式才能进行的，而我们当然不可能向UriMatcher中添加隐私数据的URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了。 实现跨程序数据共享创建内容提供器 为了简单，在上一章中DatabaseTest项目的基础上做，通过内容提供器给它加入外部访问接口，打开DatabaseTest项目 首先将项目内的Toast去掉，因为跨程序访问时不能直接使用Toast 创建一个内容提供器右击com.example.databasetest包→New→Other→Content Provider，这里我们将内容提供器命名为DatabaseProvider，authority指定为com.example.databasetest.provider，Exported属性表示是否允许外部程序访问我们的内容提供器，Enabled属性表示是否启用这个内容提供器。将两个属性都勾中，点击Finish完成创建 修改DatabaseProvider的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR= 0 ; public static final int BOOK_ITEM= 1 ; public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY="com.zanecode6574.databasetest.provider"; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static&#123; //创建一个URI树的根结点，因为根结点没有匹配路径，所以不需要返回码，所以这里初始化传参为UriMatcher.NO_MATCH来表示根结点不需要匹配路径的返回码 uriMatcher=new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY,"book",BOOK_DIR); uriMatcher.addURI(AUTHORITY,"book/#",BOOK_ITEM); uriMatcher.addURI(AUTHORITY,"category",CATEGORY_DIR); uriMatcher.addURI(AUTHORITY,"category/#",CATEGORY_ITEM); &#125; public DatabaseProvider() &#123; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // Implement this to handle requests to delete one or more rows. SQLiteDatabase db=dbHelper.getWritableDatabase(); int deleteRows=0; switch(uriMatcher.match(uri))&#123; case BOOK_DIR: deleteRows=db.delete("Book",selection,selectionArgs); break; case BOOK_ITEM: String bookId=uri.getPathSegments().get(1); deleteRows=db.delete("Book","id=?",new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: deleteRows=db.delete("Category",selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId=uri.getPathSegments().get(1); deleteRows=db.delete("Category","id=?",new String[]&#123;categoryId&#125;); break; default: break; &#125; return deleteRows; &#125; @Override public String getType(Uri uri) &#123; // TODO: Implement this to handle requests for the MIME type of the data // at the given URI. switch(uriMatcher.match(uri))&#123; case BOOK_DIR: return "vnd.android.cursor.dir/vnd.com.zanecode6574.databasetest.provider.book"; case BOOK_ITEM: return "vnd.android.cursor.item/vnd.com.zanecode6574.databasetest.provider.book"; case CATEGORY_DIR: return "vnd.android.cursor.dir/vnd.com.zanecode6574.databasetest.provider.category"; case CATEGORY_ITEM: return "vnd.android.cursor.item/vnd.com.zanecode6574.databasetest.provider.category"; &#125; return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // TODO: Implement this to handle requests to insert a new row. SQLiteDatabase db=dbHelper.getWritableDatabase(); Uri uriReturn=null; switch (uriMatcher.match(uri))&#123; case BOOK_DIR: case BOOK_ITEM: long newBookId=db.insert("Book",null,values); uriReturn=Uri.parse("content://"+AUTHORITY+"" +"/book/"+newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId=db.insert("Category",null,values); uriReturn=Uri.parse("content://"+AUTHORITY+"/category"+newCategoryId); break; default: break; &#125; return uriReturn; &#125; @Override public boolean onCreate() &#123; // TODO: Implement this to initialize your content provider on startup. dbHelper=new MyDatabaseHelper(getContext(),"BookStore.db",null,2); return true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // TODO: Implement this to handle query requests from clients. SQLiteDatabase db=dbHelper.getReadableDatabase(); Cursor cursor=null; switch(uriMatcher.match(uri))&#123; case BOOK_DIR: cursor=db.query("Book",projection,selection,selectionArgs,null,null,sortOrder); break; case BOOK_ITEM: String bookId=uri.getPathSegments().get(1); cursor=db.query("Book",projection,"id=?",new String[]&#123;bookId&#125;,null,null,sortOrder); break; case CATEGORY_DIR: cursor=db.query("Category",projection,selection,selectionArgs,null,null,sortOrder); break; case CATEGORY_ITEM: String categoryId=uri.getPathSegments().get(1); cursor=db.query("Category",projection,"id=?",new String[]&#123;categoryId&#125;,null,null,sortOrder); break; default: break; &#125; return cursor; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // TODO: Implement this to handle requests to update one or more rows. SQLiteDatabase db=dbHelper.getWritableDatabase(); int updateRows=0; switch(uriMatcher.match(uri))&#123; case BOOK_DIR: updateRows=db.update("Book",values,selection,selectionArgs); break; case BOOK_ITEM: String bookId=uri.getPathSegments().get(1); updateRows=db.update("Book",values,"id=?",new String[]&#123;bookId&#125;); break; case CATEGORY_DIR: updateRows=db.update("Category",values,selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId=uri.getPathSegments().get(1); updateRows=db.update("Category",values,"id=?",new String[]&#123;categoryId&#125;); break; default: break; &#125; return updateRows; &#125;&#125; 这些内容都非常容易理解，因为使用到的全部都是上一小节中我们学到的知识。首先在类的一开始，同样是定义了4个常量，分别用于表示访问Book表中的所有数据、访问Book表中的单条数据、访问Category表中的所有数据和访问Category表中的单条数据。然后在静态代码块里对UriMatcher进行了初始化操作，将期望匹配的几种URI格式添加了进去。接下来就是每个抽象方法的具体实现了。 onCreate()方法，创建了一个MyDatabaseHelper的实例，然后返回true表示内容提供器初始化成功，这时数据库就已经完成了创建或升级操作。 query()方法，在这个方法中先获取到了SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要访问哪张表，再调用SQLiteDatabase的query()进行查询，并将Cursor对象返回就好了。注意当访问单条数据的时候有一个细节，这里调用了Uri对象的getPathSegments()方法，它会将内容URI权限之后的部分以“/”符号进行分割，并把分割后的结果放入到一个字符串列表中，那这个列表的第0个位置存放的就是路径，第1个位置存放的就是id了。得到了id之后，再通过selection和selectionArgs参数进行约束，就实现了查询单条数据的功能。 insert()方法，先获取到了SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要往哪张表里添加数据，再调用SQLiteDatabase的insert()方法进行添加就可以了。注意insert()方法要求返回一个能够表示这条新增数据的URI，所以我们还需要调用Uri.parse()方法来将一个内容URI解析成Uri对象，当然这个内容URI是以新增数据的id结尾的。 update()方法了，先获取SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要更新哪张表里的数据，再调用SQLiteDatabase的update()方法进行更新就好了，受影响的行数将作为返回值返回。 delete()方法，先获取到SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要删除哪张表里的数据，再调用SQLiteDatabase的delete()方法进行删除就好了，被删除的行数将作为返回值返回。 getType()方法，这个方法中的代码完全是按照上一节中介绍的格式规则编写的。 在AndroidManifest中注册内容提供器(这一步Android Studio已经帮我们添加好了) 删除原模拟器中的DatabaseTest程序防止之前的数据干扰 运行一次项目，将其安装至模拟器 创建PrividerTest项目进行测试 新建ProviderTest项目 修改activity_main.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:gravity="center_horizontal" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/add_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加数据"/&gt; &lt;Button android:id="@+id/query_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="查询数据"/&gt; &lt;Button android:id="@+id/update_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="更新数据"/&gt; &lt;Button android:id="@+id/delete_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="删除数据"/&gt; &lt;/LinearLayout&gt; 修改MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MainActivity extends AppCompatActivity &#123; private String newId; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button addData=findViewById(R.id.add_data); Button queryData=findViewById(R.id.query_data); Button updateData=findViewById(R.id.update_data); Button deleteData=findViewById(R.id.delete_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri=Uri.parse("content://com.zanecode6574.databasetest.provider/book"); ContentValues values=new ContentValues(); values.put("name","Provider测试"); values.put("author","Provider"); values.put("pages",300); values.put("price",29.99); Uri newUri=getContentResolver().insert(uri,values); newId=newUri.getPathSegments().get(1); &#125; &#125;); queryData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri=Uri.parse("content://com.zanecode6574.databasetest.provider/book"); Cursor cursor=getContentResolver().query(uri,null,null,null,null); if (cursor != null) &#123; while(cursor.moveToNext())&#123; String name=cursor.getString(cursor.getColumnIndex("name")); String author=cursor.getString(cursor.getColumnIndex("author")); int pages=cursor.getInt(cursor.getColumnIndex("pages")); double price=cursor.getDouble(cursor.getColumnIndex("price")); Log.d("MainActivity","Name:"+name+" "+"Author:"+author+" "+"Pages:"+pages+" "+"Price:"+price); &#125; cursor.close(); &#125; &#125; &#125;); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri=Uri.parse("content://com.zanecode6574.databasetest.provider/book/"+newId); ContentValues values=new ContentValues(); values.put("name","Provider再次测试"); values.put("pages",899); values.put("price",19.99); getContentResolver().update(uri,values,null,null); &#125; &#125;); deleteData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Uri uri=Uri.parse("content://com.zanecode6574.databasetest.provider/book/"+newId); getContentResolver().delete(uri,null,null); &#125; &#125;); &#125;&#125; 添加数据的时候，首先调用了Uri.parse()方法将一个内容URI解析成Uri对象，然后把要添加的数据都存放到ContentValues对象中，接着调用ContentResolver的insert()方法执行添加操作就可以了。注意insert()方法会返回一个Uri对象，这个对象中包含了新增数据的id，我们通过getPathSegments()方法将这个id取出，稍后会用到它。 查询数据的时候，同样是调用了Uri.parse()方法将一个内容URI解析成Uri对象，然后调用ContentResolver的query()方法去查询数据，查询的结果当然还是存放在Cursor对象中的。之后对Cursor进行遍历，从中取出查询结果，并一一打印出来。 更新数据的时候，也是先将内容URI解析成Uri对象，然后把想要更新的数据存放到ContentValues对象中，再调用ContentResolver的update()方法执行更新操作就可以了。注意这里我们为了不想让Book表中的其他行受到影响，在调用Uri.parse()方法时，给内容URI的尾部增加了一个id，而这个id正是添加数据时所返回的。这就表示我们只希望更新刚刚添加的那条数据，Book表中的其他行都不会受影响。 删除数据的时候，也是使用同样的方法解析了一个以id结尾的内容URI，然后调用ContentResolver的delete()方法执行删除操作就可以了。由于我们在内容URI里指定了一个id，因此只会删掉拥有相应id的那行数据，Book表中的其他数据都不会受影响。 最后暂时没感觉到多少程序需要用到这个内容提供器，这节先水水，要用到的时候回来翻步骤就行了。]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>跨程序</tag>
        <tag>内容提供器</tag>
        <tag>共享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章：数据储存全方案-详解持久化技术]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98%E5%85%A8%E6%96%B9%E6%A1%88-%E8%AF%A6%E8%A7%A3%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[持久化技术介绍数据持久化就是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的，持久化技术则提供了一种机制可以让数据在瞬时状态和持久状态之间进行转换。 Android系统中主要提供了三种方式用于简单实现数据持久化功能，除了这3种方式之外，你还可以将数据保存在手机的SD卡中，不过使用文件、SharedPreferences或数据库来保存数据会相对更简单一些，而且比起将数据保存在SD卡中会更加地安全。 文件储存文件存储是Android中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据或二进制数据。如果你想使用文件存储的方式来保存一些较为复杂的文本数据，就需要定义一套自己的格式规范，这样可以方便之后将数据从文件中重新解析出来。 将数据储存到文件中Context类中提供了一个openFileOutput()方法，可以用于将数据存储到指定的文件中，这个方法接收两个参数。 第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里指定的文件名不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下的。 第二个参数是文件的操作模式，主要有两种模式可选，MODE_PRIVATE和MODE_APPEND。其中MODE_PRIVATE是默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而MODE_APPEND则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。 其实文件的操作模式本来还有另外两种：MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE，这两种模式表示允许其他的应用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安全性漏洞，已在Android 4.2版本中被废弃。 openFileOutput ()方法返回的是一个FileOutputStream对象，得到了这个对象之后就可以使用Java流的方式将数据写入到文件中了。 1234567891011121314151617181920public void save() &#123; String data = "Data to save"; FileOutputStream out = null; BufferedWriter writer = null; try &#123; out = openFileOutput("data", Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里通过openFileOutput()方法能够得到一个FileOutputStream对象，然后再借助它构建出一个OutputStreamWriter对象，接着再使用OutputStreamWriter构建出一个BufferedWriter对象，这样你就可以通过BufferedWriter来将文本内容写入到文件中了。 编写FilePersistenceTest项目进行测试 在MainActivity布局中添加一个文本输入框 编辑MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText=findViewById(R.id.edit); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText=editText.getText().toString(); save(inputText); &#125; public void save(String inputText)&#123; FileOutputStream out=null; BufferedWriter writer=null; try&#123; out=openFileOutput("data",Context.MODE_PRIVATE); writer=new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(writer!=null)&#123; writer.close(); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 在这里在输入框中输入一些字符串，按下返回键，在活动被销毁时将文字存入data文件中 在新版本的Android Studio中已经弃用了书上使用的Android Device Monitor，因此这里查看文件直接用Android Studio右下角的文件管理器即可，非常方便 从文件中读取数据Context类中还提供了一个openFileInput()方法，用于从文件中读取数据。这个方法要比openFileOutput()简单一些，它只接收一个参数，即要读取的文件名，然后系统会自动到/data/data//files/目录下去加载这个文件，并返回一个FileInputStream对象，得到了这个对象之后再通过Java流的方式就可以将数据读取出来了。 代码示例 123456789101112131415161718192021222324public String load() &#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; in = openFileInput("data"); reader = new BufferedReader(new InputStreamReader(in)); String line = ""; while ((line = reader.readLine()) != null) &#123; content.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString();&#125; 首先通过openFileInput()方法获取到了一个FileInputStream对象，然后借助它又构建出了一个InputStreamReader对象，接着再使用InputStreamReader构建出一个BufferedReader对象，这样我们就可以通过BufferedReader进行一行行地读取，把文件中所有的文本内容全部读取出来，并存放在一个StringBuilder对象中，最后将读取到的内容返回就可以了。 修改MainActivity实现启动程序读取文件中的内容至输入框中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MainActivity extends AppCompatActivity &#123; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText=findViewById(R.id.edit); String inputText=load(); if(!TextUtils.isEmpty(inputText))&#123; editText.setText(inputText); editText.setSelection(inputText.length()); Toast.makeText(this, "恢复成功", Toast.LENGTH_SHORT).show(); &#125; &#125; public String load()&#123; FileInputStream in=null; BufferedReader reader=null; StringBuilder content=new StringBuilder(); try&#123; in=openFileInput("data"); reader=new BufferedReader(new InputStreamReader(in)); String line=""; while((line=reader.readLine())!=null)&#123; content.append(line); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally &#123; if(reader!=null)&#123; try&#123; reader.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); String inputText=editText.getText().toString(); save(inputText); &#125; public void save(String inputText)&#123; FileOutputStream out=null; BufferedWriter writer=null; try&#123; out=openFileOutput("data",Context.MODE_PRIVATE); writer=new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(writer!=null)&#123; writer.close(); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 在onCreate()方法中调用load()方法来读取文件中存储的文本内容，如果读到的内容不为null，就调用EditText的setText()方法将内容填充到EditText里，并调用setSelection()方法将输入光标移动到文本的末尾位置以便于继续输入，然后弹出一句还原成功的提示。 上述代码在对字符串进行非空判断的时候使用了TextUtils.isEmpty()方法，这是一个非常好用的方法，它可以一次性进行两种空值的判断。当传入的字符串等于null或者等于空字符串的时候，这个方法都会返回true，从而使得我们不需要先单独判断这两种空值再使用逻辑运算符连接起来了。 文件的储存并不适用于一些比较复杂的文本数据 SharedPreferences储存简介不同于文件的存储方式，SharedPreferences是使用键值对的方式来存储数据的。也就是说，当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。而且SharedPreferences还支持多种不同的数据类型存储，如果存储的数据类型是整型，那么读取出来的数据也是整型的；如果存储的数据是一个字符串，那么读取出来的数据仍然是字符串。 要使用SharedPreferences需要先获取SharedPreferences对象，Android中主要提供了三种方法用于获取SharedPreferences对象。 Context类中的getSharedPreferences()方法：此方法接收两个参数，第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences文件都是存放在/data/data//shared_prefs/目录下的。第二个参数用于指定操作模式，目前只有MODE_PRIVATE这一种模式可选，它是默认的操作模式，和直接传入0效果是相同的，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。其他几种操作模式均已被废弃，MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE这两种模式是在Android 4.2版本中被废弃的，MODE_MULTI_PROCESS模式是在Android 6.0版本中被废弃的。 Activity类中的getPreferences()方法：这个方法和Context中的getSharedPreferences()方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的类名作为SharedPreferences的文件名。 PreferenceManager类中的getDefaultSharedPreferences()方法：这是一个静态方法，它接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences文件。得到了SharedPreferences对象之后，就可以开始向SharedPreferences文件中存储数据了，主要可以分为3步实现。 调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象。 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。 调用apply()方法将添加的数据提交，从而完成数据存储操作。 新建SharedPreferencesTest项目写入数据 修改activity_main.xml中的代码 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center_horizontal|center_vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="储存"/&gt;&lt;/LinearLayout&gt; 添加了一个按钮 修改MainActivity中的代码 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button=findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences.Editor editor=getSharedPreferences("data",MODE_PRIVATE).edit(); editor.putString("name","Zanecode6574"); editor.putInt("age",99); editor.putBoolean("married",false); editor.apply(); &#125; &#125;); &#125;&#125; 这里首先给按钮注册了一个点击事件，然后在点击事件中通过getSharedPreferences()方法指定SharedPreferences的文件名为data，并得到了SharedPreferences.Editor对象。接着向这个对象中添加了3条不同类型的数据，最后调用apply()方法进行提交，从而完成了数据存储的操作。 读取数据从SharedPreferences文件中读取数据会更加地简单。SharedPreferences对象中提供了一系列的get方法，用于对存储的数据进行读取，每种get方法都对应了SharedPreferences.Editor中的一种put方法，比如读取一个布尔型数据就使用getBoolean()方法，读取一个字符串就使用getString()方法。这些get方法都接收两个参数，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了；第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回。 修改activity_main.xml的代码，添加一个读取数据用的按钮 修改MainActivity中的代码 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private Button button; private Button button2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button=findViewById(R.id.button); button2=findViewById(R.id.button2); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences.Editor editor=getSharedPreferences("data",MODE_PRIVATE).edit(); editor.putString("name","Zanecode6574"); editor.putInt("age",99); editor.putBoolean("married",false); editor.apply(); &#125; &#125;); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences pref=getSharedPreferences("data",MODE_PRIVATE); String name=pref.getString("name",""); int age=pref.getInt("age",999); boolean married=pref.getBoolean("married",false); Toast.makeText(MainActivity.this, name+" "+age+" "+married, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 在还原数据按钮的点击事件中首先通过getSharedPreferences()方法得到了SharedPreferences对象，然后分别调用它的getString()、getInt()和getBoolean()方法，去获取前面所存储的姓名、年龄和是否已婚，如果没有找到相应的值，就会使用方法中传入的默认值来代替 实现记住密码功能这里使用之前强制下线的项目代码即可，打开BroadcastPractice项目 修改activity_login.xml中的代码，添加一个选择框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".LoginActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:layout_marginLeft="30dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="账号"/&gt; &lt;EditText android:id="@+id/EditText_UserName" android:layout_width="0dp" android:layout_height="wrap_content" android:hint="输入账号" android:maxLines="1" android:layout_weight="1" android:layout_marginRight="30dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:layout_marginLeft="30dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="密码"/&gt; &lt;EditText android:id="@+id/EditText_Password" android:layout_width="0dp" android:layout_height="wrap_content" android:hint="输入密码" android:maxLines="1" android:layout_weight="1" android:inputType="textPassword" android:layout_marginRight="30dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:gravity="center_horizontal" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;CheckBox android:id="@+id/remember_pass" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="记住密码"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center"&gt; &lt;Button android:id="@+id/Button_Login" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 修改LoginActivity中的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class LoginActivity extends BaseActivity &#123; private EditText userNameEdit; private EditText passwordEdit; private CheckBox checkBox; private SharedPreferences pref; private SharedPreferences.Editor editor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); Button loginButton=findViewById(R.id.Button_Login); checkBox=findViewById(R.id.remember_pass); userNameEdit=findViewById(R.id.EditText_UserName); passwordEdit=findViewById(R.id.EditText_Password); pref=PreferenceManager.getDefaultSharedPreferences(this); boolean isRemember=pref.getBoolean("isRemember",false); if(isRemember)&#123; String userName=pref.getString("userName",""); String password=pref.getString("password",""); userNameEdit.setText(userName); passwordEdit.setText(password); checkBox.setChecked(true); &#125; loginButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String userName=userNameEdit.getText().toString(); String password=passwordEdit.getText().toString(); if(userName.equals("admin"))&#123; if(password.toString().equals("admin"))&#123; editor=pref.edit(); if(checkBox.isChecked())&#123; editor.putBoolean("isRemember",true); editor.putString("userName",userName); editor.putString("password",password); &#125;else&#123; editor.clear(); &#125; editor.apply(); Intent intent=new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); &#125; &#125;else&#123; Toast.makeText(LoginActivity.this, "输入有误！", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125; 这里首先在onCreate()方法中获取到了SharedPreferences对象，然后调用它的getBoolean()方法去获取remember_password这个键对应的值。一开始当然不存在对应的值了，所以会使用默认值false，这样就什么都不会发生。接着在登录成功之后，会调用CheckBox的isChecked()方法来检查复选框是否被选中，如果被选中了，则表示用户想要记住密码，这时将remember_password设置为true，然后把account和password对应的值都存入到SharedPreferences文件当中并提交。如果没有被选中，就简单地调用一下clear()方法，将SharedPreferences文件中的数据全部清除掉。当用户选中了记住密码复选框，并成功登录一次之后，remember_password键对应的值就是true了，这个时候如果再重新启动登录界面，就会从SharedPreferences文件中将保存的账号和密码都读取出来，并填充到文本输入框中，然后把记住密码复选框选中，这样就完成记住密码的功能了。 SQLite数据库储存SQLite是一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，通常只需要几百KB的内存就足够了，因而特别适合在移动设备上使用。SQLite不仅支持标准的SQL语法，还遵循了数据库的ACID事务，所以只要你以前使用过其他的关系型数据库，就可以很快地上手SQLite。而SQLite又比一般的数据库要简单得多，它甚至不用设置用户名和密码就可以使用。Android正是把这个功能极为强大的数据库嵌入到了系统当中，使得本地持久化的功能有了一次质的飞跃。 创建数据库Android为了让我们能够更加方便地管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这个类就可以非常简单地对数据库进行创建和升级。 SQLiteOpenHelper是一个抽象类，这意味着如果我们想要使用它的话，就需要创建一个自己的帮助类去继承它。 SQLiteOpenHelper中有两个抽象方法，分别是onCreate()和onUpgrade()，我们必须在自己的帮助类里面重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑。 SQLiteOpenHelper中还有两个非常重要的实例方法：getReadableDatabase()和getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候（如磁盘空间已满），getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法则将出现异常。 SQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可。这个构造方法中接收4个参数，第一个参数是Context，这个没什么好说的，必须要有它才能对数据库进行操作。第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般都是传入null。第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。构建出SQLiteOpenHelper的实例之后，再调用它的getReadableDatabase()或getWritableDatabase()方法就能够创建数据库了，数据库文件会存放在/data/data//databases/目录下。此时，重写的onCreate()方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑。 创建一个DatabaseTest项目 新建一个MyDatabaseHelper类继承自SQLiteOpenHelper 123456789101112131415161718public class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK="create table Book("+"id integer primary key autoincrement,"+"author text"+"price real,"+"pages integer,"+"name text)"; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version)&#123; super(context,name,factory,version); mContext=context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext, "创建数据库成功", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; &#125; 把建表语句定义成了一个字符串常量，然后在onCreate()方法中又调用了SQLiteDatabase的execSQL()方法去执行这条建表语句，并弹出一个Toast提示创建成功，这样就可以保证在数据库创建完成的同时还能成功创建Book表。 修改activity_main.xml中的代码添加一个创建数据库的按钮 修改MainActivity中的代码 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private Button crerateDatabase; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper=new MyDatabaseHelper(this,"BookStore",null,1); crerateDatabase=findViewById(R.id.create_database); crerateDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 升级数据库MyDatabaseHelper中还有一个空方法,onUpgrade()方法是用于对数据库进行升级的，它在整个数据库的管理工作当中起着非常重要的作用. 目前DatabaseTest项目中已经有一张Book表用于存放书的各种详细数据，如果我们想再添加一张Category表用于记录图书的分类，比如Category表中有id（主键）、分类名和分类代码这几个列，那么建表语句就可以写成 1234create table Category (id integer primary key autoincrement,category_name text,category_code integer) 修改MydatabaseHelper 12345678910111213141516171819202122232425public class MyDatabaseHelper extends SQLiteOpenHelper &#123; public static final String CREATE_BOOK="create table Book("+"id integer primary key autoincrement,"+"author text"+"price real,"+"pages integer,"+"name text)"; public static final String CREATE_CATEGORY="create table Category ("+"id integer primary key autoincrement,"+"category_name text,"+"category_code integer)"; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version)&#123; super(context,name,factory,version); mContext=context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, "创建数据库成功", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("drop table if exists Book"); db.execSQL("drop table if exists Category"); onCreate(db); &#125;&#125; 修改MainActivity 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private Button crerateDatabase; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper=new MyDatabaseHelper(this,"BookStore",null,4); crerateDatabase=findViewById(R.id.create_database); crerateDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 要触发数据库升级的操作，就要传入一个更大的参数给MyDatabaseHelper，之前是1，由于我个人测试了几次，所以是4，其实只要比上一次创建的时候的值大就会触发升级，在升级函数中又对之前的数据库进行了删除，所以即使存在也没有关系，会重新创建（实际中应该不是这样吧，万一之前的表中还有数据？） 添加数据对数据进行的操作无非有4种，即CRUD。其中C代表添加（Create），R代表查询（Retrieve），U代表更新（Update），D代表删除（Delete）。 开发者的水平总会是参差不齐的，未必每一个人都能非常熟悉地使用SQL语言，因此Android也提供了一系列的辅助性方法，使得在Android中即使不去编写SQL语句，也能轻松完成所有的CRUD操作。 调用SQLiteOpenHelper的getReadableDatabase()或getWritableDatabase()方法是可以用于创建和升级数据库的，不仅如此，这两个方法还都会返回一个SQLiteDatabase对象，借助这个对象就可以对数据进行CRUD操作了。 SQLiteDatabase中提供了一个insert()方法，这个方法就是专门用于添加数据的。它接收3个参数，第一个参数是表名，我们希望向哪张表里添加数据，这里就传入该表的名字。第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可。第三个参数是一个ContentValues对象，它提供了一系列的put()方法重载，用于向ContentValues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。 修改activity_main.xml的代码,增加一个添加数据的按钮 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends AppCompatActivity &#123; private Button crerateDatabase; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper=new MyDatabaseHelper(this,"BookStore.db",null,7); crerateDatabase=findViewById(R.id.create_database); Button addData=findViewById(R.id.add_data); crerateDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); //开始组装第一条数据 values.put("name","ZaneCode6574"); values.put("author","ZaneCode6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); values.clear(); //开始组装第二条数据 values.put("name","Z6574"); values.put("author","Ze6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); &#125; &#125;); &#125;&#125; 更新数据SQLiteDatabase中也提供了一个非常好用的update()方法，用于对数据进行更新，这个方法接收4个参数，第一个参数和insert()方法一样，也是表名，在这里指定去更新哪张表里的数据。第二个参数是ContentValues对象，要把更新数据在这里组装进去。第三、第四个参数用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。 修改activity_main.xml中的代码，添加一个更新数据的按钮 修改MainActivity中的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity &#123; private Button crerateDatabase; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper=new MyDatabaseHelper(this,"BookStore.db",null,7); crerateDatabase=findViewById(R.id.create_database); Button addData=findViewById(R.id.add_data); Button updateData=findViewById(R.id.update_data); crerateDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); //开始组装第一条数据 values.put("name","ZaneCode6574"); values.put("author","ZaneCode6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); values.clear(); //开始组装第二条数据 values.put("name","Z6574"); values.put("author","Ze6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); &#125; &#125;); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put("price",100); db.update("Book",values,"name=?",new String[]&#123;"Z6574"&#125;); &#125; &#125;); &#125;&#125; 删除数据SQLiteDatabase中提供了一个delete()方法，专门用于删除数据，这个方法接收3个参数，第一个参数仍然是表名，这个已经没什么好说的了，第二、第三个参数又是用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行。 修改activity_main.xml的代码，添加一个删除按钮 修改MainActivity的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MainActivity extends AppCompatActivity &#123; private Button crerateDatabase; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper=new MyDatabaseHelper(this,"BookStore.db",null,7); crerateDatabase=findViewById(R.id.create_database); Button addData=findViewById(R.id.add_data); Button updateData=findViewById(R.id.update_data); Button deleteData=findViewById(R.id.delete_data); crerateDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); //开始组装第一条数据 values.put("name","ZaneCode6574"); values.put("author","ZaneCode6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); values.clear(); //开始组装第二条数据 values.put("name","Z6574"); values.put("author","Ze6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); &#125; &#125;); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put("price",100); db.update("Book",values,"name=?",new String[]&#123;"Z6574"&#125;); &#125; &#125;); deleteData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); db.delete("Book","pages&gt;?",new String[]&#123;"400"&#125;); &#125; &#125;); &#125;&#125; 查询数据查询是CRUD中最复杂的一种操作，SQLiteDatabase中还提供了一个query()方法用于对数据进行查询。这个方法的参数非常复杂，最短的一个方法重载也需要传入7个参数。那我们就先来看一下这7个参数各自的含义吧。第一个参数不用说，当然还是表名，表示我们希望从哪张表中查询数据。第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列。第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据。第五个参数用于指定需要去group by的列，不指定则表示不对查询结果进行group by操作。第六个参数用于对group by之后的数据进行进一步的过滤，不指定则表示不进行过滤。第七个参数用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。更多详细的内容可以参考下表。调用query()方法后会返回一个Cursor对象，查询到的所有数据都将从这个对象中取出 修改activity_main.xml的代码添加一个查询按钮 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class MainActivity extends AppCompatActivity &#123; private Button crerateDatabase; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper=new MyDatabaseHelper(this,"BookStore.db",null,7); crerateDatabase=findViewById(R.id.create_database); Button addData=findViewById(R.id.add_data); Button updateData=findViewById(R.id.update_data); Button deleteData=findViewById(R.id.delete_data); Button queryData=findViewById(R.id.query_data); crerateDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbHelper.getWritableDatabase(); &#125; &#125;); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); //开始组装第一条数据 values.put("name","ZaneCode6574"); values.put("author","ZaneCode6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); values.clear(); //开始组装第二条数据 values.put("name","Z6574"); values.put("author","Ze6574"); values.put("pages",454); values.put("price",99.99); db.insert("Book",null,values); &#125; &#125;); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put("price",100); db.update("Book",values,"name=?",new String[]&#123;"Z6574"&#125;); &#125; &#125;); deleteData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); db.delete("Book","pages&gt;?",new String[]&#123;"400"&#125;); &#125; &#125;); queryData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbHelper.getWritableDatabase(); //查询Book表的所有数据 Cursor cursor=db.query("Book",null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; String name = cursor.getString(cursor.getColumnIndex("name")); String author = cursor.getString(cursor.getColumnIndex("author")); int pages = cursor.getInt(cursor.getColumnIndex("pages")); double price = cursor.getDouble(cursor.getColumnIndex("price")); Log.d("MainActivity", "书名:" + name + "作者:" + author + "价格:" + price + "页数:" + pages); &#125; while (cursor.moveToNext()); &#125; cursor.close(); &#125; &#125;); &#125;&#125; 使用SQL操作数据库 添加数据的方法如下 1234db.execSQL("insert into Book (name, author, pages, price) values(?, ?, ?, ?)",new String[] &#123; "The Da Vinci Code", "Dan Brown", "454", "16.96" &#125;);db.execSQL("insert into Book (name, author, pages, price) values(?, ?, ?, ?)",new String[] &#123; "The Lost Symbol", "Dan Brown", "510", "19.95" &#125;); 更新数据的方法如下 1db.execSQL("update Book set price = ? where name = ?", new String[] &#123; "10.99", "The Da Vinci Code" &#125;); 删除数据的方法如下 1db.execSQL("delete from Book where pages &gt; ?", new String[] &#123; "500" &#125;); 查询数据的方法如下 1db.rawQuery("select * from Book", null); 使用这种方法建议学习一下数据库的书 使用LitePal操作数据库LitePal是一款开源的Android数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行了封装，使得不用编写一行SQL语句就可以完成各种建表和増删改查的操作。LitePal的项目主页上也有详细的使用文档，地址是：https://github.com/LitePalFramework/LitePal 过去的方式比较复杂，通常需要下载开源库的Jar包或者源码，然后再集成到我们的项目当中。而现在就简单得多了，大多数的开源项目都会将版本提交到jcenter上，我们只需要在app/build.gradle文件中声明该开源库的引用就可以了。 新建一个LitePalTest项目修改app/build.gradle文件，在dependencies闭包中添加如下内容1implementation 'org.litepal.android:java:3.0.0' 最新的版本建议自己到项目地址查看 配置litepal.xml文件 右击app/src/main目录→New→Directory，创建一个assets目录，然后在assets目录下再新建一个litepal.xml文件，接着编辑litepal.xml文件中的内容，这里dbname标签用于指定数据库名，version标签用于指定数据库版本号，list标签用于指定所有的映射模型 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt;&lt;dbname value="BookStore" &gt;&lt;/dbname&gt;&lt;version value="1" &gt;&lt;/version&gt;&lt;list&gt;&lt;/list&gt;&lt;/litepal&gt; 修改AndroidManifest.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.zanecode6574.databasetest"&gt; &lt;application android:name="org.litepal.LitePalApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 创建数据库LitePal采取的是对象关系映射（ORM）的模式，简单点说，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射了。 对象关系映射模式赋予了我们一个强大的功能，就是可以用面向对象的思维来操作数据库，而不用再和SQL语句打交道了。在6.4.1小节中，为了创建一张Book表，需要先分析表中应该包含哪些列，然后再编写出一条建表语句，最后在自定义的SQLiteOpenHelper中去执行这条建表语句。但是使用LitePal，就可以用面向对象的思维来实现同样的功能了. 将SQLiteTest项目的布局复制过来 定义一个Book类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zanecode6574.litepaltest;public class Book &#123; private int id; private String author; private double price; private int pages; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public int getPages() &#123; return pages; &#125; public void setPages(int pages) &#123; this.pages = pages; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 这是一个典型的Java bean，在Book类中我们定义了id、author、price、pages、name这几个字段，并生成了相应的getter和setter方法。Book类就会对应数据库中的Book表，而类中的每一个字段分别对应了表中的每一个列，这就是对象关系映射最直观的体验 将Book类添加到映射模型列表当中，修改litepal.xml的代码 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="1" &gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class="com.zanecode6574.litepaltest.Book"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 使用标签来声明我们要配置的映射模型类，注意一定要使用完整的类名。不管有多少模型类需要映射，都使用同样的方式配置在标签下即可。 现在只需要执行一次任意的数据库操作，数据库就会被创建出来 修改MainActivity中的代码 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createDatabase=findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); &#125; &#125;); &#125;&#125; 这里直接就创建好数据库了，十分方便. 这里原书上使用的是Litepal的1.4.1，而最新的版本是3.0.0，如果在dependencies中使用org.litepal.android:core:3.0.0,在MainActivity中就会没有Litepal这个对象使用，需要修改为org.litepal.android:java:3.0.0，好像是因为litepal做了更新，氛分为java和kotlin两种语言的 升级数据库这里解决了之前的疑问，之前的代码中升级数据库是将之前的表删除掉再建，而这里直接就可以完成，不用担心之前的表内数据丢失 向Book类中添加一个press(出版社)列 修改Book中的代码，添加一个press字段,同时生成get和set方法添加一张Category表 新建一个Category类 1234567891011121314151617181920212223242526272829public class Category &#123; private int id; private String categoryName; private int categoryCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCategoryName() &#123; return categoryName; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125; public int getCategoryCode() &#123; return categoryCode; &#125; public void setCategoryCode(int categoryCode) &#123; this.categoryCode = categoryCode; &#125;&#125; 修改litepal.xml的代码，添加Category的映射和修改版本号 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="BookStore" &gt;&lt;/dbname&gt; &lt;version value="2" &gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class="com.zanecode6574.litepaltest.Book"&gt;&lt;/mapping&gt; &lt;mapping class="com.zanecode6574.litepaltest.Category"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 添加数据观察现有的模型类，你会发现它们都是没有继承结构的。因为LitePal进行表管理操作时不需要模型类有任何的继承结构，但是进行CRUD操作时就不行了，必须要继承自DataSupport类才行，因此这里我们需要先把继承结构给加上 修改Book类的代码,让其继承自LitepalSupport类（原书用的DataSupport类，但是新版本中已经弃用并用前者代替） 修改MainActivity中的代码 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createDatabase=findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); &#125; &#125;); Button addData=findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setName("ZaneCode6574的书"); book.setAuthor("FFF"); book.setPages(666); book.setPrice(99.99); book.setPress("大学出版社"); book.save(); &#125; &#125;); &#125;&#125; 更新数据更新数据要比添加数据稍微复杂一点，因为它的API接口比较多，这里我们只介绍最常用的几种更新方式。 首先，最简单的一种更新方式就是对已存储的对象重新设值，然后重新调用save()方法即可。 对于LitePal来说，对象是否已存储就是根据调用model.isSaved()方法的结果来判断的，返回true就表示已存储，返回false就表示未存储。 实际上只有在两种情况下model.isSaved()方法才会返回true，一种情况是已经调用过model.save()方法去添加数据了，此时model会被认为是已存储的对象。另一种情况是model对象是通过LitePal提供的查询API查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象。 由于查询API我们暂时还没学到，因此只能先通过第一种情况来进行验证. 修改MainActivity代码（示例，弃用，首选下面的方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createDatabase=findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); &#125; &#125;); Button addData=findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setName("ZaneCode6574的书"); book.setAuthor("FFF"); book.setPages(666); book.setPrice(99.99); book.setPress("大学出版社"); book.save(); &#125; &#125;); Button updateData=findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setName("Zanecode6574的第二本书"); book.setAuthor("ZZZ"); book.setPrice(98.88); book.setPages(1000); book.setPress("不知道"); book.save(); book.setPrice(10.0); book.save(); &#125; &#125;); &#125;&#125; Book表中新增了一条书的数据，但这本书的价格并不是一开始设置的19.95，而是10.99，说明我们的更新操作确实生效了。但是这种更新方式只能对已存储的对象进行操作，限制性比较大，接下来我们学习另外一种更加灵巧的更新方式。 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createDatabase=findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); &#125; &#125;); Button addData=findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setName("ZaneCode6574的书"); book.setAuthor("FFF"); book.setPages(666); book.setPrice(99.99); book.setPress("大学出版社"); book.save(); &#125; &#125;); Button updateData=findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setPrice(98.88); book.setPages(9000); book.updateAll("name=? and author=?","Zanecode6574的第二本书","ZZZ"); &#125; &#125;); &#125;&#125; 首先new出了一个Book的实例，然后直接调用setPrice()和setPress()方法来设置要更新的数据，最后再调用updateAll()方法去执行更新操作。注意updateAll()方法中可以指定一个条件约束，和SQLiteDatabase中update()方法的where参数部分有点类似，但更加简洁，如果不指定条件语句的话，就表示更新所有数据。这里我们指定将所有书名是The Lost Symbol并且作者是Dan Brown的书价格更新为14.95，出版社更新为Anchor。 删除数据使用LitePal删除数据的方式主要有两种，第一种比较简单，就是直接调用已存储对象的delete()方法就可以了，对于已存储对象的概念，我们在上一小节中已经学习过了。也就是说，调用过save()方法的对象，或者是通过LitePal提供的查询API查出来的对象，都是可以直接使用delete()方法来删除数据的。这种方式比较简单，我们就不进行代码演示了，下面直接来看另外一种删除数据的方式。 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createDatabase=findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); &#125; &#125;); Button addData=findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setName("ZaneCode6574的书"); book.setAuthor("FFF"); book.setPages(666); book.setPrice(99.99); book.setPress("大学出版社"); book.save(); &#125; &#125;); Button updateData=findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setPrice(98.88); book.setPages(9000); book.updateAll("name=? and author=?","Zanecode6574的第二本书","ZZZ"); &#125; &#125;); Button deleteData=findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.deleteAll(Book.class,"price&lt;?","99.99"); &#125; &#125;); &#125;&#125; 这里书上使用的是DataSupport.deleteAll(),但是之前说了这个类已经弃用了在新版的litepal中，所以这里使用LitePal.deleteAll() 查询数据使用LitePal来查询数据一点都不复杂。我一直都认为LitePal在查询API方面的设计极为人性化，想想之前我们所使用的query()方法，冗长的参数列表让人看得头疼，即使多数参数都是用不到的，也不得不传入null，使用LitePal完成同样的功能非常简单，只需要这样写 1List&lt;Book&gt; books = DataSupport.findAll(Book.class); 修改MainActivity中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createDatabase=findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.getDatabase(); &#125; &#125;); Button addData=findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setName("ZaneCode6574的书"); book.setAuthor("FFF"); book.setPages(666); book.setPrice(99.99); book.setPress("大学出版社"); book.save(); &#125; &#125;); Button updateData=findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Book book=new Book(); book.setPrice(98.88); book.setPages(9000); book.updateAll("name=? and author=?","Zanecode6574的第二本书","ZZZ"); &#125; &#125;); Button deleteData=findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; LitePal.deleteAll(Book.class,"price&lt;?","99.99"); &#125; &#125;); Button queryButton=findViewById(R.id.query_data); queryButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; List&lt;Book&gt; books=LitePal.findAll(Book.class); for(Book book:books)&#123; Log.d("MainActivity", "书名:"+book.getName()+" "+"作者:"+book.getAuthor()+" "+"页数:"+book.getPages()+" "+"价格:"+book.getPrice()+" "+"出版社:"+book.getPress()); &#125; &#125; &#125;); &#125;&#125; 这里用的LitePal.findAll()，同上，原书使用的DataSupport() LitePal其他非常有用的查询API 查询Book表中的第一条数据 1Book firstBook = DataSupport.findFirst(Book.class); 查询Book表中的最后一条数据 1Book lastBook = DataSupport.findLast(Book.class); 连缀查询 select()方法用于指定查询哪几列的数据，对应了SQL当中的select关键字。比如只查name和author这两列的数据，就可以这样写 1List&lt;Book&gt; books = DataSupport.select("name", "author").find(Book.class); where()方法用于指定查询的约束条件，对应了SQL当中的where关键字。比如只查页数大于400的数据，就可以这样写 1List&lt;Book&gt; books = DataSupport.where("pages &gt; ?", "400").find(Book.class); order()方法用于指定结果的排序方式，对应了SQL当中的order by关键字。比如将查询结果按照书价从高到低排序，就可以这样写,其中desc表示降序排列，asc或者不写表示升序排列 1List&lt;Book&gt; books = DataSupport.order("price desc").find(Book.class); limit()方法用于指定查询结果的数量，比如只查表中的前3条数据，就可以这样写 1List&lt;Book&gt; books = DataSupport.limit(3).find(Book.class); offset()方法用于指定查询结果的偏移量，比如查询表中的第2条、第3条、第4条数据，就可以这样写,由于limit(3)查询到的是前3条数据，这里我们再加上offset(1)进行一个位置的偏移，就能实现查询第2条、第3条、第4条数据的功能了。limit()和offset()方法共同对应了SQL当中的limit关键字。 1List&lt;Book&gt; books = DataSupport.limit(3).offset(1).find(Book.class); 当然，你还可以对这5个方法进行任意的连缀组合，来完成一个比较复杂的查询操作 123456 List&lt;Book&gt; books = DataSupport.select("name", "author", "pages").where("pages &gt; ?", "400").order("pages").limit(10).offset(10).find(Book.class); 这段代码就表示，查询Book表中第11～20条满足页数大于400这个条件的name、author和pages这3列数据，并将查询结果按照页数升序排列。 LitePal仍然支持使用原生的SQL来进行查询 1Cursor c = DataSupport.findBySQL("select * from Book where pages &gt; ? and price &lt; ?", "400", "20"); 调用DataSupport.findBySQL()方法来进行原生查询，其中第一个参数用于指定SQL语句，后面的参数用于指定占位符的值。注意findBySQL()方法返回的是一个Cursor对象，接下来你还需要通过之前所学的老方式将数据一一取出才行。]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>数据储存</tag>
        <tag>持久化技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章：详解广播机制]]></title>
    <url>%2F2019%2F01%2F05%2F%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E8%AF%A6%E8%A7%A3%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[广播机制简介安卓中每个应用程序都可以对自己感兴趣的广播进行注册，广播可来自系统也可来自应用程序。 标准广播（Normal broadcasts） 一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的 有序广播（Ordered broadcasts） 一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了 尝试接收系统广播动态注册监听网络变化 新建BroadcastTest项目 在AndroidManifest.xml中添加代码注册网络权限 1&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; 修改MainActivity中的代码 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver); &#125; class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "network changes", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 这里定义了内部类NetworkChangeReceiver继承自BroadcastReceiver然后重写了onReceive函数，在onCreate中创建了一个IntentFilter的实例，并且添加了android.net.conn.CONNECTIVITY_CHANGE这个action，这是网络改变的时候系统会发出的一条广播的值，调用registerReceiver将两个实例传入就可以接收到这条广播了 添加对是否有网络的判断，修改MainActivity中NetworkChangeReceiver的代码 123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE"); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver); &#125; class NetworkChangeReceiver extends BroadcastReceiver &#123; public void onReceive(Context context,Intent intent)&#123; ConnectivityManager connectivityManager=(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo(); if(networkInfo!=null &amp;&amp; networkInfo.isAvailable())&#123; Toast.makeText(context, "网络已连接", Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(context, "网络已断开", Toast.LENGTH_SHORT).show(); &#125; //Toast.makeText(context,"网络改变了",Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 在onReceive()方法中，首先通过getSystemService()方法得到了ConnectivityManager的实例，这是一个系统服务类，专门用于管理网络连接的。然后调用它的getActiveNetworkInfo()方法可以得到NetworkInfo的实例，接着调用NetworkInfo的isAvailable()方法，就可以判断出当前是否有网络了 静态注册实现开机启动动态注册的广播比较自由，但是必须在程序启动以后才能收到广播，要让程序在未启动的时候收到广播就要用静态注册的方法 新建一个广播接收器右键点击包名，新建，选择Other-Broadcast Receiver，这里命名为BootCompleteReceiver，Exported属性表示是否允许这个广播接收器接收本程序以外的广播，Enabled属性表示是否启用这个广播接收器，都勾选上 修改BootCompleteReceiver的代码 123456public class BootCompleteReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "Boot Complete", Toast.LENGTH_LONG).show(); &#125;&#125; 在AndroidManifest.xml文件中注册静态广播（一定要） 1234567&lt;/application&gt; ··· &lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;/receiver&gt;&lt;/application&gt; 在application标签内添加receiver标签注册静态广播，用法和标签非常相似，也是通过android:name来指定具体注册哪一个广播接收器，而enabled和exported属性则是根据我们刚才勾选的状态自动生成的 添加接收开机广播的权限，同样修改AndroidManifest.xml 1&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/&gt; 12345678&lt;receiver android:name=".BootCompleteReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送自定义广播发送标准广播 定义一个广播接收器，准备接收自己的广播，新建一个MyBroadcastReceiver 1234567public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "收到自己的广播了！", Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125; 修改AndroidManifest.xml 123456&lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.broadcasttest.MY_BROADCAST"/&gt;&lt;/intent-filter&gt;&lt;/receiver&gt; 这里让MyBroadcastReceiver接收一条com.example.broadcasttest.MY_BROADCAST的广播，也就是我们要发出的广播 修改activity_main.xml的代码 12345&lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="match_parent" android:text="按钮"/&gt; 修改MainActivity中的代码 12345678Button button=findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent); &#125;&#125;); 为按钮添加事件，发送一个广播 发送有序广播广播是跨进程的通信方式，创建一个BroadcastTest2项目 新建一个AnotherBroadcastReceiver继承自BroadcastReceiver 123456public class AnotherBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "在另外的软件里收到了广播", Toast.LENGTH_SHORT).show(); &#125;&#125; 修改AndroidManifest.xml文件 1234567&lt;receiver android:name=".AnotherBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.broadcasttest.MY_BROADCAST"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 这里AnotherBroadcastReceiver同样接收com.example.broadcasttest.MY_BROADCAST广播 在BroadcastTest项目中点击按钮就会弹出两次提示，说明两个程序都收到了广播 发送有序广播，修改BroadcastTest项目中MainActivity中的代码 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcasttest.MY_BROADCAST"); sendOrderedBroadcast(intent, null); &#125; &#125;); ... &#125;...&#125; 发送有序广播只需要改动一行代码，即将sendBroadcast()方法改成sendOrderedBroadcast()方法。sendOrderedBroadcast()方法接收两个参数，第一个参数仍然是Intent，第二个参数是一个与权限相关的字符串，这里传入null就行了 设定有序广播的接收顺序 修改AndroidManifest.xml中的代码 12345678910111213141516171819&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"package="com.example.broadcasttest2"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; ... &lt;receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="com.example.broadcasttest.MY_BROADCAST" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt;&lt;/manifest&gt; 通过android:priority属性给广播接收器设定了优先级 选择是否允许广播继续传播 修改MyBroadcastReceiver中的代码 12345678public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received in MyBroadcastReceiver", Toast.LENGTH_SHORT).show(); abortBroadcast(); &#125;&#125; 这里表示将这条广播截断 使用本地广播前面我们发送和接收的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序接收到，并且我们也可以接收来自于其他任何应用程序的广播。这样就很容易引起安全性的问题，比如说我们发送的一些携带关键性数据的广播有可能被其他的应用程序截获，或者其他的程序不停地向我们的广播接收器里发送各种垃圾广播。为了能够简单地解决广播的安全性问题，Android引入了一套本地广播机制，使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播，这样所有的安全性问题就都不存在了。 本地广播使用LocalBroadcastManager来管理广播 修改MainActivity中的代码 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例 Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST"); localBroadcastManager.sendBroadcast(intent); // 发送本地广播 &#125; &#125;); intentFilter = new IntentFilter(); intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST"); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); localBroadcastManager.unregisterReceiver(localReceiver); &#125; class LocalReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 广播的最佳实践-实现强制下线功能创建ActivityCollector类1234567891011121314151617181920public class ActivityCollector &#123; public static List&lt;Activity&gt; activities=new ArrayList&lt;&gt;(); public static void addActivity(Activity activity)&#123; activities.add(activity); &#125; public static void removeActivity(Activity activity)&#123; activities.remove(activity); &#125; public static void finishAll()&#123; for(Activity activity:activities)&#123; if(!activity.isFinishing())&#123; activity.finish(); &#125; &#125; activities.clear(); &#125;&#125; 创建BaseActivity类作为所有活动的父类12345678910111213public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityCollector.addActivity(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this); &#125;&#125; 新建LoginActivity，这里选择空白活动 编辑activity_login.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".LoginActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:layout_marginLeft="30dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="账号"/&gt; &lt;EditText android:id="@+id/EditText_UserName" android:layout_width="0dp" android:layout_height="wrap_content" android:hint="输入账号" android:maxLines="1" android:layout_weight="1" android:layout_marginRight="30dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:layout_marginLeft="30dp" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="密码"/&gt; &lt;EditText android:id="@+id/EditText_Password" android:layout_width="0dp" android:layout_height="wrap_content" android:hint="输入密码" android:maxLines="1" android:layout_weight="1" android:inputType="textPassword" android:layout_marginRight="30dp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center"&gt; &lt;Button android:id="@+id/Button_Login" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="登陆"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 修改LoginActivity中的代码 12345678910111213141516171819202122232425262728293031public class LoginActivity extends BaseActivity &#123; private EditText userNameEdit; private EditText passwordEdit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); Button loginButton=findViewById(R.id.Button_Login); userNameEdit=findViewById(R.id.EditText_UserName); passwordEdit=findViewById(R.id.EditText_Password); loginButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String userName=userNameEdit.getText().toString(); String password=passwordEdit.getText().toString(); if(userName.equals("admin"))&#123; if(password.toString().equals("admin"))&#123; Intent intent=new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); &#125; &#125;else&#123; Toast.makeText(LoginActivity.this, "输入有误！", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125; 修改MainActivity 修改activity_main.xml的代码添加一个按钮 修改MainActivity中的代码 1234567891011121314151617public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=findViewById(R.id.Button_Main); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent("com.zanecode6574.cquclass.broadcastpractice.FORCE_OFFLINE"); sendBroadcast(intent); &#125; &#125;); &#125;&#125; 由于广播接收器里面需要弹出一个对话框来阻塞用户的正常操作，但如果创建的是一个静态注册的广播接收器，是没有办法在onReceive()方法里弹出对话框这样的UI控件的，而我们显然也不可能在每个活动中都去注册一个动态的广播接收器。那么只需要在BaseActivity中动态注册一个广播接收器就可以了，因为所有的活动都是继承自BaseActivity的。 修改BaseActivity中的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class BaseActivity extends AppCompatActivity &#123; private ForceOfflineReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityCollector.addActivity(this); &#125; @Override protected void onResume() &#123; super.onResume(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction("com.zanecode6574.cquclass.broadcastpractice.FORCE_OFFLINE"); receiver=new ForceOfflineReceiver(); registerReceiver(receiver,intentFilter); &#125; @Override protected void onPause() &#123; super.onPause(); if(receiver!=null)&#123; unregisterReceiver(receiver); receiver=null; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this); &#125; class ForceOfflineReceiver extends BroadcastReceiver&#123; @Override public void onReceive(final Context context, Intent intent) &#123; AlertDialog.Builder builder=new AlertDialog.Builder(context); builder.setTitle("警告"); builder.setMessage("强制下线！重新登录！"); builder.setCancelable(false); builder.setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCollector.finishAll(); Intent intent=new Intent(context,LoginActivity.class); context.startActivity(intent); &#125; &#125;); builder.show(); &#125; &#125;&#125; onReceive()方法里使用AlertDialog.Builder来构建一个对话框，注意这里一定要调用setCancelable()方法将对话框设为不可取消，否则用户按一下Back键就可以关闭对话框继续使用程序了。然后使用setPositiveButton()方法来给对话框注册确定按钮，当用户点击了确定按钮时，就调用ActivityCollector的finishAll()方法来销毁掉所有活动，并重新启动LoginActivity这个活动。注册ForceOfflineReceiver这个广播接收器的方法，可以看到，这里重写了onResume()和onPause()这两个生命周期函数，然后分别在这两个方法里注册和取消注册了ForceOfflineReceiver。之前都是在onCreate()和onDestroy()方法里来注册和取消注册广播接收器的，因为我们始终需要保证只有处于栈顶的活动才能接收到这条强制下线广播，非栈顶的活动不应该也没有必要去接收这条广播，所以写在onResume()和onPause()方法里就可以很好地解决这个问题，当一个活动失去栈顶位置时就会自动取消广播接收器的注册。 修改AndroidManifest.xml这里将主活动设置为LoginActivity即可 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.zanecode6574.cquclass.broadcastpractice"&gt; &lt;!-- To auto-complete the email text field in the login form with the user's emails --&gt; &lt;uses-permission android:name="android.permission.GET_ACCOUNTS" /&gt; &lt;uses-permission android:name="android.permission.READ_PROFILE" /&gt; &lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".LoginActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MainActivity"&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>广播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java远程操作完全分布式Hadoop集群]]></title>
    <url>%2F2018%2F12%2F21%2F%E9%85%8D%E7%BD%AEEcplise%E7%94%A8Java%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8FHadoop%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[前言再次说到最近的作业需要用Hadoop，网上随便搜都能搜到相应的代码，但是直接复制下来换IP换路径以后一直报错，没法读取Hadoop集群上的文件，又搞了一天，终于搞清楚了，这篇文章教你如何使用Ecplise远程操作Hadoop完全分布式集群，伪分布式理论也通用 环境 完全分布式hadoop集群（参考Hadoop分类第一篇文章） MacOS Ecplise Hadoop-2.8.5 配置步骤下载Hadoop-2.8.5和Hadoop-eclipse-plugin-2.8.5复制到下载器下载即可Hadoop-2.8.5: 1http://onedrive.zanecode6574.com/hadoop-2.8.5.tar.gz Hadoop-eclipse-plugin-2.8.5： 1http://onedrive.zanecode6574.com/Hadoop-eclipse-plugin-2.8.5.zip 配置Ecplise 解压Hadoop-eclipse-plugin-2.8.5，复制release文件夹内的包到Ecplise安装目录的Ecplise/dropins文件夹（有人说是plugins文件夹，个人测试是dropins文件夹，具体自己试试） 重启Ecplise 打开Ecplise-Window-Show View-Other，选择MapReduce Tools-Map/Reduce Location 点击如图的位置添加服务器位置(可能界面有点差别，我调整过) 设置如下到此就设置完成了 测试项目 创建一个项目，选择File-New-Other-Map/Reduce Project 添加Hadoop-2.8.5目录（这里下载Hadoop是为了开发环境用，不需要配置，解压出来就行了） 创建完成在项目上方会看到一个选项能看见你设置的Hadoop远程服务器上的目录和文件 测试从Hadoop读取文件,在项目中新建class名字为MyFSDataInputStream继承FSDataInputStream，地址自己设置（我在Hadoop目录添加了一个文件夹叫做Hadoop，上传了1.txt到这个文件夹下面,如何上传自行百度Hadoop基本操作，创建和上传都是在主节点上完成的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.apache.hadoop.fs.FSDataInputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.*;public class MyFSDataInputStream extends FSDataInputStream &#123; public MyFSDataInputStream(InputStream in) &#123; super(in); &#125; public static String readline(Configuration conf, String remoteFilePath) &#123; try (FileSystem fs = FileSystem.get(conf)) &#123; Path remotePath = new Path(remoteFilePath); FSDataInputStream in = fs.open(remotePath); BufferedReader d = new BufferedReader(new InputStreamReader(in)); String line = null; if ((line = d.readLine()) != null) &#123; d.close(); in.close(); return line; &#125; return null; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; Configuration conf = new Configuration(); conf.set("fs.default.name", "hdfs://122.152.230.48:9000"); String remoteFilePath = "/hadoop/1.txt"; // HDFS路径 System.out.println("读取文件: " + remoteFilePath); System.out.println(MyFSDataInputStream.readline(conf, remoteFilePath)); System.out.println("\n读取完成"); &#125; &#125; 成功读取文件前面两行报错可以忽略，或者自行百度解决；后面的warning是因为jdk版本问题，也可以忽略，读取成功输出文本第一行，也就是我打码的地方 最后配置整个Hadoop环境花了很多时间，网上很多博客都没雨说清楚具体该怎么做，我也是参考别人的做出来，文中需要的程序在网盘里都有]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Ecplise</tag>
        <tag>远程</tag>
        <tag>完全分布式Hadoop集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop完全分布式搭建]]></title>
    <url>%2F2018%2F12%2F19%2Fhadoop%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言最近上课需要用到hadoop环境，正好手里有三台空闲的学生机，于是想用这三台学生机搭建hadoop完全分布式环境，遇到的坑实在是太大了，在这里做个记录，为了简化操作，以下服务器全部用root直接登陆，实际生产中不建议这样操作 配置云服务器 服务器hostname 公网IP 内网IP 供应商 master MasterPublic MasterPrivate 腾讯云 slave1 Slave1Public Slave1Private 腾讯云 slave2 Slave2Public Slave2Private 阿里云 服务器系统都为Ubuntu16.04 x64 搭建完全分布式hadoop环境以下操作需要在每台机器上都进行一次 修改hostname1vim /etc/hostname 修改每个服务器hostname为自己指定的名字 关闭防火墙1ufw disable 修改主机上的hosts文件映射1vim /etc/hosts 此处很重要，多数教程使用的都是本地虚拟机，因此只有一个内网IP，但是使用云服务器，服务器包含公网IP和内网IP，每台服务器上的hosts文件里面对本机的映射要填写本机的内网IP，对于另外节点的映射要填写公网IP。如 master上的hosts文件 12345MasterPrivate masterSlave1Public slave1Slave2Public slave2 slave1上的hosts文件 12345MasterPublic masterSlave1Private slave1Slave2Public slave2 按照此规则修改每台主机上的hosts文件即可，修改完成可用ping -c 3 hostname验证是否能够通信 不按照这个规则填写hosts文件，会出现的问题就是主机启动的时候无限报错端口占用，实际上并没有端口占用 配置jdk下载jdk并解压至指定目录1wget http://onedrive.zanecode6574.com/jdk-8u191-linux-x64.tar.gz &amp;&amp; mkdir /opt/java &amp;&amp; tar -zxvf jdk-8u191-linux-x64.tar.gz &amp;&amp; mv jdk1.8.0_191 /opt/java/ 配置环境变量1vim /etc/profile 在文件末尾添加如下代码 1234export JAVA_HOME=/opt/java/jdk1.8.0_191export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 配置免密登陆节点服务器1ssh-keygen –t rsa 会在/root/.ssh文件夹下生成密钥，其中id_rsa.pub是每台机器的公钥，将三台主机的id_rsa.pub里面的内容复制到文件authorized_keys中，上传authorized_keys到三台服务器的/root/.ssh文件夹下并设置权限与id_rsa.pub相同 测试免密登陆1ssh hostname 如果成功的话第一次会让你输入yes，然后就登陆上指定hostname的主机了，登陆上记得要exit退出否则命令都是在hostname的机器上运行的 下载Hadoop-2.8.5点击前往下载 或者 1wget http://onedrive.zanecode6574.com/hadoop-2.8.5.tar.gz &amp;&amp; tar -zxvf hadoop-2.8.5.tar.gz &amp;&amp; mv hadoop-2.8.5 /opt/hadoop/ &amp;&amp; cd /opt/hadoop/hadoop-2.8.5/ 新建目录1mkdir tmp &amp;&amp; mkdir hdfs &amp;&amp; mkdir hdfs/name &amp;&amp; mkdir hdfs/data 开始修改配置文件此操作开始仅在主机上进行即可 1cd /opt/hadoop/hadoop-2.8.5/etc/hadoop 修改hadoop-env.sh,添加代码 12#修改JAVA安装路径export JAVA_HOME=/opt/java/jdk1.8.0_191 修改core-site.xml 1234567891011121314151617&lt;configuration&gt;&lt;!--配置hdfs文件系统的命名空间--&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt;&lt;!-- 配置操作hdfs的存冲大小 --&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt;&lt;!-- 配置临时数据存储目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/hadoop-2.8.5/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改hdfs-site.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;configuration&gt; &lt;!--配置副本数--&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt;&lt;!--hdfs的元数据存储位置--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/hadoop-2.8.5/hdfs/name&lt;/value&gt; &lt;/property&gt;&lt;!--hdfs的数据存储位置--&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop/hadoop-2.8.5/hdfs/data&lt;/value&gt; &lt;/property&gt;&lt;!--hdfs的namenode的web ui 地址--&gt; &lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;master:50070&lt;/value&gt; &lt;/property&gt;&lt;!--hdfs的snn的web ui 地址--&gt; &lt;property&gt; &lt;name&gt;dfs.secondary.http.address&lt;/name&gt; &lt;value&gt;master:50090&lt;/value&gt; &lt;/property&gt;&lt;!--是否开启web操作hdfs--&gt; &lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;&lt;!--是否启用hdfs权限（acl）--&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 新建文件mapred-site.xml，配置如下 1234567891011121314151617&lt;configuration&gt;&lt;!--指定maoreduce运行框架--&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;!--历史服务的通信地址--&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; &lt;/property&gt;&lt;!--历史服务的web ui地址--&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改slaves文件，去掉loacalhost，填入主机名一行一个 123masterslave1slave2 修改yarn-site.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;configuration&gt; &lt;!-- Site specific YARN configuration properties --&gt;&lt;!--指定resourcemanager所启动的服务器主机名--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt;&lt;!--指定mapreduce的shuffle--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;!--指定resourcemanager的内部通讯地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:8032&lt;/value&gt; &lt;/property&gt;&lt;!--指定scheduler的内部通讯地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:8030&lt;/value&gt; &lt;/property&gt;&lt;!--指定resource-tracker的内部通讯地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:8031&lt;/value&gt; &lt;/property&gt;&lt;!--指定resourcemanager.admin的内部通讯地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;master:8033&lt;/value&gt; &lt;/property&gt;&lt;!--指定resourcemanager.webapp的ui监控地址--&gt;&lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:8088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 分发配置文件（复制配置文件到各个剩余的节点） 1scp hadoop-env.sh core-site.xml hdfs-site.xml mapred-site.xml slaves yarn-site.xml slave1:/opt/hadoop/hadoop-2.8.5/etc/hadoop/ 有多少个节点自己拷贝到相应的hostname就行了 主节点格式化1cd /opt/hadoop/hadoop-2.8.5/bin &amp;&amp; ./hdfs namenode -format 启动1cd /opt/hadoop/hadoop-2.8.5/sbin &amp;&amp; ./start-all.sh 注意事项 启动后可以通过jps命令查看节点上的进程 浏览器访问主节点IP:50070可以查看到状态页面 无法访问或者有任何错误自行查看hadoop-2.8.5文件夹下的logs文件夹日志]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>完全分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章：兼顾手机与平板-探究碎片]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%85%BC%E9%A1%BE%E6%89%8B%E6%9C%BA%E4%B8%8E%E5%B9%B3%E6%9D%BF-%E6%8E%A2%E7%A9%B6%E7%A2%8E%E7%89%87%2F</url>
    <content type="text"><![CDATA[碎片（Fragment）是一种可以嵌入在活动当中的UI片段，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛。手机的界面如下平板的界面如下如果平板按照手机的设置就会导致界面上有大量的空白区域，因此，更好的设计方案是将新闻标题列表界面和新闻详细内容界面分别放在两个碎片中，然后在同一个活动里引入这两个碎片，这样就可以将屏幕空间充分地利用起来了。 碎片的简单用法 新建FragmentTest项目 新建一个左侧碎片布局left_fragment.xml1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:text="Button"/&gt;&lt;/LinearLayout&gt; 这个布局非常简单，只放置了一个按钮，并让它水平居中显示 新建右侧碎片布局right_fragment.xml12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"android:orientation="vertical"android:background="#00ff00"android:layout_width="match_parent"android:layout_height="match_parent"&gt;&lt;TextViewandroid:layout_width="wrap_content"android:layout_height="wrap_content"android:layout_gravity="center_horizontal"android:textSize="20sp"android:text="This is right fragment"/&gt;&lt;/LinearLayout&gt; 这个布局的背景色设置成了绿色，并放置了一个TextView用于显示一段文本 新建一个LeftFragment类，继承自Fragment，这里可能会有两个不同包下的Fragment供你选择，一个是系统内置的android.app.Fragment，一个是support-v4库中的android.support.v4．app.Fragment。这里我强烈建议你使用support-v4库中的Fragment，因为它可以让碎片在所有Android系统版本中保持功能一致性，这里不需要单独引入这个依赖，因为build.gradle已经添加了appcompat-v7的依赖，这个库会将support-v4引入12345678public class LeftFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.left_fragment, container, false); return view; &#125;&#125; 这里重写了onCreateView方法，通过LayoutInflater方法将刚才定义的left_fragment布局动态加载进来了 新建一个RightFragment类 12345678public class RightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.right_fragment, container, false); return view; &#125;&#125; 修改activity_main中的代码 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;fragment android:id="@+id/right_fragment" android:name="com.example.fragmenttest.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt;&lt;/LinearLayout&gt; 这里在&lt;Fragment&gt;标签中添加碎片，这里需要通过android:name属性来指明要添加的碎片类名，一定要将类的包名也加上 动态添加碎片碎片真正强大的地方在于可以在程序运行时动态的添加到活动当中，在上一个项目的基础上完善 添加another_right_fragment.xml 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:background="#ffff00" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:textSize="20sp" android:text="This is another right fragment" /&gt;&lt;/LinearLayout&gt; 新建AnotherRightFragment类 12345678public class AnotherRightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.another_right_fragment,container,false); return view; &#125;&#125; 修改activity_main文件，动态添加到活动中 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;FrameLayout android:id="@+id/right_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" &gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 这里将右侧碎片替换成了一个FrameLayout，这是Android中最简单的布局，所有控件都会放在左上角，由于这里是在布局中放入一个碎片，不需要任何定位，因此适合使用FrameLayout 向FrameLayout中添加内容，实现动态添加碎片的功能，修改MainActivity中的代码1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(this); replaceFragment(new RightFragment()); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: replaceFragment(new AnotherRightFragment()); break; default: break; &#125;&#125; private void replaceFragment(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.replace(R.id.right_layout, fragment); transaction.commit(); &#125;&#125; 首先我们给左侧碎片中的按钮注册了一个点击事件，然后调用replaceFragment()方法动态添加了RightFragment这个碎片。当点击左侧碎片中的按钮时，又会调用replaceFragment()方法将右侧碎片替换成AnotherRightFragment 总结动态添加碎片步骤 创建待添加的碎片实例 获取FragmentManager，在活动中可以直接通过调用getSupportFragmentManager()方法得到 开启一个事务，通过调用beginTransaction()方法开启 向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例 提交事务，调用commit()方法来完成 在碎片中模拟返回栈模仿类似于返回栈的效果，按下back键返回到上一个碎片。FragmentTransaction中提供了一个addToBackStack方法，可用于将一个事务添加到返回栈中，修改MainActivity中的代码12345678910public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; ... private void replaceFragment(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.replace(R.id.right_layout, fragment); transaction.addToBackStack(null); transaction.commit(); &#125;&#125; 这里我们在事务提交之前调用了FragmentTransaction的addToBackStack()方法，它可以接收一个名字用于描述返回栈的状态，一般传入null即可。现在重新运行程序，并点击按钮将AnotherRightFragment添加到活动中，然后按下Back键，你会发现程序并没有退出，而是回到了RightFragment界面，继续按下Back键，RightFragment界面也会消失，再次按下Back键，程序才会退出 碎片和活动之间进行通信FragmentManager中提供了一个类似于findViewById的方法，专门用于从布局文件中获取碎片的实例 在活动中调用碎片:12RightFragment rightFragment = (RightFragment) getSupportFragmentManager().findFragmentById(R.id.right_fragment); 调用FragmentManager的findFragmentById()方法，可以在活动中得到相应碎片的实例，然后就能轻松地调用碎片里的方法了 在碎片中调用活动的方法每个碎片都可以通过getActivity方法来得到当前碎片相关联的活动实例1MainActivity activity=(MainActivity)getActivity(); 有了活动实例以后，在碎片中调用活动里的方法就变得很容易了，当碎片中需要使用Context对象时也可以使用getActivity方法，因为获取到的活动本身就是一个Context对象 碎片与碎片通信：在碎片中得到与之关联的活动，再从活动中获取另外一个碎片的实例 碎片的生命周期 运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。 暂停状态：当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关联的可见碎片就会进入到暂停状态。 停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但如果在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。 销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入到销毁状态。 活动中有的回调方法，碎片中几乎都有，不过碎片还提供了一些附加的回调方法，那我们就重点看一下这几个回调 onAttach()。当碎片和活动建立关联的时候调用 onCreateView()。为碎片创建视图（加载布局）时调用 onActivityCreated()。确保与碎片相关联的活动一定已经创建完毕的时候调用 onDestroyView()。当与碎片关联的视图被移除的时候调用 onDetach()。当碎片和活动解除关联的时候调用 体验碎片的生命周期，修改RightFragment中的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class RightFragment extends Fragment &#123; public static final String TAG = "RightFragment"; @Override public void onAttach(Context context) &#123; super.onAttach(context); Log.d(TAG, "onAttach"); &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(TAG, "onCreate"); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.d(TAG, "onCreateView"); View view = inflater.inflate(R.layout.right_fragment, container, false); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); Log.d(TAG, "onActivityCreated"); &#125; @Override public void onStart() &#123; super.onStart(); Log.d(TAG, "onStart"); &#125; @Override public void onResume() &#123; super.onResume(); Log.d(TAG, "onResume"); &#125; @Override public void onPause() &#123; super.onPause(); Log.d(TAG, "onPause"); &#125; @Override public void onStop() &#123; super.onStop(); Log.d(TAG, "onStop"); &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); Log.d(TAG, "onDestroyView"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy"); &#125; @Override public void onDetach() &#123; super.onDetach(); Log.d(TAG, "onDetach"); &#125;&#125; 在碎片中也是可以通过onSaveInstanceState()方法来保存数据的，因为进入停止状态的碎片有可能在系统内存不足的时候被回收。保存下来的数据在onCreate()、onCreateView()和onActivityCreated()这3个方法中你都可以重新得到，它们都含有一个Bundle类型的savedInstanceState参数 动态加载布局的技巧使用限定符使用限定符让程序自己判断使用双页或者单页模式 修改FragmentTest中的activity_main文件12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 这里将多余的代码都删掉，只留下一个左侧碎片，并让它充满整个父布局。 接着在res目录下新建layout-large文件夹，在这个文件夹下新建一个布局，也叫作activity_main.xml1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;fragment android:id="@+id/right_fragment" android:name="com.example.fragmenttest.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3" /&gt;&lt;/LinearLayout&gt; 可以看到，layout/activity_main布局只包含了一个碎片，即单页模式，而layout-large/ activity_main布局包含了两个碎片，即双页模式。其中large就是一个限定符，那些屏幕被认为是large的设备就会自动加载layout-large文件夹下的布局，而小屏幕的设备则还是会加载layout文件夹下的布局 将MainActivity中的replaceFragment方法中的代码注释掉，重新运行程序就会自动根据模拟器来选择显示模式 Android常见限定符参考￼￼ 使用最小宽度限定符最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以dp为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局 在res目录下新建layout-sw600dp文件夹，在此文件夹下新建activity_main.xml布局1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/left_fragment" android:name="com.example.fragmenttest.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;fragment android:id="@+id/right_fragment" android:name="com.example.fragmenttest.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3" /&gt;&lt;/LinearLayout&gt; 当程序运行在屏幕宽度大于600dp的设备上时，会加载layout-sw600dp/activity_main布局，当程序运行在屏幕宽度小于600dp的设备上时，则仍然加载默认的layout/activity_main布局 碎片最佳实践-简易版新闻应用 新建FragmentBestPractice项目，需要用到RecyclerView，需要添加依赖库 123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:24.2.1' testCompile 'junit:junit:4.12' compile 'com.android.support:recyclerview-v7:24.2.1'&#125; 准备新闻实体类，创建类News 12345678910111213141516public class News &#123; private String title; private String content; public String getTitle() &#123; return title;&#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 新建布局文件news_content_frag.xml 12345678910111213141516171819202122232425262728293031323334&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/visibility_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:visibility="invisible" &gt; &lt;TextView android:id="@+id/news_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:padding="10dp" android:textSize="20sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#000" /&gt; &lt;TextView android:id="@+id/news_content" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:padding="15dp" android:textSize="18sp" /&gt;&lt;/LinearLayout&gt; &lt;View android:layout_width="1dp" android:layout_height="match_parent" android:layout_alignParentLeft="true" android:background="#000" /&gt;&lt;/RelativeLayout&gt; 新闻内容的布局主要可以分为两个部分，头部部分显示新闻标题，正文部分显示新闻内容，中间使用一条细线分隔开。这里的细线是利用View来实现的，将View的宽或高设置为1dp，再通过background属性给细线设置一下颜色就可以了。这里我们把细线设置成黑色。 新建NewsContentFragment类，继承自Fragment类12345678910111213141516public class NewsContentFragment extends Fragment &#123; private View view; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; view = inflater.inflate(R.layout.news_content_frag, container, false); return view; &#125; public void refresh(String newsTitle, String newsContent) &#123; View visibilityLayout = view.findViewById(R.id.visibility_layout); visibilityLayout.setVisibility(View.VISIBLE); TextView newsTitleText = (TextView) view.findViewById(R.id.news_title); TextView newsContentText = (TextView)view.findViewById(R.id.news_content); newsTitleText.setText(newsTitle); // 刷新新闻的标题 newsContentText.setText(newsContent); // 刷新新闻的内容 &#125;&#125; 首先在onCreateView()方法里加载了我们刚刚创建的news_content_frag布局，接下来又提供了一个refresh()方法，用于将新闻的标题和内容显示在界面上。这里通过findViewById()方法分别获取到新闻标题和内容的控件，然后将方法传递进来的参数设置进去。这样我们就把新闻内容的碎片和布局都创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还需要再创建一个活动。右击com.example.fragmentbestpractice包→New→Activity→Empty Activity，新建一个NewsContentActivity，并将布局名指定成news_content，然后修改news_content.xml中的代码，如下所示：1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/news_content_fragment" android:name="com.example.fragmentbestpractice.NewsContentFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 这里我们充分发挥了代码的复用性，直接在布局中引入了NewsContentFragment，这样也就相当于把news_content_frag布局的内容自动加了进来。 修改NewsContentActivity中的代码123456789101112131415161718public class NewsContentActivity extends AppCompatActivity &#123; public static void actionStart(Context context, String newsTitle, StringnewsContent) &#123; Intent intent = new Intent(context, NewsContentActivity.class); intent.putExtra("news_title", newsTitle); intent.putExtra("news_content", newsContent); context.startActivity(intent);&#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.news_content); String newsTitle = getIntent().getStringExtra("news_title"); // 获取传入的新闻标题 String newsContent = getIntent().getStringExtra("news_content"); // 获取传入的新闻内容 NewsContentFragment newsContentFragment = (NewsContentFragment)getSupportFragmentManager().findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(newsTitle, newsContent); //刷NewsContent_Fragment界面 &#125;&#125; 在onCreate()方法中我们通过Intent获取到了传入的新闻标题和新闻内容，然后调用FragmentManager的findFragmentById()方法得到了NewsContentFragment的实例，接着调用它的refresh()方法，并将新闻的标题和内容传入，就可以把这些数据显示出来了 创建一个用于显示新闻列表的布局，新建news_title_frag.xml 12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7．widget.RecyclerView android:id="@+id/news_title_recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 新建news_item.xml作为RecyclerView子项的布局 1234567891011&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/news_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:maxLines="true" android:ellipsize="end" android:textSize="18sp" android:paddingLeft="10dp" android:paddingRight="10dp" android:paddingTop="15dp" android:paddingBottom="15dp" /&gt; android:padding表示给控件的周围加上补白，这样不至于让文本内容会紧靠在边缘上android:maxLines设置为true表示让这个TextView只能单行显示android:ellipsize用于设定当文本内容超出控件宽度时，文本的缩略方式，这里指定成end表示在尾部进行缩略 创建展示新闻列表的地方，新建NewsTitleFragment作为展示新闻列表的碎片123456789101112131415161718public class NewsTitleFragment extends Fragment &#123; private boolean isTwoPane; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.news_title_frag, container, false); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (getActivity().findViewById(R.id.news_content) != null) &#123; isTwoPane = true; // 可以找到news_content_layout布局时，为双页模式 &#125; else &#123; isTwoPane = false; // 找不到news_content_layout布局时，为单页模式 &#125; &#125;&#125; 在onCreateView()方法中加载了news_title_frag布局，onActivityCreated()方法通过在活动中能否找到一个id为news_content_layout的View来判断当前是双页模式还是单页模式，因此我们需要让这个id为news_content_layout的View只在双页模式中才会出现,借助限定符进行操作 修改activity_main中的代码 1234567891011&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"android:id="@+id/news_title_layout"android:layout_width="match_parent"android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/news_title_fragment" android:name="com.example.fragmentbestpractice.NewsTitleFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/FrameLayout&gt; 新建layout-sw600dp文件夹，在此文件夹下新建activity_main文件 12345678910111213141516171819202122&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;fragment android:id="@+id/news_title_fragment" android:name="com.example.fragmentbestpractice.NewsTitleFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" /&gt; &lt;FrameLayout android:id="@+id/news_content_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="3" &gt; &lt;fragment android:id="@+id/news_content_fragment" android:name="com.example.fragmentbestpractice.NewsContentFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 可以看出，在双页模式下我们同时引入了两个碎片，并将新闻内容的碎片放在了一个FrameLayout布局下，而这个布局的id正是news_content_layout。因此，能够找到这个id的时候就是双页模式，否则就是单面模式 在NewsTitleFragment中通过RecyclerView将新闻列表展示出来，在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class NewsTitleFragment extends Fragment &#123; private boolean isTwoPane; ... class NewsAdapter extends RecyclerView.Adapter&lt;NewsAdapter.ViewHolder&gt; &#123; private List&lt;News&gt; mNewsList; class ViewHolder extends RecyclerView.ViewHolder &#123; TextView newsTitleText; public ViewHolder(View view) &#123; super(view); newsTitleText = (TextView) view.findViewById(R.id.news_title); &#125; &#125; public NewsAdapter(List&lt;News&gt; newsList) &#123; mNewsList = newsList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_item, parent, false); final ViewHolder holder = new ViewHolder(view); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; News news = mNewsList.get(holder.getAdapterPosition()); if (isTwoPane) &#123; // 如果是双页模式，则刷新NewsContentFragment中的内容 NewsContentFragment newsContentFragment = (NewsContentFragment) getFragmentManager().findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(news.getTitle(), news.getContent()); &#125; else &#123; // 如果是单页模式，则直接启动NewsContentActivity NewsContentActivity.actionStart(getActivity(), news.getTitle(), news.getContent()); &#125; &#125; &#125;); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; News news = mNewsList.get(position); holder.newsTitleText.setText(news.getTitle()); &#125; @Override public int getItemCount() &#123; return mNewsList.size(); &#125; &#125;&#125; 需要注意的是，之前我们都是将适配器写成一个独立的类，其实也是可以写成内部类，这里写成内部类的好处就是可以直接访问NewsTitleFragment的变量，比如isTwoPaneonCreateViewHolder()方法中注册的点击事件，首先获取到了点击项的News实例，然后通过isTwoPane变量来判断当前是单页还是双页模式，如果是单页模式，就启动一个新的活动去显示新闻内容，如果是双页模式，就更新新闻内容碎片里的数据 最后一步工作，往RecyclerView中填充数据,修改NewsTitleFragment代码123456789101112131415161718192021222324252627282930313233public class NewsTitleFragment extends Fragment &#123; ... @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.news_title_frag, container, false); RecyclerView newsTitleRecyclerView = (RecyclerView) view.findViewById(R.id.news_title_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity()); newsTitleRecyclerView.setLayoutManager(layoutManager); NewsAdapter adapter = new NewsAdapter(getNews()); newsTitleRecyclerView.setAdapter(adapter); return view; &#125; private List&lt;News&gt; getNews() &#123; List&lt;News&gt; newsList = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 50; i++) &#123; News news = new News(); news.setTitle("This is news title " + i); news.setContent(getRandomLengthContent("This is news content " + i + ". ")); newsList.add(news); &#125; return newsList; &#125; private String getRandomLengthContent(String content) &#123; Random random = new Random(); int length = random.nextInt(20) + 1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; builder.append(content); &#125; return builder.toString(); &#125; ...&#125; onCreateView()方法中添加了RecyclerView标准的使用方法，在碎片中使用RecyclerView和在活动中使用几乎是一模一样的。这里调用了getNews()方法来初始化50条模拟新闻数据，同样使用了一个getRandomLengthContent()方法来随机生成新闻内容的长度，以保证每条新闻的内容差距比较大]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章：UI开发、布局、控件]]></title>
    <url>%2F2018%2F11%2F13%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AUI%E5%BC%80%E5%8F%91%E3%80%81%E5%B8%83%E5%B1%80%E3%80%81%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[常用控件的使用方法TextView android: id =&quot;@ + id/ text_ view&quot; 控件ID android: layout_ width =&quot; match_ parent&quot; 宽度：和父布局大小一样，match_parent和fill_parent意义一样，官方推荐使用match_parent android: layout_ height =&quot; wrap_ content&quot; 高度，wrap_content表示刚好包含控件内的内容 android: gravity =&quot; center&quot; android:gravity指定对齐方式，可选值有 top、 bottom、 left、 right、 center等，可以用“ |”来同时指定多个值，这里我们指定的 center，效果等同于 center_ vertical | center_ horizontal，表示文字在垂直和水平方向都居中对齐 android: textSize =&quot; 24sp&quot; 文本大小，单位sp android: textColor =&quot;# 00ff00&quot; 颜色 android: text =&quot; This is TextView&quot; 显示的文字 Button android: id =&quot;@ + id/ button&quot; android: layout_ width =&quot; match_ parent&quot; android: layout_ height =&quot; wrap_ content&quot; android: text =&quot; Button&quot; android: textAllCaps =&quot; false&quot; 表示显示的字母全部大写，设置为false显示原输入，否则全部转换为大写显示 两种方法为Button添加监听函数 匿名类方式 1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); Button button = (Button) findViewById( R. id. button); button. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; //在此处添加逻辑 &#125; &#125;); &#125; &#125; 实现接口方式 1234567891011121314151617public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); Button button = (Button) findViewById( R. id. button); button. setOnClickListener( this); &#125; @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: //在此处添加逻辑 break; default: break; &#125; &#125; &#125; 两种方式看个人喜好 EditText android: id =&quot;@ + id/ edit_ text&quot; android: layout_ width =&quot; match_ parent&quot; android: layout_ height =&quot; wrap_ content&quot; android: hint =&quot; Type something here&quot; 输入框的提示效果 android: maxLines =&quot; 2&quot; 由于输入框是wrap_content，如果一直输入会变得很大，设定最大行数就可以解决这个问题 获取EditText的输入文字 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; private EditText editText; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); Button button = (Button) findViewById( R. id. button); editText = (EditText) findViewById( R. id. edit_ text); button. setOnClickListener( this); &#125; @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: String inputText = editText. getText(). toString(); Toast. makeText( MainActivity. this, inputText, Toast. LENGTH_ SHORT). show(); break; default: break; &#125; &#125; &#125; ImageView android: id =&quot;@ + id/ image_ view&quot; android: layout_ width =&quot; wrap_ content&quot; android: layout_ height =&quot; wrap_ content&quot; android: src =&quot;@ drawable/ img_ 1&quot; 记一下，这里ImageView有一个属性叫做adjustViewBounds，对于这个属性，如果不设置默认就是fasle，我在使用ConstraintLayout的时候，如果是这个属性为flase，那么图片就算是设置为wrap_content,图片周围还是会出现留空的问题，设置为true以后就是严格wrap了，就不会出现多余的位置 动态更改ImageView的图片 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; private EditText editText; private ImageView imageView; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); Button button = (Button) findViewById( R. id. button); editText = (EditText) findViewById( R. id. edit_ text); imageView = (ImageView) findViewById( R. id. image_ view); button. setOnClickListener( this); &#125; @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: imageView. setImageResource( R. drawable. img_ 2); break; default: break; &#125; &#125; &#125; ProgressBar 在界面上显示一个进度条 1234567&lt; ProgressBar android: id ="@ + id/ progress_ bar" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" style ="? android: attr/ progressBarStyleHorizontal" android: max =" 100" /&gt; style一行表示把进度条显示为水平进度条，不指定就默认是圆形，max设置了最大值 动态更改进度条 1234567891011121314public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; ... @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: int progress = progressBar. getProgress(); progress = progress + 10; progressBar. setProgress( progress); break; default: break; &#125; &#125; &#125; 实现点击出现点击消失 Android控件的可见属性。所有的 Android控件都具有这个属性，可以通过 android: visibility进行指定，可选值有 3种： visible、 invisible和 gone。 visible表示控件是可见的，这个值是默认值，不指定 android: visibility时，控件都是可见的。 invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。 gone则表示控件不仅不可见，而且不再占用任何屏幕空间。1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; private EditText editText; private ImageView imageView; private ProgressBar progressBar; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); Button button = (Button) findViewById( R. id. button); editText = (EditText) findViewById( R. id. edit_ text); imageView = (ImageView) findViewById( R. id. image_ view); progressBar = (ProgressBar) findViewById( R. id. progress_ bar); button. setOnClickListener( this); &#125; @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: if (progressBar. getVisibility() = = View. GONE) &#123; progressBar. setVisibility( View. VISIBLE); &#125; else &#123; progressBar. setVisibility( View. GONE); &#125; break; default: break; &#125; &#125; &#125; AlertDialog AlertDialog可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此 AlertDialog一般都是用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; ... @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: AlertDialog. Builder dialog = new AlertDialog. Builder (MainActivity. this); dialog. setTitle(" This is Dialog"); dialog. setMessage(" Something important."); dialog. setCancelable( false); dialog. setPositiveButton(" OK", new DialogInterface. OnClickListener() &#123; @Override public void onClick( DialogInterface dialog, int which) &#123; &#125; &#125;); dialog. setNegativeButton(" Cancel", new DialogInterface. OnClickListener() &#123; @Override public void onClick( DialogInterface dialog, int which) &#123; &#125; &#125;); dialog. show(); break; default: break; &#125; &#125; &#125; ProgressDialog ProgressDialog和 AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。不同的是， ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待123456789101112131415161718public class MainActivity extends AppCompatActivity implements View. OnClickListener &#123; ... @Override public void onClick( View v) &#123; switch (v. getId()) &#123; case R. id. button: ProgressDialog progressDialog = new ProgressDialog (MainActivity. this); progressDialog. setTitle(" This is ProgressDialog"); progressDialog. setMessage(" Loading..."); progressDialog. setCancelable( true); //如果在这里传入false，代表不能通过返回键取消，则需要在进度完成时调用ProgressDialog的dismiss函数来关闭对话框 progressDialog. show(); break; default: break; &#125; &#125; &#125; 详解四种基本布局 线性布局LinearLayout线性布局会将所有的控件在线性方向上依次排列，水平或者垂直由布局属性里面的android:orientation决定 LinearLayout垂直排列 123456789101112131415161718192021&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ button1" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: text =" Button 1" /&gt; &lt; Button android: id ="@ + id/ button2" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: text =" Button 2" /&gt; &lt; Button android: id ="@ + id/ button3" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: text =" Button 3" /&gt; &lt;/ LinearLayout &gt; 如果排列方向为水平则控件layout_width属性不能设置为wrap_parent，同理排列方向为垂直layout_height属性不能设置为wrap_parent android:gravity属性用于指定文字在控件中的对齐方式，而android:layout_gravity用于指定控件在布局中的对齐方式，两种属性的可选值差不多，但是如果LinearLayout的排列方式是horizontal的时候，只有垂直方向的对齐方式才会生效，因为此时水平方向上的长度是不固定的，没添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。同理当LinearLayout的排列方向是 vertical时，只有水平方向上的对齐方式才会生效 指定layout_gravity的效果 123456789101112131415161718192021222324&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" horizontal" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ button1" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" top" android: text =" Button 1" /&gt; &lt; Button android: id ="@ + id/ button2" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center_ vertical" android: text =" Button 2" /&gt; &lt; Button android: id ="@ + id/ button3" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" bottom" android: text =" Button 3" /&gt; &lt;/ LinearLayout &gt; 由于目前 LinearLayout的排列方向是 horizontal，因此我们只能指定垂直方向上的排列方向，将第一个 Button的对齐方式指定为 top，第二个 Button的对齐方式指定为 center_ vertical，第三个 Button的对齐方式指定为 bottom android:layout_weight属性 这个属性允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要的作用 指定layout_weight的效果 123456789101112131415161718&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" horizontal" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; EditText android: id ="@ + id/ input_ message" android: layout_ width =" 0dp" android: layout_ height =" wrap_ content" android: layout_ weight =" 1" android: hint =" Type something" /&gt; &lt; Button android: id ="@ + id/ send" android: layout_ width =" 0dp" android: layout_ height =" wrap_ content" android: layout_ weight =" 1" android: text =" Send" /&gt; &lt;/ LinearLayout &gt; 由于我们使用了 android: layout_ weight属性，此时控件的宽度就不应该再由 android: layout_ width来决定，这里指定成 0dp是一种比较规范的写法 使用 layout_ weight实现宽度自适配效果 1234567891011121314151617&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" horizontal" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; EditText android: id ="@ + id/ input_ message" android: layout_ width =" 0dp" android: layout_ height =" wrap_ content" android: layout_ weight =" 1" android: hint =" Type something" /&gt; &lt; Button android: id ="@ + id/ send" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: text =" Send" /&gt; &lt;/ LinearLayout &gt; 这里我们仅指定了 EditText的 android: layout_ weight属性，并将 Button的宽度改回 wrap_ content。这表示 Button的宽度仍然按照 wrap_ content来计算，而 EditText则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服 相对布局RelativeLayoutRelativeLayout可以通过相对定位的方式让控件出现在布局的任何位置。也正因为如此， RelativeLayout中的属性非常多 相对于父布局定位效果 123456789101112131415161718192021222324252627282930313233343536373839&lt; RelativeLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ button1" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ alignParentLeft =" true" android: layout_ alignParentTop =" true" android: text =" Button 1" /&gt; &lt; Button android: id ="@ + id/ button2" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ alignParentRight =" true" android: layout_ alignParentTop =" true" android: text =" Button 2" /&gt; &lt; Button android: id ="@ + id/ button3" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ centerInParent =" true" android: text =" Button 3" /&gt; &lt; Button android: id ="@ + id/ button4" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ alignParentBottom =" true" android: layout_ alignParentLeft =" true" android: text =" Button 4" /&gt; &lt; Button android: id ="@ + id/ button5" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ alignParentBottom =" true" android: layout_ alignParentRight =" true" android: text =" Button 5" /&gt; &lt;/ RelativeLayout &gt; 相对于控件布局 123456789101112131415161718192021222324252627282930313233343536373839&lt; RelativeLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ button3" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ centerInParent =" true" android: text =" Button 3" /&gt; &lt; Button android: id ="@ + id/ button1" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ above ="@ id/ button3" android: layout_ toLeftOf ="@ id/ button3" android: text =" Button 1" /&gt; &lt; Button android: id ="@ + id/ button2" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ above ="@ id/ button3" android: layout_ toRightOf ="@ id/ button3" android: text =" Button 2" /&gt; &lt; Button android: id ="@ + id/ button4" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ below ="@ id/ button3" android: layout_ toLeftOf ="@ id/ button3" android: text =" Button 4" /&gt; &lt; Button android: id ="@ + id/ button5" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ below ="@ id/ button3" android: layout_ toRightOf ="@ id/ button3" android: text =" Button 5" /&gt; &lt;/ RelativeLayout &gt; RelativeLayout中还有另外一组相对于控件进行定位的属性，android: layout_ alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐， android: layout_ alignRight表示让一个控件的右边缘和另一个控件的右边缘对齐。此外，还有 android: layout_ alignTop和 android: layout_ alignBottom等 帧布局FrameLayout这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角 例如123456789101112131415&lt; FrameLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; TextView android: id ="@ + id/ text_ view" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: text =" This is TextView" /&gt; &lt; ImageView android: id ="@ + id/ image_ view" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: src ="@ mipmap/ ic_ launcher" /&gt; &lt;/ FrameLayout &gt; 此方式出来的布局都从左上角开始，ImageView叠加在TextView上面 还可以使用 layout_ gravity属性来指定控件在布局中的对齐方式，这和 LinearLayout中的用法是相似的1234567891011121314151617&lt; FrameLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; TextView android: id ="@ + id/ text_ view" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" left" android: text =" This is TextView" /&gt; &lt; ImageView android: id ="@ + id/ button" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" right" android: src ="@ mipmap/ ic_ launcher" /&gt; &lt;/ FrameLayout &gt; 总体来讲， FrameLayout由于定位方式的欠缺，导致它的应用场景也比较少 百分比布局由于 LinearLayout本身已经支持按比例指定控件的大小了，因此百分比布局只为 FrameLayout和 RelativeLayout进行了功能扩展，提供了 PercentFrameLayout和 PercentRelativeLayout这两个全新的布局 打开app/build.gradle文件，在dependencies闭包中添加如下内容 123456dependencies &#123; implementation fileTree( dir: 'libs', include: ['*. jar']) implementation 'com. android. support: appcompat-v7: 24. 2. 1' implementation 'com. android. support: percent: 24. 2. 1' testimplementation 'junit: junit: 4. 12' &#125; 修改activity_main.xml中的代码 1234567891011121314151617181920212223242526272829&lt; android. support. percent. PercentFrameLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" xmlns: app =" http:// schemas. android. com/ apk/ res-auto" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ button1" android: text =" Button 1" android: layout_ gravity =" left | top" app: layout_ widthPercent =" 50%" app: layout_ heightPercent =" 50%" /&gt; &lt; Button android: id ="@ + id/ button2" android: text =" Button 2" android: layout_ gravity =" right | top" app: layout_ widthPercent =" 50%" app: layout_ heightPercent =" 50%" /&gt; &lt; Button android: id ="@ + id/ button3" android: text =" Button 3" android: layout_ gravity =" left | bottom" app: layout_ widthPercent =" 50%" app: layout_ heightPercent =" 50%" /&gt; &lt; Button android: id ="@ + id/ button4" android: text =" Button 4" android: layout_ gravity =" right | bottom" app: layout_ widthPercent =" 50%" app: layout_ heightPercent =" 50%" /&gt; &lt;/ android. support. percent. PercentFrameLayout &gt; 最外层使用了 PercentFrameLayout，由于百分比布局并不是内置在系统 SDK当中的，所以需要把完整的包路径写出来。然后还必须定义一个 app的命名空间，这样才能使用百分比布局的自定义属性 ConstraintLayout上外教的移动开发作业要求用到这个，查了一下资料是后来才出现的，可能作者写书的时候没有这个 官方文档 创建自定义控件我们所用的所有控件都是直接或间接继承自 View的，所用的所有布局都是直接或间接继承自 ViewGroup的。 View是 Android中最基本的一种 UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在 View的基础之上又添加了各自特有的功能。而 ViewGroup则是一种特殊的 View，它可以包含很多子 View和子 ViewGroup，是一个用于放置控件和布局的容器 引入布局给每个活动引入一个自定义的标题栏 新建一个布局title.xml文件123456789101112131415161718192021222324252627282930313233&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: background ="@ drawable/ title_ bg" &gt; &lt; Button android: id ="@ + id/ title_ back" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center" android: layout_ margin =" 5dp" android: background ="@ drawable/ back_ bg" android: text =" Back" android: textColor ="# fff" /&gt; &lt; TextView android: id ="@ + id/ title_ text" android: layout_ width =" 0dp" android: layout_ height =" wrap_ content" android: layout_ gravity =" center" android: layout_ weight =" 1" android: gravity =" center" android: text =" Title Text" android: textColor ="# fff" android: textSize =" 24sp" /&gt; &lt; Button android: id ="@ + id/ title_ edit" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center" android: layout_ margin =" 5dp" android: background ="@ drawable/ edit_ bg" android: text =" Edit" android: textColor ="# fff" /&gt; &lt;/ LinearLayout &gt; 在 LinearLayout中分别加入了两个 Button和一个 TextView，左边的 Button可用于返回，右边的 Button可用于编辑，中间的 TextView则可以显示一段标题文本。android: background用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充，这里我提前准备好了 3张图片——title_ bg. png、 back_ bg. png和 edit_ bg. png，分别用于作为标题栏、返回按钮和编辑按钮的背景。另外，在两个 Button中我们都使用了 android: layout_ margin这个属性，它可以指定控件在上下左右方向上偏移的距离，当然也可以使用 android: layout_ marginLeft或 android: layout_ marginTop等属性来单独指定控件在某个方向上偏移的距离 使用标题栏 修改activity_main.xml中的代码 12345&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; include layout ="@ layout/ title" /&gt; &lt;/ LinearLayout &gt; 修改MainActivity文件隐藏系统自带的标题栏 1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); ActionBar actionbar = getSupportActionBar(); if (actionbar != null) &#123; actionbar. hide(); &#125; &#125; &#125; 这里我们调用了 getSupportActionBar()方法来获得 ActionBar的实例，然后再调用 ActionBar的 hide()方法将标题栏隐藏起来 创建自定义控件引入布局的技巧确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决 新建 TitleLayout继承自 LinearLayout，让它成为我们自定义的标题栏控件123456public class TitleLayout extends LinearLayout &#123; public TitleLayout( Context context, AttributeSet attrs) &#123; super( context, attrs); LayoutInflater. from( context). inflate( R. layout. title, this); &#125; &#125; 重写了 LinearLayout中带有两个参数的构造函数，在布局中引入 TitleLayout控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借助 LayoutInflater来实现了。通过 LayoutInflater的 from()方法可以构建出一个 LayoutInflater对象，然后调用 inflate()方法就可以动态加载一个布局文件， inflate()方法接收两个参数，第一个参数是要加载的布局文件的 id，这里我们传入 R. layout. title，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入 this 在布局文件中添加自定义控件,修改activity_main1234567&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; com. example. uicustomviews. TitleLayout android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" /&gt; &lt;/ LinearLayout &gt; 添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我们需要指明控件的完整类名，包名在这里是不可以省略的 为标题栏中的按钮注册点击事件,修改TitleLayout中的代码 1234567891011121314151617181920public class TitleLayout extends LinearLayout &#123; public TitleLayout( Context context, AttributeSet attrs) &#123; super( context, attrs); LayoutInflater. from( context). inflate( R. layout. title, this); Button titleBack = (Button) findViewById( R. id. title_ back); Button titleEdit = (Button) findViewById( R. id. title_ edit); titleBack. setOnClickListener( new OnClickListener() &#123; @Override public void onClick( View v) &#123; (( Activity) getContext()). finish(); &#125; &#125;); titleEdit. setOnClickListener( new OnClickListener() &#123; @Override public void onClick( View v) &#123; Toast. makeText( getContext(), "You clicked Edit button", Toast. LENGTH_ SHORT). show(); &#125; &#125;); &#125; &#125; 首先还是通过 findViewById()方法得到按钮的实例，然后分别调用 setOnClickListener()方法给两个按钮注册了点击事件，当点击返回按钮时销毁掉当前的活动，当点击编辑按钮时弹出一段文本，每当我们在一个布局中引入 TitleLayout时，返回按钮和编辑按钮的点击事件就已经自动实现好了，这就省去了很多编写重复代码的工作 ListView-最难用最常用的控件ListView简单用法 新建ListViewTest项目，自动创建活动，修改activity_main.xml中的代码12345678&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; ListView android: id ="@ + id/ list_ view" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" /&gt; &lt;/ LinearLayout &gt; 先加入一个ListView，然后再指定id和宽高 修改MainActivity中的代码1234567891011public class MainActivity extends AppCompatActivity &#123; private String[] data = &#123; "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango", "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango" &#125;; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); ArrayAdapter &lt; String &gt; adapter = new ArrayAdapter &lt; String &gt;( MainActivity. this, android. R. layout. simple_ list_ item_ 1, data); ListView listView = (ListView) findViewById( R. id. list_ view); listView. setAdapter( adapter); &#125; &#125; 数组中的数据是无法直接传递给 ListView的，我们还需要借助适配器来完成。 Android中提供了很多适配器的实现类，其中我认为最好用的就是 ArrayAdapter。它可以通过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入。 ArrayAdapter有多个构造函数的重载，你应该根据实际情况选择最合适的一种,由于我们提供的数据都是字符串，因此将 ArrayAdapter的泛型指定为 String，然后在 ArrayAdapter的构造函数中依次传入当前上下文、 ListView子项布局的 id，以及要适配的数据。注意，我们使用了 android. R. layout. simple_ list_ item_ 1作为 ListView子项布局的 id，这是一个 Android内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。这样适配器对象就构建好了,最后调用ListView的setAdapter方法，将构建好的适配器对象传递进去，这样ListView和数据之间的关联就建立完成了 定制ListView的界面这里是让水果旁边显示对应的图片 定义一个实体类，作为ListView适配器的适配类，新建类Fruit 1234567891011121314public class Fruit &#123; private String name; private int imageId; public Fruit( String name, int imageId) &#123; this. name = name; this. imageId = imageId; &#125; public String getName() &#123; return name; &#125; public int getImageId() &#123; return imageId; &#125; &#125; 为ListView的子项指定一个我们自定义的布局，在layout目录下新建fruit_item.xml 1234567891011121314&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" &gt; &lt; ImageView android: id ="@ + id/ fruit_ image" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" /&gt; &lt; TextView android: id ="@ + id/ fruit_ name" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center_ vertical" android: layout_ marginLeft =" 10dp" /&gt; &lt;/ LinearLayout &gt; 定义了一个ImageView用于显示水果的图片，又定义了一个TextView用来显示水果名字，并让TextView在垂直方向上居中显示 创建一个自定义的适配器，继承自ArrayAdapter，将泛型指定为Fruit类，新建FruitAdapter 123456789101112131415public class FruitAdapter extends ArrayAdapter &lt; Fruit &gt; &#123; private int resourceId; public FruitAdapter( Context context, int textViewResourceId, List &lt; Fruit &gt; objects) &#123; super( context, textViewResourceId, objects); resourceId = textViewResourceId; &#125; @Override public View getView( int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem( position); //获取当前项的 Fruit实例 View view = LayoutInflater. from( getContext()). inflate( resourceId, parent, false); ImageView fruitImage = (ImageView) view. findViewById( R. id. fruit_ image); TextView fruitName = (TextView) view. findViewById( R. id. fruit_ name); fruitImage. setImageResource( fruit. getImageId()); fruitName. setText( fruit. getName()); return view; &#125; &#125; FruitAdapter重写了父类的一组构造函数，用于将上下文、 ListView子项布局的 id和数据都传递进来。另外又重写了 getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 getView()方法中，首先通过 getItem()方法得到当前项的 Fruit实例，然后使用 LayoutInflater来为这个子项加载我们传入的布局 这里 LayoutInflater的 inflate()方法接收 3个参数，前两个参数我们已经知道是什么意思了，第三个参数指定成 false，表示只让我们在父布局中声明的 layout属性生效，但不会为这个 View添加父布局，因为一旦 View有了父布局之后，它就不能再添加到 ListView中了 接下来调用 View的 findViewById()方法分别获取到 ImageView和 TextView的实例，并分别调用它们的setImageResource()和 setText()方法来设置显示的图片和文字，最后将布局返回，这样我们自定义的适配器就完成了，修改MainActivity中的代码123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; private List &lt; Fruit &gt; fruitList = new ArrayList &lt; &gt;(); @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); initFruits(); //初始化水果数据 FruitAdapter adapter = new FruitAdapter( MainActivity. this, R. layout. fruit_ item, fruitList); ListView listView = (ListView) findViewById( R. id. list_ view); listView. setAdapter( adapter); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i + +) &#123; Fruit apple = new Fruit(" Apple", R. drawable. apple_ pic); fruitList. add( apple); Fruit banana = new Fruit(" Banana", R. drawable. banana_ pic); fruitList. add( banana); Fruit orange = new Fruit(" Orange", R. drawable. orange_ pic); fruitList. add( orange); Fruit watermelon = new Fruit(" Watermelon", R. drawable. watermelon_ pic); fruitList. add( watermelon); Fruit pear = new Fruit(" Pear", R. drawable. pear_ pic); fruitList. add( pear); Fruit grape = new Fruit(" Grape", R. drawable. grape_ pic); fruitList. add( grape); Fruit pineapple = new Fruit(" Pineapple", R. drawable. pineapple_ pic); fruitList. add( pineapple); Fruit strawberry = new Fruit(" Strawberry", R. drawable. strawberry_ pic); fruitList. add( strawberry); Fruit cherry = new Fruit(" Cherry", R. drawable. cherry_ pic); fruitList. add( cherry); Fruit mango = new Fruit(" Mango", R. drawable. mango_ pic); fruitList. add( mango); &#125; &#125; &#125; 这里添加了一个 initFruits()方法，用于初始化所有的水果数据。在 Fruit类的构造函数中将水果的名字和对应的图片 id传入，然后把创建好的对象添加到水果列表中。另外我们使用了一个 for循环将所有的水果数据添加了两遍，这是因为如果只添加一遍的话，数据量还不足以充满整个屏幕。接着在 onCreate()方法中创建了 FruitAdapter对象，并将 FruitAdapter作为适配器传递给 ListView，这样定制 ListView界面的任务就完成了 提升ListView的运行效率在 FruitAdapter的 getView()方法中，每次都将布局重新加载了一遍，当 ListView快速滚动的时候，这就会成为性能的瓶颈 使用convertViewcan参数进行缓存 修改FruitAdapter中的代码1234567891011121314151617public class FruitAdapter extends ArrayAdapter &lt; Fruit &gt; &#123; ... @Override public View getView( int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem( position); View view; if (convertView = = null) &#123; view = LayoutInflater. from( getContext()). inflate( resourceId, parent, false); &#125; else &#123; view = convertView; &#125; ImageView fruitImage = (ImageView) view. findViewById( R. id. fruit_ image); TextView fruitName = (TextView) view. findViewById( R. id. fruit_ name); fruitImage. setImageResource( fruit. getImageId()); fruitName. setText( fruit. getName()); return view; &#125; &#125; 在 getView()方法中进行了判断，如果 convertView为 null，则使用 LayoutInflater去加载布局，如果不为 null则直接对 convertView进行重用。这样就大大提高了 ListView的运行效率，在快速滚动的时候也可以表现出更好的性能 使用ViewHolder进行缓存 修改FruitAdapter中的代码123456789101112131415161718192021222324public class FruitAdapter extends ArrayAdapter &lt; Fruit &gt; &#123; ... @Override public View getView( int position, View convertView, ViewGroup parent) &#123; Fruit fruit = getItem( position); View view; ViewHolder viewHolder; if (convertView = = null) &#123; view = LayoutInflater. from( getContext()). inflate( resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder. fruitImage = (ImageView) view. findViewById (R. id. fruit_ image); viewHolder. fruitName = (TextView) view. findViewById (R. id. fruit_ name); view. setTag( viewHolder); //将 ViewHolder存储在 View中 &#125; else &#123; view = convertView; viewHolder = (ViewHolder) view. getTag(); //重新获取 ViewHolder &#125; viewHolder. fruitImage. setImageResource( fruit. getImageId()); viewHolder. fruitName. setText( fruit. getName()); return view; &#125; class ViewHolder &#123; ImageView fruitImage; TextView fruitName; &#125; &#125; 新增了一个内部类 ViewHolder，用于对控件的实例进行缓存。当 convertView为 null的时候，创建一个 ViewHolder对象，并将控件的实例都存放在 ViewHolder里，然后调用 View的 setTag()方法，将 ViewHolder对象存储在 View中。当 convertView不为 null的时候，则调用 View的 getTag()方法，把 ViewHolder重新取出。这样所有控件的实例都缓存在了 ViewHolder里，就没有必要每次都通过 findViewById()方法来获取控件实例了 ListView的点击事件修改MainActivity中的代码1234567891011121314151617181920public class MainActivity extends AppCompatActivity &#123; private List &lt; Fruit &gt; fruitList = new ArrayList &lt; &gt;(); @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); initFruits(); FruitAdapter adapter = new FruitAdapter( MainActivity. this, R. layout. fruit_ item, fruitList); ListView listView = (ListView) findViewById( R. id. list_ view); listView. setAdapter( adapter); listView. setOnItemClickListener( new AdapterView. OnItemClickListener() &#123; @Override public void onItemClick( AdapterView &lt;? &gt; parent, View view, int position, long id) &#123; Fruit fruit = fruitList. get( position); Toast. makeText( MainActivity. this, fruit. getName(), Toast. LENGTH_ SHORT). show(); &#125; &#125;); &#125; ... &#125; 使用 setOnItemClickListener()方法为 ListView注册了一个监听器，当用户点击了 ListView中的任何一个子项时，就会回调 onItemClick()方法。在这个方法中可以通过 position参数判断出用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast将水果的名字显示出来 更强大的滚动控件RecyclerViewRecyclerView可以说是一个增强版的ListView，目前安卓官方推荐使用RecyclerView RecyclerView基本用法由于RecyclerView是在support库中的 修改app/build.gradle文件，在dependencies中添加 12345dependencies &#123; implementation fileTree( dir: 'libs', include: ['*. jar']) implementation 'com. android. support: appcompat-v7: 24. 2. 1' implementation 'com. android. support: recyclerview-v7: 24. 2. 1' testimplementation 'junit: junit: 4. 12' &#125; 修改activity_main中的代码 12345678&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; android. support. v7. widget. RecyclerView android: id ="@ + id/ recycler_ view" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" /&gt; &lt;/ LinearLayout &gt; 直接将之前的Fruit类和fruit_item复制过来即可 为RecyclerView准备一个适配器 新建FruitAdapter类，并让这个适配器继承自RecyclerView.Adapter类，并将泛型指定为FruitAdapter.ViewHolder，其中ViewHolder是我们在FruitAdapter中定义的一个内部类12345678910111213141516171819202122232425262728293031public class FruitAdapter extends RecyclerView. Adapter &lt; FruitAdapter. ViewHolder &gt; &#123; private List &lt; Fruit &gt; mFruitList; static class ViewHolder extends RecyclerView. ViewHolder &#123; ImageView fruitImage; TextView fruitName; public ViewHolder( View view) &#123; super( view); fruitImage = (ImageView) view. findViewById( R. id. fruit_ image); fruitName = (TextView) view. findViewById( R. id. fruit_ name); &#125; &#125; public FruitAdapter( List &lt; Fruit &gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder( ViewGroup parent, int viewType) &#123; View view = LayoutInflater. from( parent. getContext()) .inflate( R. layout. fruit_ item, parent, false); ViewHolder holder = new ViewHolder( view); return holder; &#125; @Override public void onBindViewHolder( ViewHolder holder, int position) &#123; Fruit fruit = mFruitList. get( position); holder. fruitImage. setImageResource( fruit. getImageId()); holder. fruitName. setText( fruit. getName()); &#125; @Override public int getItemCount() &#123; return mFruitList. size(); &#125; &#125; 首先定义了一个内部类 ViewHolder， ViewHolder要继承自 RecyclerView. ViewHolder。然后 ViewHolder的构造函数中要传入一个 View参数，这个参数通常就是 RecyclerView子项的最外层布局，那么我们就可以通过 findViewById()方法来获取到布局中的 ImageView和 TextView的实例了 由于 FruitAdapter是继承自 RecyclerView. Adapter的，那么就必须重写 onCreateViewHolder()、 onBindViewHolder()和 getItemCount()这 3个方法。 onCreateViewHolder()方法是用于创建 ViewHolder实例的，我们在这个方法中将 fruit_ item布局加载进来，然后创建一个 ViewHolder实例，并把加载出来的布局传入到构造函数当中，最后将 ViewHolder的实例返回。 onBindViewHolder()方法是用于对 RecyclerView子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过 position参数得到当前项的 Fruit实例，然后再将数据设置到 ViewHolder的 ImageView和 TextView当中即可。 getItemCount()方法就非常简单了，它用于告诉 RecyclerView一共有多少子项，直接返回数据源的长度就可以了 修改MainActivity中的代码1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private List &lt; Fruit &gt; fruitList = new ArrayList &lt; &gt;(); @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); initFruits(); //初始化水果数据 RecyclerView recyclerView = (RecyclerView) findViewById( R. id. recycler_ view); LinearLayoutManager layoutManager = new LinearLayoutManager( this); recyclerView. setLayoutManager( layoutManager); FruitAdapter adapter = new FruitAdapter( fruitList); recyclerView. setAdapter( adapter); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i + +) &#123; Fruit apple = new Fruit(" Apple", R. drawable. apple_ pic); fruitList. add( apple); Fruit banana = new Fruit(" Banana", R. drawable. banana_ pic); fruitList. add( banana); Fruit orange = new Fruit(" Orange", R. drawable. orange_ pic); fruitList. add( orange); Fruit watermelon = new Fruit(" Watermelon", R. drawable. watermelon_ pic); fruitList. add( watermelon); Fruit pear = new Fruit(" Pear", R. drawable. pear_ pic); fruitList. add( pear); Fruit grape = new Fruit(" Grape", R. drawable. grape_ pic); fruitList. add( grape); Fruit pineapple = new Fruit(" Pineapple", R. drawable. pineapple_ pic); fruitList. add( pineapple); Fruit strawberry = new Fruit(" Strawberry", R. drawable. strawberry_ pic); fruitList. add( strawberry); Fruit cherry = new Fruit(" Cherry", R. drawable. cherry_ pic); fruitList. add( cherry); Fruit mango = new Fruit(" Mango", R. drawable. mango_ pic); fruitList. add( mango); &#125; &#125; &#125; 使用了一个同样的 initFruits()方法，用于初始化所有的水果数据。接着在 onCreate()方法中我们先获取到 RecyclerView的实例，然后创建了一个 LinearLayoutManager对象，并将它设置到 RecyclerView当中。 LayoutManager用于指定 RecyclerView的布局方式，这里使用的 LinearLayoutManager是线性布局的意思，可以实现和 ListView类似的效果。接下来我们创建了 FruitAdapter的实例，并将水果数据传入到 FruitAdapter的构造函数中，最后调用 RecyclerView的 setAdapter()方法来完成适配器设置，这样 RecyclerView和数据之间的关联就建立完成了 实现横向滚动和瀑布流布局除了 LinearLayoutManager之外， RecyclerView还给我们提供了 GridLayoutManager和 StaggeredGridLayoutManager这两种内置的布局排列方式。 GridLayoutManager可以用于实现网格布局， StaggeredGridLayoutManager可以用于实现瀑布流布局 横向滚动 修改fruit_item的布局12345678910111213141516&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" 100dp" android: layout_ height =" wrap_ content" &gt; &lt; ImageView android: id ="@ + id/ fruit_ image" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center_ horizontal" /&gt; &lt; TextView android: id ="@ + id/ fruit_ name" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center_ horizontal" android: layout_ marginTop =" 10dp" /&gt; &lt;/ LinearLayout &gt; 修改为垂直方向排列，宽度设置为100dp是因为每种水果名字长度不同，用wrap_content就会不好看，用match_parent又会造成一个子项占一个屏幕，因此指定宽度；将ImageView和TextView设置为在布局中水平居中，并且使用layout_marginTop让文字和图片之间保持一些距离 修改MainActivity中的代码123456789101112131415public class MainActivity extends AppCompatActivity &#123; private List &lt; Fruit &gt; fruitList = new ArrayList &lt; &gt;(); @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById( R. id. recycler_ view); LinearLayoutManager layoutManager = new LinearLayoutManager( this); layoutManager. setOrientation( LinearLayoutManager. HORIZONTAL); recyclerView. setLayoutManager( layoutManager); FruitAdapter adapter = new FruitAdapter( fruitList); recyclerView. setAdapter( adapter); &#125; ... &#125; MainActivity中加入一行代码调用LinearLayoutManager的setOrientation方法来设置布局的方向 瀑布流布局 修改fruit_item1234567891011121314151617&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: layout_ margin =" 5dp" &gt; &lt; ImageView android: id ="@ + id/ fruit_ image" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" center_ horizontal" /&gt; &lt; TextView android: id ="@ + id/ fruit_ name" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: layout_ gravity =" left" android: layout_ marginTop =" 10dp" /&gt; &lt;/ LinearLayout &gt; 瀑布流的宽度是根据列数来自动调整的，因此改为match_parent，设定layout_margin是为了不让所有项都紧贴在一起 修改MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends AppCompatActivity &#123; private List &lt; Fruit &gt; fruitList = new ArrayList &lt; &gt;(); @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. activity_ main); initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById( R. id. recycler_ view); StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager( 3, StaggeredGridLayoutManager. VERTICAL); recyclerView. setLayoutManager( layoutManager); FruitAdapter adapter = new FruitAdapter( fruitList); recyclerView. setAdapter( adapter); &#125; private void initFruits() &#123; for (int i = 0; i &lt; 2; i + +) &#123; Fruit apple = new Fruit( getRandomLengthName(" Apple"), R. drawable. apple_ pic); fruitList. add( apple); Fruit banana = new Fruit( getRandomLengthName(" Banana"), R. drawable. banana_ pic); fruitList. add( banana); Fruit orange = new Fruit( getRandomLengthName(" Orange"), R. drawable. orange_ pic); fruitList. add( orange); Fruit watermelon = new Fruit( getRandomLengthName(" Watermelon"), R. drawable. watermelon_ pic); fruitList. add( watermelon); Fruit pear = new Fruit( getRandomLengthName(" Pear"), R. drawable. pear_ pic); fruitList. add( pear); Fruit grape = new Fruit( getRandomLengthName(" Grape"), R. drawable. grape_ pic); fruitList. add( grape); Fruit pineapple = new Fruit( getRandomLengthName(" Pineapple"), R. drawable. pineapple_ pic); fruitList. add( pineapple); Fruit strawberry = new Fruit( getRandomLengthName(" Strawberry"), R. drawable. strawberry_ pic); fruitList. add( strawberry); Fruit cherry = new Fruit( getRandomLengthName(" Cherry"), R. drawable. cherry_ pic); fruitList. add( cherry); Fruit mango = new Fruit( getRandomLengthName(" Mango"), R. drawable. mango_ pic); fruitList. add( mango); &#125; &#125; private String getRandomLengthName( String name) &#123; Random random = new Random(); int length = random. nextInt( 20) + 1; StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; length; i + +) &#123; builder. append( name); &#125; return builder. toString(); &#125; &#125; 首先，在 onCreate()方法中，我们创建了一个 StaggeredGridLayoutManager的实例。 StaggeredGridLayoutManager的构造函数接收两个参数，第一个参数用于指定布局的列数，传入 3表示会把布局分为 3列；第二个参数用于指定布局的排列方向，传入 StaggeredGridLayoutManager. VERTICAL表示会让布局纵向排列，最后再把创建好的实例设置到 RecyclerView当中就可以了,由于瀑布流布局需要各个子项的高度不一致才能看出明显的效果，为此我又使用了一个小技巧。这里我们把眼光聚焦在 getRandomLengthName()这个方法上，这个方法使用了 Random对象来创造一个 1到 20之间的随机数，然后将参数中传入的字符串随机重复几遍。在 initFruits()方法中，每个水果的名字都改成调用 getRandomLengthName()这个方法来生成，这样就能保证各水果名字的长短差距都比较大，子项的高度也就各不相同了 添加点击事件在Adapter中添加点击事件ListView在点击事件上的处理并不人性化， setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里具体的某一个按钮呢？虽然 ListView也是能做到的，但是实现起来就相对比较麻烦了。为此， RecyclerView干脆直接摒弃了子项点击事件的监听器，所有的点击事件都由具体的 View去注册 修改FruitAdapter里面的代码123456789101112131415161718192021222324252627282930313233343536373839public class FruitAdapter extends RecyclerView. Adapter &lt; FruitAdapter. ViewHolder &gt; &#123; private List &lt; Fruit &gt; mFruitList; static class ViewHolder extends RecyclerView. ViewHolder &#123; View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder( View view) &#123; super( view); fruitView = view; fruitImage = (ImageView) view. findViewById( R. id. fruit_ image); fruitName = (TextView) view. findViewById( R. id. fruit_ name); &#125; &#125; public FruitAdapter( List &lt; Fruit &gt; fruitList) &#123; mFruitList = fruitList; &#125; @Override public ViewHolder onCreateViewHolder( ViewGroup parent, int viewType) &#123; View view = LayoutInflater. from( parent. getContext()). inflate( R. layout. fruit_ item, parent, false); final ViewHolder holder = new ViewHolder( view); holder. fruitView. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; int position = holder. getAdapterPosition(); Fruit fruit = mFruitList. get( position); Toast. makeText( v. getContext(), "you clicked view " + fruit. getName(), Toast. LENGTH_ SHORT). show(); &#125; &#125;); holder. fruitImage. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; int position = holder. getAdapterPosition(); Fruit fruit = mFruitList. get( position); Toast. makeText( v. getContext(), "you clicked image " + fruit. getName(), Toast. LENGTH_ SHORT). show(); &#125; &#125;); return holder; &#125; ... &#125; 先是修改了 ViewHolder，在 ViewHolder中添加了 fruitView变量来保存子项最外层布局的实例，然后在 onCreateViewHolder()方法中注册点击事件就可以了。这里分别为最外层布局和 ImageView都注册了点击事件， RecyclerView的强大之处也在这里，它可以轻松实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的 position，然后通过 position拿到相应的 Fruit实例，再使用 Toast分别弹出两种不同的内容以示区别 在Activity中添加点击事件2019.2.3更新：在学了上面的点击事件添加以后我在写项目的时候发现，我想要在一个Activity中添加点击事件用上面的方法是不行的，很多变量不能操作，下面的方法可以在Activity中为RecyclerView添加点击事件的处理 添加接口OnItemClickListener 1234public interface OnItemClickListener &#123; //由于在adapter中直接设置点击事件很多变量不知道怎么传，通过这个接口可以直接在MainActivity中注册点击事件 public void onItemClick(View view, int postion);&#125; 在ViewHolder中添加一个View 1View view; 在ViewHolder的构造函数中把itemView赋值给view 在Adapter中添加 1234567891011···private OnItemClickListener mOnItemClickListener;······public interface OnItemClickListener &#123; void onItemClick(View view, int position); &#125; public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; mOnItemClickListener = onItemClickListener; &#125; 在onBindViewHolder中添加 123456viewHolder.view..setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onItemClick(v,i); &#125; &#125;); 在活动中构建好列表视图后直接调用即可 123456adapter.setOnItemClickListener(new ProClassAdapter.OnItemClickListener() &#123; @Override public void onItemClick(View view, int position) &#123; //这里点击了课程，那么将课程的老师弄出来装进列表里弹出窗口 &#125; &#125;); adapter为Adapter的对象 编写界面最佳实践制作Nine—Patch图片这是一种被特殊处理过的png图片，能够指定哪些地方可以拉伸，哪些地方不可以 在 Android sdk目录下有一个 tools文件夹，在这个文件夹中找到 draw9patch. bat文件，我们就是使用它来制作 Nine-Patch图片的。不过，要打开这个文件，必须先将 JDK的 bin目录配置到环境变量当中才行，比如你使用的是 Android Studio内置的 jdk，那么要配置的路径就是 &lt; Android Studio安装目录 &gt;/ jre/ bin 注：实测Mac下把图片导入项目文件夹以后可以直接右键点击生成.9文件，双击文件编辑拉动边框的黑色可以指定拉伸的位置 制作.9图片是为了在拉伸的时候不会太难看，可以动态的调整图片样子 编写聊天界面 首先在app/build.gradle中添加依赖库 123456dependencies &#123; compile fileTree( dir: 'libs', include: ['*. jar']) compile 'com. android. support: appcompat-v7: 24. 2. 1' compile 'com. android. support: recyclerview-v7: 24. 2. 1' test Compile 'junit: junit: 4. 12' &#125; 修改主界面，修改activity_main中的代码 123456789101112131415161718192021222324252627&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" android: background ="# d8e0e8" &gt; &lt; android. support. v7. widget. RecyclerView android: id ="@ + id/ msg_ recycler_ view" android: layout_ width =" match_ parent" android: layout_ height =" 0dp" android: layout_ weight =" 1" /&gt; &lt; LinearLayout android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" &gt; &lt; EditText android: id ="@ + id/ input_ text" android: layout_ width =" 0dp" android: layout_ height =" wrap_ content" android: layout_ weight =" 1" android: hint =" Type something here" android: maxLines =" 2" /&gt; &lt; Button android: id ="@ + id/ send" android: layout_ width =" wrap_ content" android: layout_ height =" wrap_ content" android: text =" Send" /&gt; &lt;/ LinearLayout &gt; &lt;/ LinearLayout &gt; 放入一个RecyclerView用于显示消息，线性布局放入一个输入框一个发送按钮 新建消息的实体类Msg12345678910111213141516public class Msg &#123; public static final int TYPE_ RECEIVED = 0; public static final int TYPE_ SENT = 1; private String content; private int type; public Msg( String content, int type) &#123; this. content = content; this. type = type; &#125; public String getContent() &#123; return content; &#125; public int getType() &#123; return type; &#125; &#125; Msg中有两个字段，content表示消息的内容，type表示消息的类型，其中消息类型有两个值可以选择，一个是TYPE_RECEIVED，一个是TYPE_SENT 编写RecyclerView子项的布局，新建msg_item.xml文件，代码如下123456789101112131415161718192021222324252627282930313233&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="10dp" &gt; &lt;LinearLayout android:id="@+id/left_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="left" android:background="@drawable/message_left" &gt; &lt;TextView android:id="@+id/left_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" android:textColor="#fff" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/right_layout" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:background="@drawable/message_right" &gt; &lt;TextView android:id="@+id/right_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_margin="10dp" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 这里我们让收到的消息居左对齐，发出的消息居右对齐，并且分别使用message_left.9.png和message_right.9.png作为背景图 创建RecyclerView的适配器类，新建类MsgAdapter12345678910111213141516171819202122232425262728293031323334353637383940414243public class MsgAdapter extends RecyclerView.Adapter&lt;MsgAdapter.ViewHolder&gt; &#123; private List&lt;Msg&gt; mMsgList; static class ViewHolder extends RecyclerView.ViewHolder &#123; LinearLayout leftLayout; LinearLayout rightLayout; TextView leftMsg; TextView rightMsg; public ViewHolder(View view) &#123; super(view); leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); leftMsg = (TextView) view.findViewById(R.id.left_msg); rightMsg = (TextView) view.findViewById(R.id.right_msg); &#125;&#125; public MsgAdapter(List&lt;Msg&gt; msgList) &#123; mMsgList = msgList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; Msg msg = mMsgList.get(position); if (msg.getType() == Msg.TYPE_RECEIVED) &#123; // 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏 holder.leftLayout.setVisibility(View.VISIBLE); holder.rightLayout.setVisibility(View.GONE); holder.leftMsg.setText(msg.getContent()); &#125; else if(msg.getType() == Msg.TYPE_SENT) &#123; // 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏 holder.rightLayout.setVisibility(View.VISIBLE); holder.leftLayout.setVisibility(View.GONE); holder.rightMsg.setText(msg.getContent()); &#125; &#125; @Override public int getItemCount() &#123; return mMsgList.size(); &#125;&#125; 这里增加了onBindViewHolder来判断消息发出的类型以便进行视图调整，如果是收到的，则显示左边布局，同理发出的显示右边布局 最后修改MainActivity中的代码1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity &#123; private List&lt;Msg&gt; msgList = new ArrayList&lt;&gt;(); private EditText inputText; private Button send; private RecyclerView msgRecyclerView; private MsgAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initMsgs(); // 初始化消息数据 inputText = (EditText) findViewById(R.id.input_text); send = (Button) findViewById(R.id.send); msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); msgRecyclerView.setLayoutManager(layoutManager); adapter = new MsgAdapter(msgList); msgRecyclerView.setAdapter(adapter); send.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String content = inputText.getText().toString(); if (!"".equals(content)) &#123; Msg msg = new Msg(content, Msg.TYPE_SENT); msgList.add(msg); adapter.notifyItemInserted(msgList.size() - 1); // 当有新消息时，刷新RecyclerView中的显示 msgRecyclerView.scrollToPosition(msgList.size() - 1); // 将RecyclerView定位到最后一行 inputText.setText(""); // 清空输入框中的内容 &#125; &#125; &#125;); &#125; private void initMsgs() &#123; Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED); msgList.add(msg1); Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SENT); msgList.add(msg2); Msg msg3 = new Msg("This is Tom. Nice talking to you. ", Msg.TYPE_RECEIVED); msgList.add(msg3); &#125;&#125; 在initMsgs()方法中我们先初始化了几条数据用于在RecyclerView中显示。然后在发送按钮的点击事件里获取了EditText中的内容，如果内容不为空字符串则创建出一个新的Msg对象，并把它添加到msgList列表中去。之后又调用了适配器的notifyItemInserted()方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在RecyclerView中显示。接着调用RecyclerView的scrollToPosition()方法将显示的数据定位到最后一行，以保证一定可以看得到最后发出的一条消息。最后调用EditText的setText()方法将输入的内容清空 最后附上最后的测试图]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>布局</tag>
        <tag>UI</tag>
        <tag>控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章：认识活动、Intent、活动的生命周期、活动的启动模式、实践]]></title>
    <url>%2F2018%2F11%2F12%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%AE%A4%E8%AF%86%E6%B4%BB%E5%8A%A8%E3%80%81Intent%E3%80%81%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E3%80%81%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[没有特别说明用的都是Android Studio 手动创建一个活动 创建一个项目，选择不创建任何活动 创建一个活动FirstActivity，不勾选Generate Layout和Launcher Activity这两个选项（Launcher表示设置为当前项目的主活动） 手动创建一个布局文件：在app/src/main/res创建一个layout目录，然后在目录内创建一个Layout resource file，命名为first_layout 可以编辑此布局文件 加载布局：回到创建的活动，在onCreate()方法中加入代码setContentView(R.layout.first_layout)这里调用了setContentView方法给当前活动加载了一个布局 在AndroidManifest文件中注册（所有活动都需要在此文件中注册才能生效），实际上使用Android Studio的时候会自动注册上，代码&lt;activity android:name=&quot;.FirstActivity&gt;&lt;/activity&gt;在此文件中，最外层通过package=&quot;com.example.activitytest&quot;指定了包名，因此.FirstActivity实际上是com.example.activitytest.FirstActivity的缩写 但是这样仅仅是注册了这个活动，没有指定程序的主活动，因此在&lt;activity&gt;标签中加入&lt;intent-filter&gt;标签，在此标签内添加&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;和&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; 还可以在&lt;activity&gt;标签中添加android:label=”xxxx”来指定标题栏，会显示在活动最顶部 使用Toast例：点击按钮以后弹出通知在布局文件中添加了按钮button_1,然后在活动的函数如下12345678910protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. first_ layout); Button button1 = (Button) findViewById( R. id. button_ 1); button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Toast. makeText( FirstActivity. this, "You clicked Button 1", Toast. LENGTH_ SHORT). show(); &#125; &#125;); &#125; makeText需要传入三个参数，第一个是Context即上下文，活动本身就是一个Context对象因此直接传入FirstActivity.this即可，第二个参数是想显示的内容，第三个参数是内置常量控制显示时长 在活动中加载Menu 在res文件夹中新建文件夹menu，然后创建一个新的Menu resource文件，这里命名为main 在main.xml中添加代码 12345//这里创建了两个菜单项，&lt;item&gt;标签就是用来创建具体的菜单项的&lt; menu xmlns: android =" http:// schemas. android. com/ apk/ res/ android" &gt; &lt; item android: id ="@ + id/ add_ item" android: title =" Add"/ &gt; &lt; item android: id ="@ + id/ remove_ item" android: title =" Remove"/ &gt; &lt;/ menu &gt; 回到FirstActivity中添加代码，使用快捷键重写onCreateOptionsMenu()方法，Mac快捷键是control+o，Win是ctrl+o 1234public boolean onCreateOptionsMenu( Menu menu) &#123; getMenuInflater(). inflate( R. menu. main, menu); return true; &#125; getMenuInflater函数获得MenuInflater对象，然后调用inflate函数给当前活动创建菜单，inflate函数接收两个参数，第一个用于指定使用哪一个资源文件创建菜单，第二个参数用于指定我们的菜单项添加到哪一个Menu对象中，这里直接用的menu，最后return true表示让此菜单显示出来 给菜单添加响应事件123456789101112public boolean onOptionsItemSelected( MenuItem item) &#123; switch (item. getItemId()) &#123; case R. id. add_ item: Toast. makeText( this, "You clicked Add", Toast. LENGTH_ SHORT). show(); break; case R. id. remove_ item: Toast. makeText( this, "You clicked Remove", Toast. LENGTH_ SHORT). show(); break; default: &#125; return true; &#125; 这样就添加了菜单的响应函数，点击相应的按钮会显示相应的功能 销毁一个活动 按钮添加一个监听函数直接finish()，与按下back键的效果是一样的 Intent的使用（在活动之间传递数据）显示Intent 在之前的基础上创建一个activity，这里命名为SecondActivity，勾选generate layout file，这里布局文件就叫second_layout，不要勾选launcher选项 编辑此活动的布局文件，添加一个按钮 修改FirstActivity中的按钮点击时间，改为如下代码 123456button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( FirstActivity. this, SecondActivity. class); startActivity( intent); &#125; &#125;); 这里首先是构造出一个intent，然后传入FirstActivity.this作为上下文，传入SecondActivity.class作为目标活动，然后直接调用StartActivity并传入构建的intent即可启动 隐式Intent隐式Intent不指明我想启动哪一个活动，而是制定了比较抽象的action和category，交给系统去分析启动合适的活动来处理 在SecondActivity的&lt;activity&gt;标签中配置&lt;intent-filter&gt;123456&lt; activity android: name =". SecondActivity" &gt; &lt; intent-filter &gt; &lt; action android: name =" com. example. activitytest. ACTION_ START" /&gt; &lt; category android: name =" android. intent. category. DEFAULT" /&gt; &lt;/ intent-filter &gt; &lt;/ activity &gt; 这里指定此活动能够响应com.example.activitytest.ACTION_START这个action，&lt;category&gt;包含了一些附加信息，更精确指明了当前的活动能够响应的Intent中还可能带有的category，只有action和category中的内容同时匹配上，这个活动才会响应intent 修改FirstActivity中的按钮响应函数1234567button1. setOnClickListener( new View. OnClickListener()&#123; @Override public void onClick( View v) &#123; Intent intent = new Intent(" com. example. activitytest. ACTION_ START"); startActivity( intent); &#125; &#125;); 这里使用了Intent的另外一个构造函数，不指定categoty就会使用默认的值每个Intent只能指定一个action，可以指定多个category 如果为intent添加一个category1234567button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent(" com. example. activitytest. ACTION_ START"); intent. addCategory(" com. example. activitytest. MY_ CATEGORY"); startActivity( intent); &#125;&#125;); 此时点击按钮程序会崩溃，因为没有任何活动可以响应指定的intent，然后在SecondActivity的&lt;intent-filter&gt;标签中添加&lt;category&gt;标签1234567&lt; activity android: name =". SecondActivity" &gt; &lt; intent-filter &gt; &lt; action android: name =" com. example. activitytest. ACTION_ START" /&gt; &lt; category android: name =" android. intent. category. DEFAULT" /&gt; &lt; category android: name =" com. example. activitytest. MY_ CATEGORY"/ &gt; &lt;/ intent-filter &gt; &lt;/ activity &gt; 添加了指定的category即可避免崩溃 使用Intent在活动之间传递数据传递数据给下一个活动Intent中提供了一系列putExtra()方法的重载，可以把我们想传递的数据添加到Intent中,比如FirstActivity中有一个字符串，把这个字符串传到SecondActivity中12345678button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; String data = "Hello SecondActivity"; Intent intent = new Intent( FirstActivity. this, SecondActivity. class); intent. putExtra(" extra_ data", data); startActivity( intent); &#125; &#125;); putExtra函数有两个参数，第一个是键，第二个是需要传过去的值，在SecondActivity中要有相应的代码来对应取出这串字符串12345678public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); setContentView( R. layout. second_ layout); Intent intent = getIntent(); String data = intent. getStringExtra(" extra_ data"); Log. d(" SecondActivity", data); &#125; &#125; 在SecondActivity中也要构建一个intent，然后通过getIntent()方法获取到用于启动SecondActivity的Intent，然后调用getStringExtra，传入键即可获得，如果是整型就调用getIntExtra，别的类型同理 返回数据给上一个活动Activity中还有一个启动活动的函数叫做startActivityForResult，这个方法期望在活动销毁的时候能够返回数据给上一个活动，接收两个参数，第一个是Intent，第二个是请求码，请求码用于在之后的回调中判断数据的来源 例：修改FirstActivity中的按钮点击事件 1234567button1.setOnClickListener(new View.OnClickListener()&#123; @override public void onClick(View v)&#123; Intent intent=new Intent(FirstActivity.this, SecondActivity.class); startActivityForResult(intent,1); &#125;&#125;); 请求码只需要保证是唯一的值就行了，这里传入1。 给SecondActivity中的按钮添加点击事件 12345678910Button button2=(Button)findViewById(R.id.button_2);button2.setOnClickListener(new View.OnClickListener()&#123; @override public void onClick(View v)&#123; Intent intent=new Intent(); intent.putExtra("data_return","Hello FirstActivity"); setResult(RESULT_OK,intent); finish(); &#125;&#125;); 此处的Intent仅仅用来传递数据，setResult函数是专门用来向上一个活动传递数据的，第一个参数为处理结果，通常用RESULT_OK和RESULT_CALCELED，第二个参数把生成的Intent传回去 由于我们是使用startActivityForResult()方法来启动SecondActivity的，在 SecondActivity被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity中重写这个方法来得到返回的数据 123456789101112@Override protected void onActivityResult( int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode = = RESULT_ OK) &#123; String returnedData = data. getStringExtra(" data_ return"); Log. d(" FirstActivity", returnedData); &#125; break; default: &#125; &#125; onActivityResult有三个参数，第一个是requestCode，即我们启动活动的时候传入的请求码，第二个参数resultCode，即我们返回数据时传入的处理结果，第三个参数data即携带着返回数据的Intent 由于在活动中可能调用startActivityForResult去启动很多不同的应用，每一个活动返回时都会回调onActivityResult这个函数，因此我们首先要检查requestCode来判断数据来源，然后通过resultCode来判断处理结果是否成功，最后从data中取出值并打印出来 这是通过按钮返回上一个活动，如果想通过返回键返回以后并返回数据，则要重写SecondActivity的onBackPressed函数，例 123456@Override public void onBackPressed() &#123; Intent intent = new Intent(); intent. putExtra(" data_ return", "Hello FirstActivity"); setResult( RESULT_ OK, intent); finish(); &#125; 更多隐式Intent用法例，调用浏览器打开一个网页12345678button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( Intent. ACTION_ VIEW); intent. setData( Uri. parse(" http:// www. baidu. com")); startActivity( intent); &#125; &#125;); 此处指定了一个intent，调用setData函数，Uri.parse函数是将一个网址解析成一个Uri对象，再调用setData函数将Uri对象传递进去 setData函数接收一个 Uri对象，主要用于指定当前 Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到 Uri. parse()方法中解析产生的 与此对应，我们可以在活动的&lt;intent-filter&gt;标签中配置一个&lt;data&gt;标签 android: scheme用于指定数据的协议部分，如上例中的 http部分 android: host用于指定数据的主机名部分，如上例中的 www. baidu. com部分 android: port用于指定数据的端口部分，一般紧随在主机名之后 android: path用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容 android: mimeType用于指定可以处理的数据类型，允许使用通配符的方式进行指定 只有&lt;data&gt;标签中的内容和Intent中的完全一致时，活动才会响应相应的Intent，一般不会指定过多的&lt;data&gt; 例如创建一个活动响应网页打开的Intent 新建一个活动ThirdActivity，布局文件third_layout，代码如下 12345678&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ button_ 3" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: text =" Button 3" /&gt; &lt;/ LinearLayout &gt; 修改ThirdActivity在AndroidManifest中的注册信息 123456&lt; activity android: name =". ThirdActivity" &gt; &lt; intent-filter &gt; &lt; action android: name =" android. intent. action. VIEW" /&gt; &lt; category android: name =" android. intent. category. DEFAULT" /&gt; &lt; data android: scheme =" http" /&gt; &lt;/ intent-filter &gt; &lt;/ activity &gt; &lt;data&gt;标签指定了响应http请求，这样点击一个网页的时候就会弹出这个活动的选项. 例如调用打电话活动 1234567button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( Intent. ACTION_ DIAL); intent. setData( Uri. parse(" tel: 10086")); startActivity( intent); &#125; &#125;); 这里指定的action是ACTION_DIAL 活动的生命周期返回栈Android中的活动是可以层叠的。我们每启动一个新的活动，就会覆盖在原活动之上，然后点击 Back键会销毁最上面的活动，下面的一个活动就会重新显示出来。其实 Android是使用任务（ Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（ Back Stack） 活动状态 运行状态：当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。 暂停状态：当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。你可能会觉得既然活动已经不在栈顶了，还怎么会可见呢？这是因为并不是每一个活动都会占满整个屏幕的，比如对话框形式的活动只会占用屏幕中间的部分区域。处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种活动。 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。 销毁状态：当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。 活动的生存期Activity类中定义了 7个回调方法 onCreate()：这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。 onStart()。这个方法在活动由不可见变为可见的时候调用。 onResume()。这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。 onPause()。这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗 CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。 onStop()。这个方法在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。 onDestroy()。这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。 onRestart()。这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。 以上 7个方法中除了 onRestart()方法，其他都是两两相对的，从而又可以将活动分为3种生存期 完整生存期。活动在 onCreate()方法和 onDestroy()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在 onCreate()方法中完成各种初始化操作，而在 onDestroy()方法中完成释放内存的操作。 可见生存期。活动在 onStart()方法和 onStop()方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在 onStart()方法中对资源进行加载，而在 onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。 前台生存期。活动在 onResume()方法和 onPause()方法之间所经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我们平时看到和接触最多的也就是这个状态下的活动。 体验活动的生命周期 创建新项目ActivityLifeCycleTest，勾选创建新活动，再创建两个子活动分别为NormalActivity和DialogActivity布局文件分别为normal_layout和dialog_layout 编辑normal_layout文件 12345678&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; TextView android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: text =" This is a normal activity" /&gt; &lt;/ LinearLayout &gt; 编辑dialog_layout文件 123456789&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; TextView android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: text =" This is a dialog activity" /&gt; &lt;/ LinearLayout &gt; 修改AndroidManifest中的&lt;activity&gt;标签配置 1234567&lt; activity android: name =". NormalActivity" &gt; &lt;/ activity &gt; &lt; activity android: name =". DialogActivity" android: theme ="@ style/ Theme. AppCompat. Dialog" &gt; &lt;/ activity &gt; 对DialogActivity使用了一个@style/Theme.AppCompat.Dialog，意思是让DialogActivity使用对话框的形式 修改activity_main定制主活动布局 12345678910111213141516&lt; LinearLayout xmlns: android =" http:// schemas. android. com/ apk/ res/ android" android: orientation =" vertical" android: layout_ width =" match_ parent" android: layout_ height =" match_ parent" &gt; &lt; Button android: id ="@ + id/ start_ normal_ activity" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: text =" Start NormalActivity" /&gt; &lt; Button android: id ="@ + id/ start_ dialog_ activity" android: layout_ width =" match_ parent" android: layout_ height =" wrap_ content" android: text =" Start DialogActivity" /&gt; &lt;/ LinearLayout &gt; 最后修改MainActivity中的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; public static final String TAG = "MainActivity"; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d( TAG," onCreate"); setContentView( R. layout. activity_ main); Button startNormalActivity = (Button) findViewById( R. id. start_ normal_ activity); Button startDialogActivity = (Button) findViewById( R. id. start_ dialog_ activity); startNormalActivity. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( MainActivity. this, NormalActivity. class); startActivity( intent); &#125; &#125;); startDialogActivity. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( MainActivity. this, DialogActivity. class); startActivity( intent); &#125; &#125;); &#125; @Override protected void onStart() &#123; super. onStart(); Log. d( TAG, "onStart"); &#125; @Override protected void onResume() &#123; super. onResume(); Log. d( TAG, "onResume"); &#125; @Override protected void onPause() &#123; super. onPause(); Log. d( TAG, "onPause"); &#125; @Override protected void onStop() &#123; super. onStop(); Log. d( TAG, "onStop"); &#125; @Override protected void onDestroy() &#123; super. onDestroy(); Log. d( TAG, "onDestroy"); &#125; @Override protected void onRestart() &#123; super. onRestart(); Log. d( TAG, "onRestart"); &#125; &#125; 处理活动被回收的情况设想：有一个活动A，在A的基础上启动了B，然后A意外被系统回收，此时用户按下back键，就会返回到A，但是时调用A的onCreate方法创建了一个A，如果A上有临时数据就会消失，为了解决这个问题，Activity提供了一个函数onSaveInstanceState方法，保证活动在被销毁的时候一定调用这个函数，此函数携带一个Bundle类型的参数，Bundle提供了一系列方法用于保存数据，不如putString方法保存字符串，putInt方法保存整形变量，每个保存方法传入两个参数，第一个参数是键，第二个是真正要保存的内容 在MainActivity中重写onSaveInstanceState函数就可以保存数据 123456@Override protected void onSaveInstanceState( Bundle outState) &#123; super. onSaveInstanceState( outState); String tempData = "Something you just typed"; outState. putString(" data_ key", tempData); &#125; 修改onCreate方法 1234567891011@Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d( TAG, "onCreate"); setContentView( R. layout. activity_ main); if (savedInstanceState != null) &#123; String tempData = savedInstanceState. getString(" data_ key"); Log. d( TAG, tempData); &#125; ... &#125; 取出值以后再进行赋值就可以获得我们想要的东西了 Intent可以和Bundle一起用，先将所有数据保存在Bundle中，然后再将Bundle放进Intent中，到了目标活动再取出Intent，再从Bundle中取出数据即可 活动的启动模式活动启动模式一共有4种，分别是standard、singleTop、singleTask、singleInstance，可以在AndroidManifest中给&lt;activity&gt;标签指定android:launchMode属性来选择启动模式 standardstandard是活动的默认启动模式，在 standard模式（即默认情况）下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用 standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例 singleTop当活动的启动模式指定为 singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例 singleTask当活动的启动模式指定为 singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。 singleInstance不同于以上 3种启动模式，指定为 singleInstance模式的活动会启用一个新的返回栈来管理这个活动（其实如果 singleTask模式指定了不同的 taskAffinity，也会启动一个新的返回栈），不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。 singleInstance实践 修改AndroidManifest里面SecondActivity的启动模式 1234567&lt; activity android: name =". SecondActivity" android: launchMode =" singleInstance" &gt; &lt; intent-filter &gt; &lt; action android: name =" com. example. activitytest. ACTION_ START" /&gt; &lt; category android: name =" android. intent. category. DEFAULT" /&gt; &lt; category android: name =" com. example. activitytest. MY_ CATEGORY" /&gt; &lt;/ intent-filter &gt; &lt;/ activity &gt; 修改FirstActivity中onCreate中的代码 12345678910111213@Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d(" FirstActivity", "Task id is " + getTaskId()); setContentView( R. layout. first_ layout); Button button1 = (Button) findViewById( R. id. button_ 1); button1. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( FirstActivity. this, SecondActivity. class); startActivity( intent); &#125; &#125;); &#125; 在onCreate中打印了当前返回栈的id 修改SecondActivity中onCreate的代码 12345678910111213@Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d(" SecondActivity", "Task id is " + getTaskId()); setContentView( R. layout. second_ layout); Button button2 = (Button) findViewById( R. id. button_ 2); button2. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; Intent intent = new Intent( SecondActivity. this, ThirdActivity. class); startActivity( intent); &#125; &#125;); &#125; 同样打印了当前返回栈的id，并修改了按钮代码用于启动ThirdActivity 修改ThirdActivity中的onCreate代码 12345@Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d(" ThirdActivity", "Task id is " + getTaskId()); setContentView( R. layout. third_ layout); &#125; 最终在FirstActivity中启动SecondActivity，然后在SecondActivity中启动ThirdActivity，会发现FirstActivity和ThirdActivity的返回栈id一样，SecondActivity不一样，按下返回键会返回到FirstActivity，再按下返回键会返回到SecondActivity 活动管理器（知晓、管理活动） 创建BaseActivity类这里的BaseActivity类不需要在AndroidManifest中注册，因此创建为普通的java类，继承AppCompatActivity类，重写onCreate方法1234567public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d(" BaseActivity", getClass(). getSimpleName()); &#125; &#125; 在onCreate中打印出当前实例的类名，接下来修改所有活动的父类，让它们继承BaseActivity即可 随时退出程序（活动管理器） 创建一个ActivityCollector类，代码如下1234567891011121314151617public class ActivityCollector &#123; public static List &lt; Activity &gt; activities = new ArrayList &lt; &gt;(); public static void addActivity( Activity activity) &#123; activities. add( activity); &#125; public static void removeActivity( Activity activity) &#123; activities. remove( activity); &#125; public static void finishAll() &#123; for (Activity activity : activities) &#123; if (! activity. isFinishing()) &#123; activity. finish(); &#125; &#125; activities. clear(); &#125; &#125; 通过一个List来暂存活动，然后提供了一个addActivity方法用于向List中添加一个活动，提供removeActivity方法用于从List中移除活动，最后一个finishAll用于将List中的活动全部销毁。 修改BaseActivity中的代码12345678910111213public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d(" BaseActivity", getClass(). getSimpleName()); ActivityCollector. addActivity( this); &#125; @Override protected void onDestroy() &#123; super. onDestroy(); ActivityCollector. removeActivity( this); &#125; &#125; 在 BaseActivity的 onCreate()方法中调用了ActivityCollector的addActivity()方法，表明将当前正在创建的活动添加到活动管理器里。然后在BaseActivity中重写onDestroy()方法，并调用了ActivityCollector的removeActivity()方法，表明将一个马上要销毁的活动从活动管理器里移除。从此以后，不管你想在什么地方退出程序，只需要调用 ActivityCollector. finishAll()方法就可以了 例如1234567891011121314151617public class ThirdActivity extends BaseActivity &#123; @Override protected void onCreate( Bundle savedInstanceState) &#123; super. onCreate( savedInstanceState); Log. d(" ThirdActivity", "Task id is " + getTaskId()); setContentView( R. layout. third_ layout); Button button3 = (Button) findViewById( R. id. button_ 3); button3. setOnClickListener( new View. OnClickListener() &#123; @Override public void onClick( View v) &#123; //确保杀死进程 android.os.Process.killProcess(android.os.Process.myPid(); ActivityCollector. finishAll(); &#125; &#125;); &#125; &#125; 启动活动的最佳写法 在活动中构建ActionStart函数，以SecondActivity为例123456789public class SecondActivity extends BaseActivity &#123; public static void actionStart( Context context, String data1, String data2) &#123; Intent intent = new Intent( context, SecondActivity. class); intent. putExtra(" param1", data1); intent. putExtra(" param2", data2); context. startActivity( intent); &#125; ... &#125; 在 SecondActivity中添加了一个 actionStart()方法，在这个方法中完成了 Intent的构建，另外所有 SecondActivity中需要的数据都是通过 actionStart()方法的参数传递过来的，然后把它们存储到 Intent中，最后调用 startActivity()方法启动 SecondActivity 现在在FirstActivity中启动SecondActivity的方法如下 123456button1. setOnClickListener( new OnClickListener() &#123; @Override public void onClick( View v) &#123; SecondActivity. actionStart( FirstActivity. this, "data1", "data2"); &#125; &#125;); 这样代码就清晰很多，启动活动需要的数据也全部清楚]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>活动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章：Android系统架构、组件、日志区分、java项目文件结构]]></title>
    <url>%2F2018%2F11%2F12%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AAndroid%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E3%80%81%E7%BB%84%E4%BB%B6%E3%80%81%E6%97%A5%E5%BF%97%E5%8C%BA%E5%88%86%E3%80%81java%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Android系统架构 Linux内核层：为设备硬件提供驱动 系统运行库层：通过一些C/C++库来为Android提供主要特性支持 应用框架层：提供了构建应用程序时可能用到的各种 API 应用层：所有安装在手机上的应用程序都是属于这一层的 Android四大组件活动（ Activity）、服务（ Service）、广播接收器（ Broadcast Receiver）和内容提供器（ Content Provider），凡是在应用中你看得到的东西，都是放在活动中的 几种日志级别 Log. v()：用于打印那些最为琐碎的、意义最小的日志信息。对应级别 verbose，是 Android日志里面级别最低的一种。 Log. d()：用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别 debug，比 verbose高一级。 Log. i()：用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别 info，比 debug高一级。 Log. w()：用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别 warn，比 info高一级。 Log. e()：用于打印程序中的错误信息，比如程序进入到了 catch语句当中。当有错误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别 error，比 warn高一级 java项目的文件结构 Src：存放的java源代码文件 Gen：自动生成当前应用的配置文件 Android X.X.X文件夹：开发当前应用需要的一些类库 Assets：存放资源文件，但是编译的时候不会自动生成id，不会占用空间 Bin：自动存放应用被编译生成的文件 Res：存放应用用到的所有资源，如图片布局等，编译的时候会占用应用空间 Drawable：存放不同分辨率的图片，为了在不同分辨率手机上运行 Layout：布局配置文件，格式是xml Values：也是布局文件，比如长宽高，颜色等等，values-vXX对应的不同安卓版本的布局文件，类似不同分辨率 AndroidMainfest.xml：清单文件，配置一些与应用有关的重要信息，包含包名、权限、程序组件等等]]></content>
      <categories>
        <category>第一行代码Android</category>
      </categories>
      <tags>
        <tag>Android架构</tag>
        <tag>组件</tag>
        <tag>日志等级</tag>
        <tag>java项目结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
